/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { CoordinateConverter } from '../../../angular-cesium/services/coordinate-converter/coordinate-converter.service';
import { EditActions } from '../../models/edit-actions.enum';
import { EditModes } from '../../models/edit-mode.enum';
import { PolylinesEditorService } from '../../services/entity-editors/polyline-editor/polylines-editor.service';
/**
 *
 * Range and bearing component that is used to draw range and bearing on the map.
 * The inputs are used to customize the range and bearing style and behavior.
 * Create component reference and use the `create()` function to start creating R&B on the map.
 * The function receives an optional RangeAndBearingOptions object that defines the created range and bearing style and behavior
 * (on top of the default and global definitions).
 *
 * Usage:
 *
 * my-component.ts:
 *
 * ```
 * \\@ViewChild('rangeAndBearing') private rangeAndBearing: RangeAndBearingComponent; // Get R&B reference
 *  // ...
 * this.rangeAndBearing.create({style: { pointProps: { pixelSize: 12 } }, bearingLabelsStyle: { fillColor: Cesium.Color.GREEN } });
 * ```
 *
 * my-component.html
 * ```
 * <range-and-bearing #rangeAndBearing></range-and-bearing> // Optional inputs defines global style and behavior.
 * ```
 *
 */
export class RangeAndBearingComponent {
    /**
     * @param {?} polylineEditor
     * @param {?} coordinateConverter
     */
    constructor(polylineEditor, coordinateConverter) {
        this.polylineEditor = polylineEditor;
        this.coordinateConverter = coordinateConverter;
        this.lineEditOptions = {};
        this.labelsStyle = {};
        this.distanceLabelsStyle = {};
        this.bearingLabelsStyle = {};
    }
    /**
     * @param {?=} __0
     * @return {?}
     */
    create({ lineEditOptions = {}, labelsStyle = {}, distanceLabelsStyle = {}, bearingLabelsStyle = {}, bearingStringFn, distanceStringFn, labelsRenderFn, } = { lineEditOptions: {}, labelsStyle: {}, distanceLabelsStyle: {}, bearingLabelsStyle: {} }) {
        /** @type {?} */
        const rnb = this.polylineEditor.create(Object.assign({ allowDrag: false, pointProps: {
                showVirtual: false,
                pixelSize: 8,
            }, polylineProps: {
                width: 2,
            } }, this.lineEditOptions, lineEditOptions));
        if (labelsRenderFn) {
            rnb.setLabelsRenderFn(labelsRenderFn);
        }
        else if (this.labelsRenderFn) {
            rnb.setLabelsRenderFn(this.labelsRenderFn);
        }
        else {
            rnb.setLabelsRenderFn(update => {
                /** @type {?} */
                const positions = update.positions;
                /** @type {?} */
                let totalDistance = 0;
                if (!positions || positions.length === 0) {
                    return [];
                }
                return (update.editMode === EditModes.CREATE && update.editAction !== EditActions.ADD_LAST_POINT
                    ? [...positions, update.updatedPosition]
                    : positions).reduce((labels, position, index, array) => {
                    if (index !== 0) {
                        /** @type {?} */
                        const previousPosition = array[index - 1];
                        /** @type {?} */
                        const bearing = this.coordinateConverter.bearingToCartesian(previousPosition, position);
                        /** @type {?} */
                        const distance = Cesium.Cartesian3.distance(previousPosition, position) / 1000;
                        labels.push(Object.assign({ text: (bearingStringFn && bearingStringFn(bearing)) ||
                                (this.bearingStringFn && this.bearingStringFn(bearing)) ||
                                `${bearing.toFixed(2)}Â°`, scale: 0.2, font: '80px Helvetica', pixelOffset: new Cesium.Cartesian2(-20, -8), position: new Cesium.Cartesian3((position.x + previousPosition.x) / 2, (position.y + previousPosition.y) / 2, (position.z + previousPosition.z) / 2), fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.WHITE, showBackground: true }, ((/** @type {?} */ (this.labelsStyle))), ((/** @type {?} */ (labelsStyle))), ((/** @type {?} */ (this.bearingLabelsStyle))), ((/** @type {?} */ (bearingLabelsStyle)))), Object.assign({ text: (distanceStringFn && distanceStringFn(totalDistance + distance)) ||
                                (this.distanceStringFn && this.distanceStringFn(totalDistance + distance)) ||
                                `${(totalDistance + distance).toFixed(2)} Km`, scale: 0.2, font: '80px Helvetica', pixelOffset: new Cesium.Cartesian2(-35, -8), position: position, fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.WHITE, showBackground: true }, ((/** @type {?} */ (this.labelsStyle))), ((/** @type {?} */ (labelsStyle))), ((/** @type {?} */ (this.distanceLabelsStyle))), ((/** @type {?} */ (distanceLabelsStyle)))));
                        totalDistance += distance;
                    }
                    return labels;
                }, [
                    Object.assign({ text: (distanceStringFn && distanceStringFn(0)) || (this.distanceStringFn && this.distanceStringFn(0)) || `0 Km`, scale: 0.2, font: '80px Helvetica', pixelOffset: new Cesium.Cartesian2(-20, -8), position: positions[0], fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.WHITE, showBackground: true }, ((/** @type {?} */ (this.labelsStyle))), ((/** @type {?} */ (labelsStyle))), ((/** @type {?} */ (this.distanceLabelsStyle))), ((/** @type {?} */ (distanceLabelsStyle)))),
                ]);
            });
        }
        return rnb;
    }
}
RangeAndBearingComponent.decorators = [
    { type: Component, args: [{
                selector: 'range-and-bearing',
                template: `
    <polylines-editor></polylines-editor>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [PolylinesEditorService]
            }] }
];
/** @nocollapse */
RangeAndBearingComponent.ctorParameters = () => [
    { type: PolylinesEditorService },
    { type: CoordinateConverter }
];
RangeAndBearingComponent.propDecorators = {
    lineEditOptions: [{ type: Input }],
    labelsStyle: [{ type: Input }],
    distanceLabelsStyle: [{ type: Input }],
    bearingLabelsStyle: [{ type: Input }],
    bearingStringFn: [{ type: Input }],
    distanceStringFn: [{ type: Input }],
    labelsRenderFn: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    RangeAndBearingComponent.prototype.lineEditOptions;
    /** @type {?} */
    RangeAndBearingComponent.prototype.labelsStyle;
    /** @type {?} */
    RangeAndBearingComponent.prototype.distanceLabelsStyle;
    /** @type {?} */
    RangeAndBearingComponent.prototype.bearingLabelsStyle;
    /** @type {?} */
    RangeAndBearingComponent.prototype.bearingStringFn;
    /** @type {?} */
    RangeAndBearingComponent.prototype.distanceStringFn;
    /** @type {?} */
    RangeAndBearingComponent.prototype.labelsRenderFn;
    /**
     * @type {?}
     * @private
     */
    RangeAndBearingComponent.prototype.polylineEditor;
    /**
     * @type {?}
     * @private
     */
    RangeAndBearingComponent.prototype.coordinateConverter;
}
/**
 * @record
 */
export function RangeAndBearingOptions() { }
if (false) {
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.lineEditOptions;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.labelsStyle;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.distanceLabelsStyle;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.bearingLabelsStyle;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.bearingStringFn;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.distanceStringFn;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.labelsRenderFn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UtYW5kLWJlYXJpbmcuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1jZXNpdW0vIiwic291cmNlcyI6WyJsaWIvYW5ndWxhci1jZXNpdW0td2lkZ2V0cy9jb21wb25lbnRzL3JhbmdlLWFuZC1iZWFyaW5nL3JhbmdlLWFuZC1iZWFyaW5nLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sb0ZBQW9GLENBQUM7QUFDekgsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBSzdELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSx3RUFBd0UsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDaEgsTUFBTSxPQUFPLHdCQUF3Qjs7Ozs7SUFTbkMsWUFBb0IsY0FBc0MsRUFBVSxtQkFBd0M7UUFBeEYsbUJBQWMsR0FBZCxjQUFjLENBQXdCO1FBQVUsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQVJuRyxvQkFBZSxHQUF5QixFQUFFLENBQUM7UUFDM0MsZ0JBQVcsR0FBZ0IsRUFBRSxDQUFDO1FBQzlCLHdCQUFtQixHQUFnQixFQUFFLENBQUM7UUFDdEMsdUJBQWtCLEdBQWdCLEVBQUUsQ0FBQztJQU05QyxDQUFDOzs7OztJQUVELE1BQU0sQ0FDSixFQUNFLGVBQWUsR0FBRyxFQUFFLEVBQ3BCLFdBQVcsR0FBRyxFQUFFLEVBQ2hCLG1CQUFtQixHQUFHLEVBQUUsRUFDeEIsa0JBQWtCLEdBQUcsRUFBRSxFQUN2QixlQUFlLEVBQ2YsZ0JBQWdCLEVBQ2hCLGNBQWMsTUFDWSxFQUFDLGVBQWUsRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFF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QXlCOztJQUN6QixxREFBaUM7O0lBQ2pDLG9EQUFnQzs7SUFDaEMsaURBQTRDOztJQUM1QyxrREFBNkM7O0lBQzdDLGdEQUFvRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb29yZGluYXRlQ29udmVydGVyIH0gZnJvbSAnLi4vLi4vLi4vYW5ndWxhci1jZXNpdW0vc2VydmljZXMvY29vcmRpbmF0ZS1jb252ZXJ0ZXIvY29vcmRpbmF0ZS1jb252ZXJ0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBFZGl0QWN0aW9ucyB9IGZyb20gJy4uLy4uL21vZGVscy9lZGl0LWFjdGlvbnMuZW51bSc7XG5pbXBvcnQgeyBQb2x5bGluZUVkaXRvck9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUtZWRpdG9yLW9ic2VydmFibGUnO1xuaW1wb3J0IHsgUG9seWxpbmVFZGl0T3B0aW9ucyB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZS1lZGl0LW9wdGlvbnMnO1xuaW1wb3J0IHsgTGFiZWxQcm9wcywgTGFiZWxTdHlsZSB9IGZyb20gJy4uLy4uL21vZGVscy9sYWJlbC1wcm9wcyc7XG5pbXBvcnQgeyBQb2x5bGluZUVkaXRVcGRhdGUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUtZWRpdC11cGRhdGUnO1xuaW1wb3J0IHsgRWRpdE1vZGVzIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2VkaXQtbW9kZS5lbnVtJztcbmltcG9ydCB7IFBvbHlsaW5lc0VkaXRvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9lbnRpdHktZWRpdG9ycy9wb2x5bGluZS1lZGl0b3IvcG9seWxpbmVzLWVkaXRvci5zZXJ2aWNlJztcblxuLyoqXG4gKlxuICogUmFuZ2UgYW5kIGJlYXJpbmcgY29tcG9uZW50IHRoYXQgaXMgdXNlZCB0byBkcmF3IHJhbmdlIGFuZCBiZWFyaW5nIG9uIHRoZSBtYXAuXG4gKiBUaGUgaW5wdXRzIGFyZSB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgcmFuZ2UgYW5kIGJlYXJpbmcgc3R5bGUgYW5kIGJlaGF2aW9yLlxuICogQ3JlYXRlIGNvbXBvbmVudCByZWZlcmVuY2UgYW5kIHVzZSB0aGUgYGNyZWF0ZSgpYCBmdW5jdGlvbiB0byBzdGFydCBjcmVhdGluZyBSJkIgb24gdGhlIG1hcC5cbiAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhbiBvcHRpb25hbCBSYW5nZUFuZEJlYXJpbmdPcHRpb25zIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGNyZWF0ZWQgcmFuZ2UgYW5kIGJlYXJpbmcgc3R5bGUgYW5kIGJlaGF2aW9yXG4gKiAob24gdG9wIG9mIHRoZSBkZWZhdWx0IGFuZCBnbG9iYWwgZGVmaW5pdGlvbnMpLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqIG15LWNvbXBvbmVudC50czpcbiAqXG4gKiBgYGBcbiAqIFxcQFZpZXdDaGlsZCgncmFuZ2VBbmRCZWFyaW5nJykgcHJpdmF0ZSByYW5nZUFuZEJlYXJpbmc6IFJhbmdlQW5kQmVhcmluZ0NvbXBvbmVudDsgLy8gR2V0IFImQiByZWZlcmVuY2VcbiAqICAvLyAuLi5cbiAqIHRoaXMucmFuZ2VBbmRCZWFyaW5nLmNyZWF0ZSh7c3R5bGU6IHsgcG9pbnRQcm9wczogeyBwaXhlbFNpemU6IDEyIH0gfSwgYmVhcmluZ0xhYmVsc1N0eWxlOiB7IGZpbGxDb2xvcjogQ2VzaXVtLkNvbG9yLkdSRUVOIH0gfSk7XG4gKiBgYGBcbiAqXG4gKiBteS1jb21wb25lbnQuaHRtbFxuICogYGBgXG4gKiA8cmFuZ2UtYW5kLWJlYXJpbmcgI3JhbmdlQW5kQmVhcmluZz48L3JhbmdlLWFuZC1iZWFyaW5nPiAvLyBPcHRpb25hbCBpbnB1dHMgZGVmaW5lcyBnbG9iYWwgc3R5bGUgYW5kIGJlaGF2aW9yLlxuICogYGBgXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdyYW5nZS1hbmQtYmVhcmluZycsXG4gIHRlbXBsYXRlOiBgXG4gICAgPHBvbHlsaW5lcy1lZGl0b3I+PC9wb2x5bGluZXMtZWRpdG9yPlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJvdmlkZXJzOiBbUG9seWxpbmVzRWRpdG9yU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIFJhbmdlQW5kQmVhcmluZ0NvbXBvbmVudCB7XG4gIEBJbnB1dCgpIGxpbmVFZGl0T3B0aW9ucz86IFBvbHlsaW5lRWRpdE9wdGlvbnMgPSB7fTtcbiAgQElucHV0KCkgbGFiZWxzU3R5bGU/OiBMYWJlbFN0eWxlID0ge307XG4gIEBJbnB1dCgpIGRpc3RhbmNlTGFiZWxzU3R5bGU/OiBMYWJlbFN0eWxlID0ge307XG4gIEBJbnB1dCgpIGJlYXJpbmdMYWJlbHNTdHlsZT86IExhYmVsU3R5bGUgPSB7fTtcbiAgQElucHV0KCkgYmVhcmluZ1N0cmluZ0ZuPzogKHZhbHVlOiBudW1iZXIpID0+IHN0cmluZztcbiAgQElucHV0KCkgZGlzdGFuY2VTdHJpbmdGbj86ICh2YWx1ZTogbnVtYmVyKSA9PiBzdHJpbmc7XG4gIEBJbnB1dCgpIGxhYmVsc1JlbmRlckZuPzogKHVwZGF0ZTogUG9seWxpbmVFZGl0VXBkYXRlLCBsYWJlbHM6IExhYmVsUHJvcHNbXSkgPT4gTGFiZWxQcm9wc1tdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcG9seWxpbmVFZGl0b3I6IFBvbHlsaW5lc0VkaXRvclNlcnZpY2UsIHByaXZhdGUgY29vcmRpbmF0ZUNvbnZlcnRlcjogQ29vcmRpbmF0ZUNvbnZlcnRlcikge1xuICB9XG5cbiAgY3JlYXRlKFxuICAgIHtcbiAgICAgIGxpbmVFZGl0T3B0aW9ucyA9IHt9LFxuICAgICAgbGFiZWxzU3R5bGUgPSB7fSxcbiAgICAgIGRpc3RhbmNlTGFiZWxzU3R5bGUgPSB7fSxcbiAgICAgIGJlYXJpbmdMYWJlbHNTdHlsZSA9IHt9LFxuICAgICAgYmVhcmluZ1N0cmluZ0ZuLFxuICAgICAgZGlzdGFuY2VTdHJpbmdGbixcbiAgICAgIGxhYmVsc1JlbmRlckZuLFxuICAgIH06IFJhbmdlQW5kQmVhcmluZ09wdGlvbnMgPSB7bGluZUVkaXRPcHRpb25zOiB7fSwgbGFiZWxzU3R5bGU6IHt9LCBkaXN0YW5jZUxhYmVsc1N0eWxlOiB7fSwgYmVhcmluZ0xhYmVsc1N0eWxlOiB7fX0sXG4gICk6IFBvbHlsaW5lRWRpdG9yT2JzZXJ2YWJsZSB7XG4gICAgY29uc3Qgcm5iID0gdGhpcy5wb2x5bGluZUVkaXRvci5jcmVhdGUoe1xuICAgICAgYWxsb3dEcmFnOiBmYWxzZSxcbiAgICAgIHBvaW50UHJvcHM6IHtcbiAgICAgICAgc2hvd1ZpcnR1YWw6IGZhbHNlLFxuICAgICAgICBwaXhlbFNpemU6IDgsXG4gICAgICB9LFxuICAgICAgcG9seWxpbmVQcm9wczoge1xuICAgICAgICB3aWR0aDogMixcbiAgICAgIH0sXG4gICAgICAuLi50aGlzLmxpbmVFZGl0T3B0aW9ucyxcbiAgICAgIC4uLmxpbmVFZGl0T3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGlmIChsYWJlbHNSZW5kZXJGbikge1xuICAgICAgcm5iLnNldExhYmVsc1JlbmRlckZuKGxhYmVsc1JlbmRlckZuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxzUmVuZGVyRm4pIHtcbiAgICAgIHJuYi5zZXRMYWJlbHNSZW5kZXJGbih0aGlzLmxhYmVsc1JlbmRlckZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm5iLnNldExhYmVsc1JlbmRlckZuKHVwZGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHVwZGF0ZS5wb3NpdGlvbnM7XG4gICAgICAgIGxldCB0b3RhbERpc3RhbmNlID0gMDtcbiAgICAgICAgaWYgKCFwb3NpdGlvbnMgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHVwZGF0ZS5lZGl0TW9kZSA9PT0gRWRpdE1vZGVzLkNSRUFURSAmJiB1cGRhdGUuZWRpdEFjdGlvbiAhPT0gRWRpdEFjdGlvbnMuQUREX0xBU1RfUE9JTlRcbiAgICAgICAgICAgID8gWy4uLnBvc2l0aW9ucywgdXBkYXRlLnVwZGF0ZWRQb3NpdGlvbl1cbiAgICAgICAgICAgIDogcG9zaXRpb25zXG4gICAgICAgICkucmVkdWNlKFxuICAgICAgICAgIChsYWJlbHMsIHBvc2l0aW9uLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1Bvc2l0aW9uID0gYXJyYXlbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgY29uc3QgYmVhcmluZyA9IHRoaXMuY29vcmRpbmF0ZUNvbnZlcnRlci5iZWFyaW5nVG9DYXJ0ZXNpYW4ocHJldmlvdXNQb3NpdGlvbiwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IENlc2l1bS5DYXJ0ZXNpYW4zLmRpc3RhbmNlKHByZXZpb3VzUG9zaXRpb24sIHBvc2l0aW9uKSAvIDEwMDA7XG4gICAgICAgICAgICAgIGxhYmVscy5wdXNoKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6XG4gICAgICAgICAgICAgICAgICAgIChiZWFyaW5nU3RyaW5nRm4gJiYgYmVhcmluZ1N0cmluZ0ZuKGJlYXJpbmcpKSB8fFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5iZWFyaW5nU3RyaW5nRm4gJiYgdGhpcy5iZWFyaW5nU3RyaW5nRm4oYmVhcmluZykpIHx8XG4gICAgICAgICAgICAgICAgICAgIGAke2JlYXJpbmcudG9GaXhlZCgyKX3CsGAsXG4gICAgICAgICAgICAgICAgICBzY2FsZTogMC4yLFxuICAgICAgICAgICAgICAgICAgZm9udDogJzgwcHggSGVsdmV0aWNhJyxcbiAgICAgICAgICAgICAgICAgIHBpeGVsT2Zmc2V0OiBuZXcgQ2VzaXVtLkNhcnRlc2lhbjIoLTIwLCAtOCksXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKFxuICAgICAgICAgICAgICAgICAgICAocG9zaXRpb24ueCArIHByZXZpb3VzUG9zaXRpb24ueCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAocG9zaXRpb24ueSArIHByZXZpb3VzUG9zaXRpb24ueSkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAocG9zaXRpb24ueiArIHByZXZpb3VzUG9zaXRpb24ueikgLyAyLFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogQ2VzaXVtLkNvbG9yLldISVRFLFxuICAgICAgICAgICAgICAgICAgb3V0bGluZUNvbG9yOiBDZXNpdW0uQ29sb3IuV0hJVEUsXG4gICAgICAgICAgICAgICAgICBzaG93QmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIC4uLih0aGlzLmxhYmVsc1N0eWxlIGFzIGFueSksXG4gICAgICAgICAgICAgICAgICAuLi4obGFiZWxzU3R5bGUgYXMgYW55KSxcbiAgICAgICAgICAgICAgICAgIC4uLih0aGlzLmJlYXJpbmdMYWJlbHNTdHlsZSBhcyBhbnkpLFxuICAgICAgICAgICAgICAgICAgLi4uKGJlYXJpbmdMYWJlbHNTdHlsZSBhcyBhbnkpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGV4dDpcbiAgICAgICAgICAgICAgICAgICAgKGRpc3RhbmNlU3RyaW5nRm4gJiYgZGlzdGFuY2VTdHJpbmdGbih0b3RhbERpc3RhbmNlICsgZGlzdGFuY2UpKSB8fFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5kaXN0YW5jZVN0cmluZ0ZuICYmIHRoaXMuZGlzdGFuY2VTdHJpbmdGbih0b3RhbERpc3RhbmNlICsgZGlzdGFuY2UpKSB8fFxuICAgICAgICAgICAgICAgICAgICBgJHsodG90YWxEaXN0YW5jZSArIGRpc3RhbmNlKS50b0ZpeGVkKDIpfSBLbWAsXG4gICAgICAgICAgICAgICAgICBzY2FsZTogMC4yLFxuICAgICAgICAgICAgICAgICAgZm9udDogJzgwcHggSGVsdmV0aWNhJyxcbiAgICAgICAgICAgICAgICAgIHBpeGVsT2Zmc2V0OiBuZXcgQ2VzaXVtLkNhcnRlc2lhbjIoLTM1LCAtOCksXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IENlc2l1bS5Db2xvci5XSElURSxcbiAgICAgICAgICAgICAgICAgIG91dGxpbmVDb2xvcjogQ2VzaXVtLkNvbG9yLldISVRFLFxuICAgICAgICAgICAgICAgICAgc2hvd0JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAuLi4odGhpcy5sYWJlbHNTdHlsZSBhcyBhbnkpLFxuICAgICAgICAgICAgICAgICAgLi4uKGxhYmVsc1N0eWxlIGFzIGFueSksXG4gICAgICAgICAgICAgICAgICAuLi4odGhpcy5kaXN0YW5jZUxhYmVsc1N0eWxlIGFzIGFueSksXG4gICAgICAgICAgICAgICAgICAuLi4oZGlzdGFuY2VMYWJlbHNTdHlsZSBhcyBhbnkpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGV4dDogKGRpc3RhbmNlU3RyaW5nRm4gJiYgZGlzdGFuY2VTdHJpbmdGbigwKSkgfHwgKHRoaXMuZGlzdGFuY2VTdHJpbmdGbiAmJiB0aGlzLmRpc3RhbmNlU3RyaW5nRm4oMCkpIHx8IGAwIEttYCxcbiAgICAgICAgICAgICAgc2NhbGU6IDAuMixcbiAgICAgICAgICAgICAgZm9udDogJzgwcHggSGVsdmV0aWNhJyxcbiAgICAgICAgICAgICAgcGl4ZWxPZmZzZXQ6IG5ldyBDZXNpdW0uQ2FydGVzaWFuMigtMjAsIC04KSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uc1swXSxcbiAgICAgICAgICAgICAgZmlsbENvbG9yOiBDZXNpdW0uQ29sb3IuV0hJVEUsXG4gICAgICAgICAgICAgIG91dGxpbmVDb2xvcjogQ2VzaXVtLkNvbG9yLldISVRFLFxuICAgICAgICAgICAgICBzaG93QmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4uKHRoaXMubGFiZWxzU3R5bGUgYXMgYW55KSxcbiAgICAgICAgICAgICAgLi4uKGxhYmVsc1N0eWxlIGFzIGFueSksXG4gICAgICAgICAgICAgIC4uLih0aGlzLmRpc3RhbmNlTGFiZWxzU3R5bGUgYXMgYW55KSxcbiAgICAgICAgICAgICAgLi4uKGRpc3RhbmNlTGFiZWxzU3R5bGUgYXMgYW55KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBybmI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSYW5nZUFuZEJlYXJpbmdPcHRpb25zIHtcbiAgbGluZUVkaXRPcHRpb25zPzogUG9seWxpbmVFZGl0T3B0aW9ucztcbiAgbGFiZWxzU3R5bGU/OiBMYWJlbFN0eWxlO1xuICBkaXN0YW5jZUxhYmVsc1N0eWxlPzogTGFiZWxTdHlsZTtcbiAgYmVhcmluZ0xhYmVsc1N0eWxlPzogTGFiZWxTdHlsZTtcbiAgYmVhcmluZ1N0cmluZ0ZuPzogKHZhbHVlOiBudW1iZXIpID0+IHN0cmluZztcbiAgZGlzdGFuY2VTdHJpbmdGbj86ICh2YWx1ZTogbnVtYmVyKSA9PiBzdHJpbmc7XG4gIGxhYmVsc1JlbmRlckZuPzogKHVwZGF0ZTogUG9seWxpbmVFZGl0VXBkYXRlLCBsYWJlbHM6IExhYmVsUHJvcHNbXSkgPT4gTGFiZWxQcm9wc1tdO1xufVxuIl19