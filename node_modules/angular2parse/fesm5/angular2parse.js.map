{"version":3,"file":"angular2parse.js","sources":["ng://angular2parse/lib/angular/facade/lang.ts","ng://angular2parse/lib/angular/compiler/assertions.ts","ng://angular2parse/lib/angular/compiler/ast.ts","ng://angular2parse/lib/angular/compiler/chars.ts","ng://angular2parse/lib/angular/compiler/interpolation-config.ts","ng://angular2parse/lib/angular/compiler/lexer.ts","ng://angular2parse/lib/angular/compiler/parser.ts","ng://angular2parse/lib/util/binary-operations.ts","ng://angular2parse/lib/util/lang.ts","ng://angular2parse/lib/visitors/parse-visitor-compiler.ts","ng://angular2parse/lib/visitors/parse-visitor-resolver.ts","ng://angular2parse/lib/parse.ts","ng://angular2parse/lib/module.ts","ng://angular2parse/public-api.ts","ng://angular2parse/angular2parse.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface BrowserNodeGlobal {\n    Object: typeof Object;\n    Array: typeof Array;\n    Map: typeof Map;\n    Set: typeof Set;\n    Date: DateConstructor;\n    RegExp: RegExpConstructor;\n    JSON: typeof JSON;\n    Math: any;  // typeof Math;\n    assert(condition: any): void;\n    Reflect: any;\n    getAngularTestability: Function;\n    getAllAngularTestabilities: Function;\n    getAllAngularRootElements: Function;\n    frameworkStabilizers: Array<Function>;\n    setTimeout: Function;\n    clearTimeout: Function;\n    setInterval: Function;\n    clearInterval: Function;\n    encodeURI: Function;\n}\n\n\nexport function getTypeNameForDebugging(type: any): string {\n    return type['name'] || typeof type;\n}\n\nexport function isPresent(obj: any): boolean {\n    return obj != null;\n}\n\nexport function isBlank(obj: any): boolean {\n    return obj == null;\n}\n\nconst STRING_MAP_PROTO = Object.getPrototypeOf({});\nexport function isStrictStringMap(obj: any): boolean {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n\nexport function stringify(token: any): string {\n    if (typeof token === 'string') {\n        return token;\n    }\n\n    if (token == null) {\n        return '' + token;\n    }\n\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n\n    if (token.name) {\n        return `${token.name}`;\n    }\n\n    const res = token.toString();\n    const newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\nexport class NumberWrapper {\n    static parseIntAutoRadix(text: string): number {\n        const result: number = parseInt(text);\n        if (isNaN(result)) {\n            throw new Error('Invalid integer literal when parsing ' + text);\n        }\n        return result;\n    }\n\n    static isNumeric(value: any): boolean { return !isNaN(value - parseFloat(value)); }\n}\n\n// JS has NaN !== NaN\nexport function looseIdentical(a: any, b: any): boolean {\n    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n}\n\nexport function isJsObject(o: any): boolean {\n    return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n\nexport function print(obj: Error | Object) {\n    // tslint:disable-next-line:no-console\n    console.log(obj);\n}\n\nexport function warn(obj: Error | Object) {\n    console.warn(obj);\n}\n\nexport function setValueOnPath(global: any, path: string, value: any) {\n    const parts = path.split('.');\n    let obj: any = global;\n    while (parts.length > 1) {\n        const name = parts.shift();\n        if (obj.hasOwnProperty(name) && obj[name] != null) {\n            obj = obj[name];\n        } else {\n            obj = obj[name] = {};\n        }\n    }\n    if (obj === undefined || obj === null) {\n        obj = {};\n    }\n    obj[parts.shift()] = value;\n}\n\nexport function isPrimitive(obj: any): boolean {\n    return !isJsObject(obj);\n}\n\nexport function escapeRegExp(s: string): string {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {isBlank, isPresent} from '../facade/lang';\n\nconst isDevMode = () => false;\n\nexport function assertArrayOfStrings(identifier: string, value: any) {\n    if (!isDevMode() || isBlank(value)) {\n        return;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(`Expected '${identifier}' to be an array of strings.`);\n    }\n    for (let i = 0; i < value.length; i += 1) {\n        if (typeof value[i] !== 'string') {\n            throw new Error(`Expected '${identifier}' to be an array of strings.`);\n        }\n    }\n}\n\nconst INTERPOLATION_BLACKLIST_REGEXPS = [\n    /^\\s*$/,        // empty\n    /[<>]/,         // html tag\n    /^[{}]$/,       // i18n expansion\n    /&(#|[a-z])/i,  // character reference,\n    /^\\/\\//,        // comment\n];\n\nexport function assertInterpolationSymbols(identifier: string, value: any): void {\n    if (isPresent(value) && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n    } else if (isDevMode() && !isBlank(value)) {\n        const start = value[0] as string;\n        const end = value[1] as string;\n        // black list checking\n        INTERPOLATION_BLACKLIST_REGEXPS.forEach(regexp => {\n            if (regexp.test(start) || regexp.test(end)) {\n                throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n            }\n        });\n    }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {isBlank} from '../facade/lang';\n\nexport class ParserError {\n    public message: string;\n    constructor(\n        message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n        this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n    }\n}\n\nexport class ParseSpan {\n    constructor(public start: number, public end: number) {}\n}\n\nexport class AST {\n    constructor(public span: ParseSpan) {}\n    visit(visitor: AstVisitor, context: any = null): any { return null; }\n    toString(): string { return 'AST'; }\n}\n\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nexport class Quote extends AST {\n    constructor(\n        span: ParseSpan, public prefix: string, public uninterpretedExpression: string,\n        public location: any) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitQuote(this, context); }\n    toString(): string { return 'Quote'; }\n}\n\nexport class EmptyExpr extends AST {\n    visit(visitor: AstVisitor, context: any = null) {\n        // do nothing\n    }\n}\n\nexport class ImplicitReceiver extends AST {\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitImplicitReceiver(this, context);\n    }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n    constructor(span: ParseSpan, public expressions: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitChain(this, context); }\n}\n\nexport class Conditional extends AST {\n    constructor(span: ParseSpan, public condition: AST, public trueExp: AST, public falseExp: AST) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitConditional(this, context);\n    }\n}\n\nexport class PropertyRead extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitPropertyRead(this, context);\n    }\n}\n\nexport class PropertyWrite extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public value: AST) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitPropertyWrite(this, context);\n    }\n}\n\nexport class SafePropertyRead extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitSafePropertyRead(this, context);\n    }\n}\n\nexport class KeyedRead extends AST {\n    constructor(span: ParseSpan, public obj: AST, public key: AST) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitKeyedRead(this, context);\n    }\n}\n\nexport class KeyedWrite extends AST {\n    constructor(span: ParseSpan, public obj: AST, public key: AST, public value: AST) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitKeyedWrite(this, context);\n    }\n}\n\nexport class BindingPipe extends AST {\n    constructor(span: ParseSpan, public exp: AST, public name: string, public args: any[]) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitPipe(this, context); }\n}\n\nexport class LiteralPrimitive extends AST {\n    constructor(span: ParseSpan, public value: any) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitLiteralPrimitive(this, context);\n    }\n}\n\nexport class LiteralArray extends AST {\n    constructor(span: ParseSpan, public expressions: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitLiteralArray(this, context);\n    }\n}\n\nexport class LiteralMap extends AST {\n    constructor(span: ParseSpan, public keys: any[], public values: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitLiteralMap(this, context);\n    }\n}\n\nexport class Interpolation extends AST {\n    constructor(span: ParseSpan, public strings: any[], public expressions: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitInterpolation(this, context);\n    }\n}\n\nexport class Binary extends AST {\n    constructor(span: ParseSpan, public operation: string, public left: AST, public right: AST) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitBinary(this, context);\n    }\n}\n\nexport class PrefixNot extends AST {\n    constructor(span: ParseSpan, public expression: AST) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitPrefixNot(this, context);\n    }\n}\n\nexport class MethodCall extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitMethodCall(this, context);\n    }\n}\n\nexport class SafeMethodCall extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitSafeMethodCall(this, context);\n    }\n}\n\nexport class FunctionCall extends AST {\n    constructor(span: ParseSpan, public target: AST, public args: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitFunctionCall(this, context);\n    }\n}\n\nexport class ASTWithSource extends AST {\n    constructor(\n        public ast: AST, public source: string, public location: string,\n        public errors: ParserError[]) {\n        super(new ParseSpan(0, isBlank(source) ? 0 : source.length));\n    }\n    visit(visitor: AstVisitor, context: any = null): any { return this.ast.visit(visitor, context); }\n    toString(): string { return `${this.source} in ${this.location}`; }\n}\n\nexport class TemplateBinding {\n    constructor(\n        public span: ParseSpan, public key: string, public keyIsVar: boolean, public name: string,\n        public expression: ASTWithSource) {}\n}\n\nexport interface AstVisitor {\n    visitBinary(ast: Binary, context: any): any;\n    visitChain(ast: Chain, context: any): any;\n    visitConditional(ast: Conditional, context: any): any;\n    visitFunctionCall(ast: FunctionCall, context: any): any;\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n    visitInterpolation(ast: Interpolation, context: any): any;\n    visitKeyedRead(ast: KeyedRead, context: any): any;\n    visitKeyedWrite(ast: KeyedWrite, context: any): any;\n    visitLiteralArray(ast: LiteralArray, context: any): any;\n    visitLiteralMap(ast: LiteralMap, context: any): any;\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n    visitMethodCall(ast: MethodCall, context: any): any;\n    visitPipe(ast: BindingPipe, context: any): any;\n    visitPrefixNot(ast: PrefixNot, context: any): any;\n    visitPropertyRead(ast: PropertyRead, context: any): any;\n    visitPropertyWrite(ast: PropertyWrite, context: any): any;\n    visitQuote(ast: Quote, context: any): any;\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n    visitBinary(ast: Binary, context: any): any {\n        ast.left.visit(this);\n        ast.right.visit(this);\n        return null;\n    }\n    visitChain(ast: Chain, context: any): any { return this.visitAll(ast.expressions, context); }\n    visitConditional(ast: Conditional, context: any): any {\n        ast.condition.visit(this);\n        ast.trueExp.visit(this);\n        ast.falseExp.visit(this);\n        return null;\n    }\n    visitPipe(ast: BindingPipe, context: any): any {\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n    visitFunctionCall(ast: FunctionCall, context: any): any {\n        ast.target.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any { return null; }\n    visitInterpolation(ast: Interpolation, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n    visitKeyedRead(ast: KeyedRead, context: any): any {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        return null;\n    }\n    visitKeyedWrite(ast: KeyedWrite, context: any): any {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        ast.value.visit(this);\n        return null;\n    }\n    visitLiteralArray(ast: LiteralArray, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n    visitLiteralMap(ast: LiteralMap, context: any): any { return this.visitAll(ast.values, context); }\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any { return null; }\n    visitMethodCall(ast: MethodCall, context: any): any {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    }\n    visitPrefixNot(ast: PrefixNot, context: any): any {\n        ast.expression.visit(this);\n        return null;\n    }\n    visitPropertyRead(ast: PropertyRead, context: any): any {\n        ast.receiver.visit(this);\n        return null;\n    }\n    visitPropertyWrite(ast: PropertyWrite, context: any): any {\n        ast.receiver.visit(this);\n        ast.value.visit(this);\n        return null;\n    }\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n        ast.receiver.visit(this);\n        return null;\n    }\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    }\n    visitAll(asts: AST[], context: any): any {\n        asts.forEach(ast => ast.visit(this, context));\n        return null;\n    }\n    visitQuote(ast: Quote, context: any): any { return null; }\n}\n\nexport class AstTransformer implements AstVisitor {\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST { return ast; }\n\n    visitInterpolation(ast: Interpolation, context: any): AST {\n        return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n    }\n\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n        return new LiteralPrimitive(ast.span, ast.value);\n    }\n\n    visitPropertyRead(ast: PropertyRead, context: any): AST {\n        return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    }\n\n    visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n        return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value);\n    }\n\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n        return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    }\n\n    visitMethodCall(ast: MethodCall, context: any): AST {\n        return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    }\n\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n        return new SafeMethodCall(\n            ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    }\n\n    visitFunctionCall(ast: FunctionCall, context: any): AST {\n        return new FunctionCall(ast.span, ast.target.visit(this), this.visitAll(ast.args));\n    }\n\n    visitLiteralArray(ast: LiteralArray, context: any): AST {\n        return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n    }\n\n    visitLiteralMap(ast: LiteralMap, context: any): AST {\n        return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n    }\n\n    visitBinary(ast: Binary, context: any): AST {\n        return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    }\n\n    visitPrefixNot(ast: PrefixNot, context: any): AST {\n        return new PrefixNot(ast.span, ast.expression.visit(this));\n    }\n\n    visitConditional(ast: Conditional, context: any): AST {\n        return new Conditional(\n            ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    }\n\n    visitPipe(ast: BindingPipe, context: any): AST {\n        return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n    }\n\n    visitKeyedRead(ast: KeyedRead, context: any): AST {\n        return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n    }\n\n    visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n        return new KeyedWrite(\n            ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    }\n\n    visitAll(asts: any[]): any[] {\n        const res = new Array(asts.length);\n        for (let i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    }\n\n    visitChain(ast: Chain, context: any): AST {\n        return new Chain(ast.span, this.visitAll(ast.expressions));\n    }\n\n    visitQuote(ast: Quote, context: any): AST {\n        return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n    }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n\nexport function isDigit(code: number): boolean {\n    return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInterpolationSymbols} from './assertions';\n\nexport class InterpolationConfig {\n    static fromArray(markers: [string, string]): InterpolationConfig {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    }\n\n    constructor(public start: string, public end: string){};\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig =\n    new InterpolationConfig('{{', '}}');","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from './chars';\nimport {NumberWrapper} from '../facade/lang';\n\nexport enum TokenType {\n    Character,\n    Identifier,\n    Keyword,\n    String,\n    Operator,\n    Number,\n    Error\n}\n\nconst KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nexport class Lexer {\n    tokenize(text: string): Token[] {\n        const scanner = new _Scanner(text);\n        const tokens: Token[] = [];\n        let token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    }\n}\n\nexport class Token {\n    constructor(\n        public index: number, public type: TokenType, public numValue: number,\n        public strValue: string) {}\n\n    isCharacter(code: number): boolean {\n        return this.type == TokenType.Character && this.numValue == code;\n    }\n\n    isNumber(): boolean { return this.type == TokenType.Number; }\n\n    isString(): boolean { return this.type == TokenType.String; }\n\n    isOperator(operater: string): boolean {\n        return this.type == TokenType.Operator && this.strValue == operater;\n    }\n\n    isIdentifier(): boolean { return this.type == TokenType.Identifier; }\n\n    isKeyword(): boolean { return this.type == TokenType.Keyword; }\n\n    isKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n\n    isKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n\n    isKeywordUndefined(): boolean {\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    }\n\n    isKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n\n    isKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n\n    isKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n\n    isError(): boolean { return this.type == TokenType.Error; }\n\n    toNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\n\n    toString(): string {\n        switch (this.type) {\n            case TokenType.Character:\n            case TokenType.Identifier:\n            case TokenType.Keyword:\n            case TokenType.Operator:\n            case TokenType.String:\n            case TokenType.Error:\n                return this.strValue;\n            case TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    }\n}\n\nfunction newCharacterToken(index: number, code: number): Token {\n    return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, text: string): Token {\n    return new Token(index, TokenType.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, text: string): Token {\n    return new Token(index, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, text: string): Token {\n    return new Token(index, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, text: string): Token {\n    return new Token(index, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, n: number): Token {\n    return new Token(index, TokenType.Number, n, '');\n}\n\nfunction newErrorToken(index: number, message: string): Token {\n    return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, TokenType.Character, 0, '');\n\nclass _Scanner {\n    length: number;\n    peek: number = 0;\n    index: number = -1;\n\n    constructor(public input: string) {\n        this.length = input.length;\n        this.advance();\n    }\n\n    advance() {\n        this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n    }\n\n    scanToken(): Token {\n        const input = this.input, length = this.length;\n        let peek = this.peek, index = this.index;\n\n        // Skip whitespace.\n        while (peek <= chars.$SPACE) {\n            if (++index >= length) {\n                peek = chars.$EOF;\n                break;\n            } else {\n                peek = input.charCodeAt(index);\n            }\n        }\n\n        this.peek = peek;\n        this.index = index;\n\n        if (index >= length) {\n            return null;\n        }\n\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek)) return this.scanIdentifier();\n        if (chars.isDigit(peek)) return this.scanNumber(index);\n\n        const start: number = index;\n        switch (peek) {\n            case chars.$PERIOD:\n                this.advance();\n                return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, chars.$PERIOD);\n            case chars.$LPAREN:\n            case chars.$RPAREN:\n            case chars.$LBRACE:\n            case chars.$RBRACE:\n            case chars.$LBRACKET:\n            case chars.$RBRACKET:\n            case chars.$COMMA:\n            case chars.$COLON:\n            case chars.$SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case chars.$SQ:\n            case chars.$DQ:\n                return this.scanString();\n            case chars.$HASH:\n            case chars.$PLUS:\n            case chars.$MINUS:\n            case chars.$STAR:\n            case chars.$SLASH:\n            case chars.$PERCENT:\n            case chars.$CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case chars.$QUESTION:\n                return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n            case chars.$LT:\n            case chars.$GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n            case chars.$BANG:\n            case chars.$EQ:\n                return this.scanComplexOperator(\n                    start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n            case chars.$AMPERSAND:\n                return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n            case chars.$BAR:\n                return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n            case chars.$NBSP:\n                while (chars.isWhitespace(this.peek)) this.advance();\n                return this.scanToken();\n        }\n\n        this.advance();\n        return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n    }\n\n    scanCharacter(start: number, code: number): Token {\n        this.advance();\n        return newCharacterToken(start, code);\n    }\n\n\n    scanOperator(start: number, str: string): Token {\n        this.advance();\n        return newOperatorToken(start, str);\n    }\n\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param start start index in the expression\n     * @param one first symbol (always part of the operator)\n     * @param twoCode code point for the second symbol\n     * @param two second symbol (part of the operator when the second code point matches)\n     * @param threeCode code point for the third symbol\n     * @param three third symbol (part of the operator when provided and matches source expression)\n     * @returns {Token}\n     */\n    scanComplexOperator(\n        start: number, one: string, twoCode: number, two: string, threeCode?: number,\n        three?: string): Token {\n        this.advance();\n        let str: string = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, str);\n    }\n\n    scanIdentifier(): Token {\n        const start: number = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek)) this.advance();\n        const str: string = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n            newIdentifierToken(start, str);\n    }\n\n    scanNumber(start: number): Token {\n        let simple: boolean = (this.index === start);\n        this.advance();  // Skip initial digit.\n        while (true) {\n            if (chars.isDigit(this.peek)) {\n                // Do nothing.\n            } else if (this.peek == chars.$PERIOD) {\n                simple = false;\n            } else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek)) this.advance();\n                if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n                simple = false;\n            } else {\n                break;\n            }\n            this.advance();\n        }\n        const str: string = this.input.substring(start, this.index);\n        const value: number = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, value);\n    }\n\n    scanString(): Token {\n        const start: number = this.index;\n        const quote: number = this.peek;\n        this.advance();  // Skip initial quote.\n\n        let buffer: string = '';\n        let marker: number = this.index;\n        const input: string = this.input;\n\n        while (this.peek != quote) {\n            if (this.peek == chars.$BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                let unescapedCode: number;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == chars.$u) {\n                    // 4 character hex code for unicode character.\n                    const hex: string = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    } else {\n                        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n                    }\n                    for (let i: number = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                } else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            } else if (this.peek == chars.$EOF) {\n                return this.error('Unterminated quote', 0);\n            } else {\n                this.advance();\n            }\n        }\n\n        const last: string = input.substring(marker, this.index);\n        this.advance();  // Skip terminating quote.\n\n        return newStringToken(start, buffer + last);\n    }\n\n    error(message: string, offset: number): Token {\n        const position: number = this.index + offset;\n        return newErrorToken(\n            position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n    }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n    return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n        (code == chars.$_) || (code == chars.$$);\n}\n\nexport function isIdentifier(input: string): boolean {\n    if (input.length == 0) return false;\n    const scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek)) return false;\n    scanner.advance();\n    while (scanner.peek !== chars.$EOF) {\n        if (!isIdentifierPart(scanner.peek)) return false;\n        scanner.advance();\n    }\n    return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n    return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n        (code == chars.$$);\n}\n\nfunction isExponentStart(code: number): boolean {\n    return code == chars.$e || code == chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n    return code == chars.$MINUS || code == chars.$PLUS;\n}\n\nexport function isQuote(code: number): boolean {\n    return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n\nfunction unescape(code: number): number {\n    switch (code) {\n        case chars.$n:\n            return chars.$LF;\n        case chars.$f:\n            return chars.$FF;\n        case chars.$r:\n            return chars.$CR;\n        case chars.$t:\n            return chars.$TAB;\n        case chars.$v:\n            return chars.$VTAB;\n        default:\n            return code;\n    }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from './chars';\nimport {escapeRegExp, isBlank, isPresent} from '../facade/lang';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './interpolation-config';\n\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, ParseSpan, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, TemplateBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from './lexer';\n\n\nexport class SplitInterpolation {\n    constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n    constructor(\n        public templateBindings: TemplateBinding[], public warnings: string[],\n        public errors: ParserError[]) {}\n}\n\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n    const pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n    return new RegExp(pattern, 'g');\n}\n\nexport class Parser {\n    private errors: ParserError[] = [];\n\n    constructor(private _lexer: Lexer) {}\n\n    parseAction(\n        input: string, location: any,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(this._stripComments(input));\n        const ast = new _ParseAST(\n            input, location, tokens, sourceToLex.length, true, this.errors,\n            input.length - sourceToLex.length)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n\n    parseBinding(\n        input: string, location: any,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        const ast = this._parseBindingAst(input, location, interpolationConfig);\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n\n    parseSimpleBinding(\n        input: string, location: string,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        const ast = this._parseBindingAst(input, location, interpolationConfig);\n        const errors = SimpleExpressionChecker.check(ast);\n        if (errors.length > 0) {\n            this._reportError(\n                `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n        }\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n\n    private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    }\n\n    private _parseBindingAst(\n        input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        const quote = this._parseQuote(input, location);\n\n        if (isPresent(quote)) {\n            return quote;\n        }\n\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(\n            input, location, tokens, sourceToLex.length, false, this.errors,\n            input.length - sourceToLex.length)\n            .parseChain();\n    }\n\n    private _parseQuote(input: string, location: any): AST {\n        if (isBlank(input)) return null;\n        const prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1) return null;\n        const prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix)) return null;\n        const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n    }\n\n    parseTemplateBindings(prefixToken: string, input: string, location: any):\n    TemplateBindingParseResult {\n        const tokens = this._lexer.tokenize(input);\n        if (prefixToken) {\n            // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n            const prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\n                t.index = 0;\n                return t;\n            });\n            tokens.unshift(...prefixTokens);\n        }\n        return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n            .parseTemplateBindings();\n    }\n\n    parseInterpolation(\n        input: string, location: any,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        const split = this.splitInterpolation(input, location, interpolationConfig);\n        if (split == null) return null;\n\n        const expressions: AST[] = [];\n\n        for (let i = 0; i < split.expressions.length; ++i) {\n            const expressionText = split.expressions[i];\n            const sourceToLex = this._stripComments(expressionText);\n            const tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));\n            const ast = new _ParseAST(\n                input, location, tokens, sourceToLex.length, false, this.errors,\n                split.offsets[i] + (expressionText.length - sourceToLex.length))\n                .parseChain();\n            expressions.push(ast);\n        }\n\n        return new ASTWithSource(\n            new Interpolation(\n                new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions),\n            input, location, this.errors);\n    }\n\n    splitInterpolation(\n        input: string, location: string,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\n        const regexp = _createInterpolateRegExp(interpolationConfig);\n        const parts = input.split(regexp);\n        if (parts.length <= 1) {\n            return null;\n        }\n        const strings: string[] = [];\n        const expressions: string[] = [];\n        const offsets: number[] = [];\n        let offset = 0;\n        for (let i = 0; i < parts.length; i++) {\n            const part: string = parts[i];\n            if (i % 2 === 0) {\n                // fixed string\n                strings.push(part);\n                offset += part.length;\n            } else if (part.trim().length > 0) {\n                offset += interpolationConfig.start.length;\n                expressions.push(part);\n                offsets.push(offset);\n                offset += part.length + interpolationConfig.end.length;\n            } else {\n                this._reportError(\n                    'Blank expressions are not allowed in interpolated strings', input,\n                    `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n                    location);\n                expressions.push('$implict');\n                offsets.push(offset);\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    }\n\n    wrapLiteralPrimitive(input: string, location: any): ASTWithSource {\n        return new ASTWithSource(\n            new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input,\n            location, this.errors);\n    }\n\n    private _stripComments(input: string): string {\n        const i = this._commentStart(input);\n        return isPresent(i) ? input.substring(0, i).trim() : input;\n    }\n\n    private _commentStart(input: string): number {\n        let outerQuote: number = null;\n        for (let i = 0; i < input.length - 1; i++) {\n            const char = input.charCodeAt(i);\n            const nextChar = input.charCodeAt(i + 1);\n\n            if (char === chars.$SLASH && nextChar == chars.$SLASH && isBlank(outerQuote)) return i;\n\n            if (outerQuote === char) {\n                outerQuote = null;\n            } else if (isBlank(outerQuote) && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    }\n\n    private _checkNoInterpolation(\n        input: string, location: any, interpolationConfig: InterpolationConfig): void {\n        const regexp = _createInterpolateRegExp(interpolationConfig);\n        const parts = input.split(regexp);\n        if (parts.length > 1) {\n            this._reportError(\n                `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n                input,\n                `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n                location);\n        }\n    }\n\n    private _findInterpolationErrorColumn(\n        parts: string[], partInErrIdx: number, interpolationConfig: InterpolationConfig): number {\n        let errLocation = '';\n        for (let j = 0; j < partInErrIdx; j++) {\n            errLocation += j % 2 === 0 ?\n                parts[j] :\n                `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n        }\n\n        return errLocation.length;\n    }\n}\n\nexport class _ParseAST {\n    private rparensExpected = 0;\n    private rbracketsExpected = 0;\n    private rbracesExpected = 0;\n\n    index: number = 0;\n\n    constructor(\n        public input: string, public location: any, public tokens: Token[],\n        public inputLength: number, public parseAction: boolean, private errors: ParserError[],\n        private offset: number) {}\n\n    peek(offset: number): Token {\n        const i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    }\n\n    get next(): Token { return this.peek(0); }\n\n    get inputIndex(): number {\n        return (this.index < this.tokens.length) ? this.next.index + this.offset :\n            this.inputLength + this.offset;\n    }\n\n    span(start: number) { return new ParseSpan(start, this.inputIndex); }\n\n    advance() { this.index++; }\n\n    optionalCharacter(code: number): boolean {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    peekKeywordLet(): boolean { return this.next.isKeywordLet(); }\n\n    expectCharacter(code: number) {\n        if (this.optionalCharacter(code)) return;\n        this.error(`Missing expected ${String.fromCharCode(code)}`);\n    }\n\n    optionalOperator(op: string): boolean {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    expectOperator(operator: string) {\n        if (this.optionalOperator(operator)) return;\n        this.error(`Missing expected operator ${operator}`);\n    }\n\n    expectIdentifierOrKeyword(): string {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            this.error(`Unexpected token ${n}, expected identifier or keyword`);\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    }\n\n    expectIdentifierOrKeywordOrString(): string {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    }\n\n    parseChain(): AST {\n        const exprs: AST[] = [];\n        const start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            const expr = this.parsePipe();\n            exprs.push(expr);\n\n            if (this.optionalCharacter(chars.$SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.optionalCharacter(chars.$SEMICOLON)) {\n                }  // read all semicolons\n            } else if (this.index < this.tokens.length) {\n                this.error(`Unexpected token '${this.next}'`);\n            }\n        }\n        if (exprs.length == 0) return new EmptyExpr(this.span(start));\n        if (exprs.length == 1) return exprs[0];\n        return new Chain(this.span(start), exprs);\n    }\n\n    parsePipe(): AST {\n        let result = this.parseExpression();\n        if (this.optionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n\n            do {\n                const name = this.expectIdentifierOrKeyword();\n                const args: AST[] = [];\n                while (this.optionalCharacter(chars.$COLON)) {\n                    args.push(this.parseExpression());\n                }\n                result = new BindingPipe(this.span(result.span.start), result, name, args);\n            } while (this.optionalOperator('|'));\n        }\n\n        return result;\n    }\n\n    parseExpression(): AST { return this.parseConditional(); }\n\n    parseConditional(): AST {\n        const start = this.inputIndex;\n        const result = this.parseLogicalOr();\n\n        if (this.optionalOperator('?')) {\n            const yes = this.parsePipe();\n            let no: AST;\n            if (!this.optionalCharacter(chars.$COLON)) {\n                const end = this.inputIndex;\n                const expression = this.input.substring(start, end);\n                this.error(`Conditional expression ${expression} requires all 3 expressions`);\n                no = new EmptyExpr(this.span(start));\n            } else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), result, yes, no);\n        } else {\n            return result;\n        }\n    }\n\n    parseLogicalOr(): AST {\n        // '||'\n        let result = this.parseLogicalAnd();\n        while (this.optionalOperator('||')) {\n            const right = this.parseLogicalAnd();\n            result = new Binary(this.span(result.span.start), '||', result, right);\n        }\n        return result;\n    }\n\n    parseLogicalAnd(): AST {\n        // '&&'\n        let result = this.parseEquality();\n        while (this.optionalOperator('&&')) {\n            const right = this.parseEquality();\n            result = new Binary(this.span(result.span.start), '&&', result, right);\n        }\n        return result;\n    }\n\n    parseEquality(): AST {\n        // '==','!=','===','!=='\n        let result = this.parseRelational();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    const right = this.parseRelational();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parseRelational(): AST {\n        // '<', '>', '<=', '>='\n        let result = this.parseAdditive();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    const right = this.parseAdditive();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parseAdditive(): AST {\n        // '+', '-'\n        let result = this.parseMultiplicative();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    let right = this.parseMultiplicative();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parseMultiplicative(): AST {\n        // '*', '%', '/'\n        let result = this.parsePrefix();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    let right = this.parsePrefix();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parsePrefix(): AST {\n        if (this.next.type == TokenType.Operator) {\n            const start = this.inputIndex;\n            const operator = this.next.strValue;\n            let result: AST;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    return this.parsePrefix();\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(\n                        this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0),\n                        result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), result);\n            }\n        }\n        return this.parseCallChain();\n    }\n\n    parseCallChain(): AST {\n        let result = this.parsePrimary();\n        while (true) {\n            if (this.optionalCharacter(chars.$PERIOD)) {\n                result = this.parseAccessMemberOrMethodCall(result, false);\n\n            } else if (this.optionalOperator('?.')) {\n                result = this.parseAccessMemberOrMethodCall(result, true);\n\n            } else if (this.optionalCharacter(chars.$LBRACKET)) {\n                this.rbracketsExpected++;\n                const key = this.parsePipe();\n                this.rbracketsExpected--;\n                this.expectCharacter(chars.$RBRACKET);\n                if (this.optionalOperator('=')) {\n                    const value = this.parseConditional();\n                    result = new KeyedWrite(this.span(result.span.start), result, key, value);\n                } else {\n                    result = new KeyedRead(this.span(result.span.start), result, key);\n                }\n\n            } else if (this.optionalCharacter(chars.$LPAREN)) {\n                this.rparensExpected++;\n                const args = this.parseCallArguments();\n                this.rparensExpected--;\n                this.expectCharacter(chars.$RPAREN);\n                result = new FunctionCall(this.span(result.span.start), result, args);\n\n            } else {\n                return result;\n            }\n        }\n    }\n\n    parsePrimary(): AST {\n        const start = this.inputIndex;\n        if (this.optionalCharacter(chars.$LPAREN)) {\n            this.rparensExpected++;\n            const result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter(chars.$RPAREN);\n            return result;\n\n        } else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), null);\n\n        } else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), void 0);\n\n        } else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), true);\n\n        } else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), false);\n\n        } else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ImplicitReceiver(this.span(start));\n\n        } else if (this.optionalCharacter(chars.$LBRACKET)) {\n            this.rbracketsExpected++;\n            const elements = this.parseExpressionList(chars.$RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter(chars.$RBRACKET);\n            return new LiteralArray(this.span(start), elements);\n\n        } else if (this.next.isCharacter(chars.$LBRACE)) {\n            return this.parseLiteralMap();\n\n        } else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n\n        } else if (this.next.isNumber()) {\n            const value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), value);\n\n        } else if (this.next.isString()) {\n            const literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), literalValue);\n\n        } else if (this.index >= this.tokens.length) {\n            this.error(`Unexpected end of expression: ${this.input}`);\n            return new EmptyExpr(this.span(start));\n        } else {\n            this.error(`Unexpected token ${this.next}`);\n            return new EmptyExpr(this.span(start));\n        }\n    }\n\n    parseExpressionList(terminator: number): AST[] {\n        const result: AST[] = [];\n        if (!this.next.isCharacter(terminator)) {\n            do {\n                result.push(this.parsePipe());\n            } while (this.optionalCharacter(chars.$COMMA));\n        }\n        return result;\n    }\n\n    parseLiteralMap(): LiteralMap {\n        const keys: string[] = [];\n        const values: AST[] = [];\n        const start = this.inputIndex;\n        this.expectCharacter(chars.$LBRACE);\n        if (!this.optionalCharacter(chars.$RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                const key = this.expectIdentifierOrKeywordOrString();\n                keys.push(key);\n                this.expectCharacter(chars.$COLON);\n                values.push(this.parsePipe());\n            } while (this.optionalCharacter(chars.$COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter(chars.$RBRACE);\n        }\n        return new LiteralMap(this.span(start), keys, values);\n    }\n\n    parseAccessMemberOrMethodCall(receiver: AST, isSafe: boolean = false): AST {\n        const start = receiver.span.start;\n        const id = this.expectIdentifierOrKeyword();\n\n        if (this.optionalCharacter(chars.$LPAREN)) {\n            this.rparensExpected++;\n            const args = this.parseCallArguments();\n            this.expectCharacter(chars.$RPAREN);\n            this.rparensExpected--;\n            const span = this.span(start);\n            return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                new MethodCall(span, receiver, id, args);\n\n        } else {\n            if (isSafe) {\n                if (this.optionalOperator('=')) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                    return new EmptyExpr(this.span(start));\n                } else {\n                    return new SafePropertyRead(this.span(start), receiver, id);\n                }\n            } else {\n                if (this.optionalOperator('=')) {\n                    if (!this.parseAction) {\n                        this.error('Bindings cannot contain assignments');\n                        return new EmptyExpr(this.span(start));\n                    }\n\n                    const value = this.parseConditional();\n                    return new PropertyWrite(this.span(start), receiver, id, value);\n                } else {\n                    return new PropertyRead(this.span(start), receiver, id);\n                }\n            }\n        }\n    }\n\n    parseCallArguments(): BindingPipe[] {\n        if (this.next.isCharacter(chars.$RPAREN)) return [];\n        const positionals: AST[] = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.optionalCharacter(chars.$COMMA));\n        return positionals as BindingPipe[];\n    }\n\n    /**\n     * An identifier, a keyword, a string with an optional `-` inbetween.\n     */\n    expectTemplateBindingKey(): string {\n        let result = '';\n        let operatorFound = false;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.optionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n\n        return result.toString();\n    }\n\n    parseTemplateBindings(): TemplateBindingParseResult {\n        const bindings: TemplateBinding[] = [];\n        let prefix: string = null;\n        const warnings: string[] = [];\n        while (this.index < this.tokens.length) {\n            const start = this.inputIndex;\n            const keyIsVar: boolean = this.peekKeywordLet();\n            if (keyIsVar) {\n                this.advance();\n            }\n            let key = this.expectTemplateBindingKey();\n            if (!keyIsVar) {\n                if (prefix == null) {\n                    prefix = key;\n                } else {\n                    key = prefix + key[0].toUpperCase() + key.substring(1);\n                }\n            }\n            this.optionalCharacter(chars.$COLON);\n            let name: string = null;\n            let expression: ASTWithSource = null;\n            if (keyIsVar) {\n                if (this.optionalOperator('=')) {\n                    name = this.expectTemplateBindingKey();\n                } else {\n                    name = '\\$implicit';\n                }\n            } else if (this.next !== EOF && !this.peekKeywordLet()) {\n                const start = this.inputIndex;\n                const ast = this.parsePipe();\n                const source = this.input.substring(start - this.offset, this.inputIndex - this.offset);\n                expression = new ASTWithSource(ast, source, this.location, this.errors);\n            }\n            bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n            if (!this.optionalCharacter(chars.$SEMICOLON)) {\n                this.optionalCharacter(chars.$COMMA);\n            }\n        }\n        return new TemplateBindingParseResult(bindings, warnings, this.errors);\n    }\n\n    error(message: string, index: number = null) {\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    }\n\n    private locationText(index: number = null) {\n        if (isBlank(index)) index = this.index;\n        return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n            `at the end of the expression`;\n    }\n\n    // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n    // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n    // '}' and ']' as conditional recovery points if one of calling productions is expecting\n    // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n    // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n    // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n    // must be conditional as they must be skipped if none of the calling productions are not\n    // expecting the closing token else we will never make progress in the case of an\n    // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n    // parseChain() is always the root production and it expects a ';'.\n\n    // If a production expects one of these token it increments the corresponding nesting count,\n    // and then decrements it just prior to checking if the token is in the input.\n    private skip() {\n        let n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n        (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n        (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n        (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\n            if (this.next.isError()) {\n                this.errors.push(\n                    new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n    static check(ast: AST): string[] {\n        const s = new SimpleExpressionChecker();\n        ast.visit(s);\n        return s.errors;\n    }\n\n    errors: string[] = [];\n\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n    visitInterpolation(ast: Interpolation, context: any) {}\n\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n    visitPropertyRead(ast: PropertyRead, context: any) {}\n\n    visitPropertyWrite(ast: PropertyWrite, context: any) {}\n\n    visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n\n    visitMethodCall(ast: MethodCall, context: any) {}\n\n    visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n\n    visitFunctionCall(ast: FunctionCall, context: any) {}\n\n    visitLiteralArray(ast: LiteralArray, context: any) { this.visitAll(ast.expressions); }\n\n    visitLiteralMap(ast: LiteralMap, context: any) { this.visitAll(ast.values); }\n\n    visitBinary(ast: Binary, context: any) {}\n\n    visitPrefixNot(ast: PrefixNot, context: any) {}\n\n    visitConditional(ast: Conditional, context: any) {}\n\n    visitPipe(ast: BindingPipe, context: any) { this.errors.push('pipes'); }\n\n    visitKeyedRead(ast: KeyedRead, context: any) {}\n\n    visitKeyedWrite(ast: KeyedWrite, context: any) {}\n\n    visitAll(asts: any[]): any[] { return asts.map(node => node.visit(this)); }\n\n    visitChain(ast: Chain, context: any) {}\n\n    visitQuote(ast: Quote, context: any) {}\n}","export const BinaryOperations = new Map<string, any>([\n    ['==', (left: any, right: any) => left == right],\n    ['===', (left: any, right: any) => left === right],\n    ['!=', (left: any, right: any) => left != right],\n    ['!==', (left: any, right: any) => left !== right],\n    ['&&', (left: any, right: any) => left && right],\n    ['||', (left: any, right: any) => left || right],\n    ['+', (left: any, right: any) => left + right],\n    ['-', (left: any, right: any) => left - right],\n    ['/', (left: any, right: any) => left / right],\n    ['*', (left: any, right: any) => left * right],\n    ['%', (left: any, right: any) => left % right],\n    ['<', (left: any, right: any) => left < right],\n    ['<=', (left: any, right: any) => left <= right],\n    ['>', (left: any, right: any) => left > right],\n    ['>=', (left: any, right: any) => left >= right],\n]);","export function compileToJSON(json: any) {\n    return JSON.stringify(json).replace(/\"/g, '');\n}\n\nexport function isPresent(obj: any) {\n    return obj !== null && obj !== undefined;\n}\n\nexport function isJsObject(obj: any) {\n    return obj !== null && (typeof obj === 'function' || typeof obj === 'object');\n}\n\nexport function isFunction(val: any) {\n    return typeof val === 'function';\n}","import {\n    AST,\n    RecursiveAstVisitor,\n    PropertyRead,\n    MethodCall,\n    KeyedRead,\n    ImplicitReceiver,\n    LiteralPrimitive,\n    Binary,\n    Chain,\n    Conditional,\n    BindingPipe,\n    FunctionCall,\n    Interpolation,\n    KeyedWrite,\n    LiteralArray,\n    LiteralMap,\n    PrefixNot,\n    PropertyWrite,\n    SafePropertyRead,\n    SafeMethodCall,\n    Quote\n} from '../angular';\nimport { compileToJSON } from '../util';\n\nexport class ParseVisitorCompiler extends RecursiveAstVisitor {\n\n    visitBinary(ast: Binary): any {\n        const left = ast.left.visit(this);\n        const right = ast.right.visit(this);\n\n        return `${left} ${ast.operation} ${right}`;\n    }\n\n    // TODO\n    visitChain(ast: Chain): any {\n        return compileToJSON(this.visitAll(ast.expressions));\n    }\n\n    visitConditional(ast: Conditional): any {\n        const condition = ast.condition.visit(this);\n        const trueExp = ast.trueExp.visit(this);\n        const falseExp = ast.falseExp.visit(this);\n\n        return `${condition} ? ${trueExp} : ${falseExp}`;\n    }\n\n    visitPipe(ast: BindingPipe): any {\n        const pipe = ast.name;\n        const args = this.visitAll(ast.args);\n        const value = ast.exp.visit(this);\n        args.unshift(value);\n\n        return `pipesCache.get('${pipe}').transform.apply(null, ${compileToJSON(args)})`;\n    }\n\n    // TODO\n    visitFunctionCall(ast: FunctionCall): any {\n        const target = ast.target.visit(this);\n        const args = compileToJSON(this.visitAll(ast.args));\n\n        return `${target}.apply(${target}, ${args})`;\n    }\n\n    visitImplicitReceiver(ast: ImplicitReceiver): any {\n        return `context`;\n    }\n\n    visitInterpolation(ast: Interpolation): any {\n        return this.visitAll(ast.expressions)[0];\n    }\n\n    visitKeyedRead(ast: KeyedRead): any {\n        const obj = ast.obj.visit(this);\n        const key = ast.key.visit(this);\n\n        return `${obj}[${key}]`;\n    }\n\n    visitKeyedWrite(ast: KeyedWrite): any {\n        return null;\n    }\n\n    visitLiteralArray(ast: LiteralArray): any {\n        return compileToJSON(this.visitAll(ast.expressions));\n    }\n\n    visitLiteralMap(ast: LiteralMap): any {\n        const result = {};\n        const keys = ast.keys;\n        const values = this.visitAll(ast.values);\n\n        for (let i = 0, length = keys.length; i < length; i++) {\n            result[keys[i]] = values[i];\n        }\n\n        return compileToJSON(result);\n    }\n\n    visitLiteralPrimitive(ast: LiteralPrimitive): any {\n        return typeof ast.value === 'string' ? `'${ast.value}'` : ast.value;\n    }\n\n    visitMethodCall(ast: MethodCall): any {\n        const methodName = ast.name;\n        const receiver = ast.receiver.visit(this);\n        const args = compileToJSON(this.visitAll(ast.args));\n\n        return `${receiver}['${methodName}'].apply(${receiver}, ${args})`;\n    }\n\n    visitPrefixNot(ast: PrefixNot): any {\n        return ast.expression.visit(this);\n    }\n\n    visitPropertyRead(ast: PropertyRead): any {\n        const property = ast.name;\n        const receiver = ast.receiver.visit(this);\n\n        return `${receiver}['${property}']`;\n    }\n\n    visitPropertyWrite(ast: PropertyWrite): any {\n        return null;\n    }\n\n    visitSafePropertyRead(ast: SafePropertyRead): any {\n        const property = ast.name;\n        const receiver = ast.receiver.visit(this);\n\n        return `${receiver}['${property}']`;\n    }\n\n    visitSafeMethodCall(ast: SafeMethodCall): any {\n        const methodName = ast.name;\n        const receiver = ast.receiver.visit(this);\n        const args = compileToJSON(this.visitAll(ast.args));\n\n        return `${receiver}['${methodName}'].apply(${receiver}, ${args})`;\n    }\n\n    visitAll(asts: AST[]): any {\n        return asts.map(ast => ast.visit(this));\n    }\n\n    visitQuote(ast: Quote): any {\n        return null;\n    }\n}","import {\n    AST,\n    RecursiveAstVisitor,\n    PropertyRead,\n    MethodCall,\n    KeyedRead,\n    ImplicitReceiver,\n    LiteralPrimitive,\n    Binary,\n    Chain,\n    Conditional,\n    BindingPipe,\n    FunctionCall,\n    Interpolation,\n    KeyedWrite,\n    LiteralArray,\n    LiteralMap,\n    PrefixNot,\n    PropertyWrite,\n    SafePropertyRead,\n    SafeMethodCall,\n    Quote\n} from '../angular';\nimport * as util from '../util';\nimport { BinaryOperations } from '../util/binary-operations';\n\nexport class ParseVisitorResolver extends RecursiveAstVisitor {\n\n    constructor(private pipes: Map<string, any>) {\n        super();\n    };\n\n    visitBinary(ast: Binary, context: any): any {\n        const execFn = BinaryOperations.get(ast.operation);\n\n        if (!execFn) {\n            throw new Error(`Parse ERROR: on visitBinary, unknown operator ${ast.operation}`);\n        }\n\n        return execFn(ast.left.visit(this, context), ast.right.visit(this, context));\n    }\n\n    // TODO\n    visitChain(ast: Chain, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n\n    visitConditional(ast: Conditional, context: any): any {\n        if (ast.condition.visit(this, context)) {\n            return ast.trueExp.visit(this, context);\n        }\n        else if (util.isPresent(ast.falseExp)) {\n            return ast.falseExp.visit(this, context);\n        }\n\n        return null;\n    }\n\n    visitPipe(ast: BindingPipe, context: any): any {\n        const pipe = this.pipes.get(ast.name);\n\n        if (!pipe) {\n            throw new Error(`pipe ${ast.name} not found.`);\n        }\n\n        if (!pipe.transform) {\n            throw new Error(`Parse ERROR: on visitPipe, transform method doesn't exist on pipe ${ast.name}.`);\n        }\n\n        const value = ast.exp.visit(this, context);\n        const pipeArgs = this.visitAll(ast.args, context);\n\n        pipeArgs.unshift(value);\n\n        return pipe.transform.apply(null, pipeArgs);\n    }\n\n    // TODO\n    visitFunctionCall(ast: FunctionCall, context: any): any {\n        const target = ast.target.visit(this, context);\n\n        if (!util.isFunction(target)) {\n            throw new Error(`Parse ERROR: on visitFunctionCall, target is not a function.`);\n        }\n\n        const args = this.visitAll(ast.args, context);\n        return target.apply(target, args);\n    }\n\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any {\n        return context;\n    }\n\n    visitInterpolation(ast: Interpolation, context: any): any {\n        return this.visitAll(ast.expressions, context)[0];\n    }\n\n    visitKeyedRead(ast: KeyedRead, context: any): any {\n        const obj = ast.obj.visit(this, context);\n        const key = ast.key.visit(this, context);\n        return obj[key];\n    }\n\n    visitKeyedWrite(ast: KeyedWrite, context: any): any {\n        const obj = ast.obj.visit(this, context);\n        const key = ast.key.visit(this, context);\n        const value = ast.value.visit(this, context);\n        obj[key] = value;\n        return null;\n    }\n\n    visitLiteralArray(ast: LiteralArray, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n\n    visitLiteralMap(ast: LiteralMap, context: any): any {\n        const result = {};\n        const keys = ast.keys;\n        const values = this.visitAll(ast.values, context);\n\n        for (let i = 0, length = keys.length; i < length; i++) {\n            result[keys[i]] = values[i];\n        }\n\n        return result;\n    }\n\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {\n        return ast.value;\n    }\n\n    visitMethodCall(ast: MethodCall, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitMethodCall, invalid method receiver.`);\n        }\n\n        const method = receiver[ast.name];\n\n        if (!util.isFunction(method)) {\n            throw new Error(`Parse ERROR: on visitMethodCall, method ${ast.name} doesn't exist on receiver.`);\n        }\n\n        const args = this.visitAll(ast.args, context);\n        return method.apply(receiver, args);\n    }\n\n    visitPrefixNot(ast: PrefixNot, context: any): any {\n        return ast.expression.visit(this, context);\n    }\n\n    visitPropertyRead(ast: PropertyRead, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitPropertyRead, invalid property receiver.`);\n        }\n\n        return receiver[ast.name];\n    }\n\n    visitPropertyWrite(ast: PropertyWrite, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitPropertyRead, invalid property receiver.`);\n        }\n\n        receiver[ast.name] = ast.value.visit(this, context);\n        return null;\n    }\n\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitSafePropertyRead, invalid property receiver.`);\n        }\n\n        return receiver[ast.name];\n    }\n\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitSafeMethodCall, invalid method receiver.`);\n        }\n\n        const method = receiver[ast.name];\n\n        if (!util.isFunction(method)) {\n            throw new Error(`Parse ERROR: on visitSafeMethodCall, method ${ast.name} doesn't exist on receiver.`);\n        }\n\n        const args = this.visitAll(ast.args, context);\n        return method.apply(receiver, args);\n    }\n\n    visitAll(asts: AST[], context: any): any {\n        return asts.map(ast => ast.visit(this, context));\n    }\n\n    visitQuote(ast: Quote, context: any): any {\n        throw new Error(`Parse ERROR: on visitQuote, quote expression not allowed.`);\n    }\n}","import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { Parser, Lexer, ASTWithSource } from './angular';\nimport { ParseVisitorResolver, ParseVisitorCompiler } from './visitors';\n\nexport const PIPES_CONFIG = new InjectionToken('PipesConfig');\n\nexport interface PipesConfig {\n  pipeName: string;\n  pipeInstance: any;\n}\n\n@Injectable({providedIn: 'root'})\nexport class Parse {\n  private _parser: Parser = new Parser(new Lexer());\n  private _pipesCache: Map<string, any> = new Map<string, any>();\n  private _evalCache: Map<string, Function> = new Map<string, Function>();\n  private _calcCache: Map<string, Function> = new Map<string, Function>();\n\n  /**\n   * Used to dependency inject the Angular 2 parser.\n   */\n\n  constructor(@Optional() @Inject(PIPES_CONFIG) pipesConfigs: PipesConfig[][]) {\n    if (pipesConfigs && pipesConfigs.length) {\n      pipesConfigs\n        .filter(pipes => pipes && pipes.length)\n        .forEach(pipes => pipes.forEach((pipeData) => this._pipesCache.set(pipeData.pipeName, pipeData.pipeInstance)));\n    }\n  }\n\n  eval(expression: string): Function {\n    if (this._evalCache.has(expression)) {\n      return this._evalCache.get(expression);\n    }\n\n    const visitor = new ParseVisitorCompiler();\n\n    let ast: ASTWithSource = this._parser.parseInterpolation(expression, 'Parse');\n\n    if (!ast) {\n      ast = this._parser.parseBinding(expression, 'Parse');\n    }\n\n    const fnBody = ast.visit(visitor);\n    const pipesCache = this._pipesCache;\n    const getFn = new Function('context', 'pipesCache', `return ${fnBody};`);\n\n    const evalParse = function evalParse(context: any): any {\n      return getFn(context, pipesCache);\n    };\n\n    this._evalCache.set(expression, evalParse);\n\n    return evalParse;\n  }\n\n  calc(expression: string): Function {\n    if (this._calcCache.has(expression)) {\n      return this._calcCache.get(expression);\n    }\n\n    const visitor = new ParseVisitorResolver(this._pipesCache);\n\n    let ast: ASTWithSource = this._parser.parseInterpolation(expression, 'Parse');\n\n    if (!ast) {\n      ast = this._parser.parseBinding(expression, 'Parse');\n    }\n\n    const calcParse = function calcParse(context: any): any {\n      return ast.visit(visitor, context);\n    };\n\n    this._calcCache.set(expression, calcParse);\n\n    return calcParse;\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { Parse, PIPES_CONFIG, PipesConfig } from './parse';\n\n@NgModule()\nexport class Angular2ParseModule {\n  static forRoot(pipesConfigMap: PipesConfig[]): ModuleWithProviders {\n    return {\n      ngModule: Angular2ParseModule,\n      providers: [{provide: PIPES_CONFIG, multi: true, useValue: pipesConfigMap || []}]\n    };\n  }\n}\n","/*\n * Public API Surface of angular2parse\n */\nexport * from './lib/module';\nexport * from './lib/parse'\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["chars.$EOF","chars.$SPACE","chars.isDigit","chars.$PERIOD","chars.$LPAREN","chars.$RPAREN","chars.$LBRACE","chars.$RBRACE","chars.$LBRACKET","chars.$RBRACKET","chars.$COMMA","chars.$COLON","chars.$SEMICOLON","chars.$SQ","chars.$DQ","chars.$HASH","chars.$PLUS","chars.$MINUS","chars.$STAR","chars.$SLASH","chars.$PERCENT","chars.$CARET","chars.$QUESTION","chars.$LT","chars.$GT","chars.$EQ","chars.$BANG","chars.$AMPERSAND","chars.$BAR","chars.$NBSP","chars.isWhitespace","chars.$BACKSLASH","chars.$u","chars.$a","chars.$z","chars.$A","chars.$Z","chars.$_","chars.$$","chars.isAsciiLetter","chars.$e","chars.$E","chars.$BT","chars.$n","chars.$LF","chars.$f","chars.$FF","chars.$r","chars.$CR","chars.$t","chars.$TAB","chars.$v","chars.$VTAB","isPresent","isJsObject","util.isPresent","util.isFunction","util.isJsObject"],"mappings":";;;AAAA;;;;;;;SA+BgB,uBAAuB,CAAC,IAAS;IAC7C,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,OAAO,IAAI,CAAC;AACvC,CAAC;SAEe,SAAS,CAAC,GAAQ;IAC9B,OAAO,GAAG,IAAI,IAAI,CAAC;AACvB,CAAC;SAEe,OAAO,CAAC,GAAQ;IAC5B,OAAO,GAAG,IAAI,IAAI,CAAC;AACvB,CAAC;AAED,IAAM,gBAAgB,GAAG,MAAM,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;SACnC,iBAAiB,CAAC,GAAQ;IACtC,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,IAAI,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,gBAAgB,CAAC;AACtG,CAAC;SAEe,SAAS,CAAC,KAAU;IAChC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC3B,OAAO,KAAK,CAAC;KAChB;IAED,IAAI,KAAK,IAAI,IAAI,EAAE;QACf,OAAO,EAAE,GAAG,KAAK,CAAC;KACrB;IAED,IAAI,KAAK,CAAC,cAAc,EAAE;QACtB,OAAO,KAAG,KAAK,CAAC,cAAgB,CAAC;KACpC;IAED,IAAI,KAAK,CAAC,IAAI,EAAE;QACZ,OAAO,KAAG,KAAK,CAAC,IAAM,CAAC;KAC1B;IAED,IAAM,GAAG,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;IAC7B,IAAM,YAAY,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACvC,OAAO,YAAY,KAAK,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC;AACtE,CAAC;AAED;IAAA;KAUC;IATU,+BAAiB,GAAxB,UAAyB,IAAY;QACjC,IAAM,MAAM,GAAW,QAAQ,CAAC,IAAI,CAAC,CAAC;QACtC,IAAI,KAAK,CAAC,MAAM,CAAC,EAAE;YACf,MAAM,IAAI,KAAK,CAAC,uCAAuC,GAAG,IAAI,CAAC,CAAC;SACnE;QACD,OAAO,MAAM,CAAC;KACjB;IAEM,uBAAS,GAAhB,UAAiB,KAAU,IAAa,OAAO,CAAC,KAAK,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;IACvF,oBAAC;AAAD,CAAC,IAAA;AAED;SACgB,cAAc,CAAC,CAAM,EAAE,CAAM;IACzC,OAAO,CAAC,KAAK,CAAC,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;AAC7F,CAAC;SAEe,UAAU,CAAC,CAAM;IAC7B,OAAO,CAAC,KAAK,IAAI,KAAK,OAAO,CAAC,KAAK,UAAU,IAAI,OAAO,CAAC,KAAK,QAAQ,CAAC,CAAC;AAC5E,CAAC;SAEe,KAAK,CAAC,GAAmB;;IAErC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACrB,CAAC;SAEe,IAAI,CAAC,GAAmB;IACpC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACtB,CAAC;SAEe,cAAc,CAAC,MAAW,EAAE,IAAY,EAAE,KAAU;IAChE,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC9B,IAAI,GAAG,GAAQ,MAAM,CAAC;IACtB,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;QACrB,IAAM,MAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;QAC3B,IAAI,GAAG,CAAC,cAAc,CAAC,MAAI,CAAC,IAAI,GAAG,CAAC,MAAI,CAAC,IAAI,IAAI,EAAE;YAC/C,GAAG,GAAG,GAAG,CAAC,MAAI,CAAC,CAAC;SACnB;aAAM;YACH,GAAG,GAAG,GAAG,CAAC,MAAI,CAAC,GAAG,EAAE,CAAC;SACxB;KACJ;IACD,IAAI,GAAG,KAAK,SAAS,IAAI,GAAG,KAAK,IAAI,EAAE;QACnC,GAAG,GAAG,EAAE,CAAC;KACZ;IACD,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,KAAK,CAAC;AAC/B,CAAC;SAEe,WAAW,CAAC,GAAQ;IAChC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC5B,CAAC;SAEe,YAAY,CAAC,CAAS;IAClC,OAAO,CAAC,CAAC,OAAO,CAAC,4BAA4B,EAAE,MAAM,CAAC,CAAC;AAC3D;;AC3HA;;;;;;;AASA,AAEA,IAAM,SAAS,GAAG,cAAM,OAAA,KAAK,GAAA,CAAC;;AAE9B,SAAgB,oBAAoB,CAAC,UAAkB,EAAE,KAAU;IAC/D,IAAI,CAAC,SAAS,EAAE,IAAI,OAAO,CAAC,KAAK,CAAC,EAAE;QAChC,OAAO;KACV;IACD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACvB,MAAM,IAAI,KAAK,CAAC,eAAa,UAAU,iCAA8B,CAAC,CAAC;KAC1E;IACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;QACtC,IAAI,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;YAC9B,MAAM,IAAI,KAAK,CAAC,eAAa,UAAU,iCAA8B,CAAC,CAAC;SAC1E;KACJ;AACL,CAAC;AAED,IAAM,+BAA+B,GAAG;IACpC,OAAO;IACP,MAAM;IACN,QAAQ;IACR,aAAa;IACb,OAAO;CACV,CAAC;AAEF,SAAgB,0BAA0B,CAAC,UAAkB,EAAE,KAAU;IACrE,IAAI,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,CAAC,EAAE;QAClE,MAAM,IAAI,KAAK,CAAC,eAAa,UAAU,oCAAiC,CAAC,CAAC;KAC7E;SAAM,IAAI,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACvC,IAAM,OAAK,GAAG,KAAK,CAAC,CAAC,CAAW,CAAC;QACjC,IAAM,KAAG,GAAG,KAAK,CAAC,CAAC,CAAW,CAAC;;QAE/B,+BAA+B,CAAC,OAAO,CAAC,UAAA,MAAM;YAC1C,IAAI,MAAM,CAAC,IAAI,CAAC,OAAK,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,KAAG,CAAC,EAAE;gBACxC,MAAM,IAAI,KAAK,CAAC,OAAK,OAAK,YAAO,KAAG,+CAA4C,CAAC,CAAC;aACrF;SACJ,CAAC,CAAC;KACN;AACL,CAAC;;AChDD;;;;;;;AAWA;IAEI,qBACI,OAAe,EAAS,KAAa,EAAS,WAAmB,EAAS,WAAiB;QAAnE,UAAK,GAAL,KAAK,CAAQ;QAAS,gBAAW,GAAX,WAAW,CAAQ;QAAS,gBAAW,GAAX,WAAW,CAAM;QAC3F,IAAI,CAAC,OAAO,GAAG,mBAAiB,OAAO,SAAI,WAAW,UAAK,KAAK,aAAQ,WAAa,CAAC;KACzF;IACL,kBAAC;AAAD,CAAC,IAAA;AAED;IACI,mBAAmB,KAAa,EAAS,GAAW;QAAjC,UAAK,GAAL,KAAK,CAAQ;QAAS,QAAG,GAAH,GAAG,CAAQ;KAAI;IAC5D,gBAAC;AAAD,CAAC,IAAA;AAED;IACI,aAAmB,IAAe;QAAf,SAAI,GAAJ,IAAI,CAAW;KAAI;IACtC,mBAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAAS,OAAO,IAAI,CAAC;KAAE;IACrE,sBAAQ,GAAR,cAAqB,OAAO,KAAK,CAAC,EAAE;IACxC,UAAC;AAAD,CAAC,IAAA;AAED;;;;;;;;;;;;;AAaA;IAA2B,yBAAG;IAC1B,eACI,IAAe,EAAS,MAAc,EAAS,uBAA+B,EACvE,QAAa;QAFxB,YAGI,kBAAM,IAAI,CAAC,SACd;QAH2B,YAAM,GAAN,MAAM,CAAQ;QAAS,6BAAuB,GAAvB,uBAAuB,CAAQ;QACvE,cAAQ,GAAR,QAAQ,CAAK;;KAEvB;IACD,qBAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAAS,OAAO,OAAO,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAAE;IAClG,wBAAQ,GAAR,cAAqB,OAAO,OAAO,CAAC,EAAE;IAC1C,YAAC;AAAD,CARA,CAA2B,GAAG,GAQ7B;AAED;IAA+B,6BAAG;IAAlC;;KAIC;IAHG,yBAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;;KAE7C;IACL,gBAAC;AAAD,CAJA,CAA+B,GAAG,GAIjC;AAED;IAAsC,oCAAG;IAAzC;;KAIC;IAHG,gCAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,qBAAqB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACvD;IACL,uBAAC;AAAD,CAJA,CAAsC,GAAG,GAIxC;AAED;;;AAGA;IAA2B,yBAAG;IAC1B,eAAY,IAAe,EAAS,WAAkB;QAAtD,YAA0D,kBAAM,IAAI,CAAC,SAAG;QAApC,iBAAW,GAAX,WAAW,CAAO;;KAAkB;IACxE,qBAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAAS,OAAO,OAAO,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAAE;IACtG,YAAC;AAAD,CAHA,CAA2B,GAAG,GAG7B;AAED;IAAiC,+BAAG;IAChC,qBAAY,IAAe,EAAS,SAAc,EAAS,OAAY,EAAS,QAAa;QAA7F,YACI,kBAAM,IAAI,CAAC,SACd;QAFmC,eAAS,GAAT,SAAS,CAAK;QAAS,aAAO,GAAP,OAAO,CAAK;QAAS,cAAQ,GAAR,QAAQ,CAAK;;KAE5F;IACD,2BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAClD;IACL,kBAAC;AAAD,CAPA,CAAiC,GAAG,GAOnC;AAED;IAAkC,gCAAG;IACjC,sBAAY,IAAe,EAAS,QAAa,EAAS,IAAY;QAAtE,YAA0E,kBAAM,IAAI,CAAC,SAAG;QAApD,cAAQ,GAAR,QAAQ,CAAK;QAAS,UAAI,GAAJ,IAAI,CAAQ;;KAAkB;IACxF,4BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACnD;IACL,mBAAC;AAAD,CALA,CAAkC,GAAG,GAKpC;AAED;IAAmC,iCAAG;IAClC,uBAAY,IAAe,EAAS,QAAa,EAAS,IAAY,EAAS,KAAU;QAAzF,YACI,kBAAM,IAAI,CAAC,SACd;QAFmC,cAAQ,GAAR,QAAQ,CAAK;QAAS,UAAI,GAAJ,IAAI,CAAQ;QAAS,WAAK,GAAL,KAAK,CAAK;;KAExF;IACD,6BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,kBAAkB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACpD;IACL,oBAAC;AAAD,CAPA,CAAmC,GAAG,GAOrC;AAED;IAAsC,oCAAG;IACrC,0BAAY,IAAe,EAAS,QAAa,EAAS,IAAY;QAAtE,YAA0E,kBAAM,IAAI,CAAC,SAAG;QAApD,cAAQ,GAAR,QAAQ,CAAK;QAAS,UAAI,GAAJ,IAAI,CAAQ;;KAAkB;IACxF,gCAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,qBAAqB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACvD;IACL,uBAAC;AAAD,CALA,CAAsC,GAAG,GAKxC;AAED;IAA+B,6BAAG;IAC9B,mBAAY,IAAe,EAAS,GAAQ,EAAS,GAAQ;QAA7D,YAAiE,kBAAM,IAAI,CAAC,SAAG;QAA3C,SAAG,GAAH,GAAG,CAAK;QAAS,SAAG,GAAH,GAAG,CAAK;;KAAkB;IAC/E,yBAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,cAAc,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAChD;IACL,gBAAC;AAAD,CALA,CAA+B,GAAG,GAKjC;AAED;IAAgC,8BAAG;IAC/B,oBAAY,IAAe,EAAS,GAAQ,EAAS,GAAQ,EAAS,KAAU;QAAhF,YAAoF,kBAAM,IAAI,CAAC,SAAG;QAA9D,SAAG,GAAH,GAAG,CAAK;QAAS,SAAG,GAAH,GAAG,CAAK;QAAS,WAAK,GAAL,KAAK,CAAK;;KAAkB;IAClG,0BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACjD;IACL,iBAAC;AAAD,CALA,CAAgC,GAAG,GAKlC;AAED;IAAiC,+BAAG;IAChC,qBAAY,IAAe,EAAS,GAAQ,EAAS,IAAY,EAAS,IAAW;QAArF,YACI,kBAAM,IAAI,CAAC,SACd;QAFmC,SAAG,GAAH,GAAG,CAAK;QAAS,UAAI,GAAJ,IAAI,CAAQ;QAAS,UAAI,GAAJ,IAAI,CAAO;;KAEpF;IACD,2BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAAS,OAAO,OAAO,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAAE;IACrG,kBAAC;AAAD,CALA,CAAiC,GAAG,GAKnC;AAED;IAAsC,oCAAG;IACrC,0BAAY,IAAe,EAAS,KAAU;QAA9C,YAAkD,kBAAM,IAAI,CAAC,SAAG;QAA5B,WAAK,GAAL,KAAK,CAAK;;KAAkB;IAChE,gCAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,qBAAqB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACvD;IACL,uBAAC;AAAD,CALA,CAAsC,GAAG,GAKxC;AAED;IAAkC,gCAAG;IACjC,sBAAY,IAAe,EAAS,WAAkB;QAAtD,YAA0D,kBAAM,IAAI,CAAC,SAAG;QAApC,iBAAW,GAAX,WAAW,CAAO;;KAAkB;IACxE,4BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACnD;IACL,mBAAC;AAAD,CALA,CAAkC,GAAG,GAKpC;AAED;IAAgC,8BAAG;IAC/B,oBAAY,IAAe,EAAS,IAAW,EAAS,MAAa;QAArE,YAAyE,kBAAM,IAAI,CAAC,SAAG;QAAnD,UAAI,GAAJ,IAAI,CAAO;QAAS,YAAM,GAAN,MAAM,CAAO;;KAAkB;IACvF,0BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACjD;IACL,iBAAC;AAAD,CALA,CAAgC,GAAG,GAKlC;AAED;IAAmC,iCAAG;IAClC,uBAAY,IAAe,EAAS,OAAc,EAAS,WAAkB;QAA7E,YAAiF,kBAAM,IAAI,CAAC,SAAG;QAA3D,aAAO,GAAP,OAAO,CAAO;QAAS,iBAAW,GAAX,WAAW,CAAO;;KAAkB;IAC/F,6BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,kBAAkB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACpD;IACL,oBAAC;AAAD,CALA,CAAmC,GAAG,GAKrC;AAED;IAA4B,0BAAG;IAC3B,gBAAY,IAAe,EAAS,SAAiB,EAAS,IAAS,EAAS,KAAU;QAA1F,YACI,kBAAM,IAAI,CAAC,SACd;QAFmC,eAAS,GAAT,SAAS,CAAQ;QAAS,UAAI,GAAJ,IAAI,CAAK;QAAS,WAAK,GAAL,KAAK,CAAK;;KAEzF;IACD,sBAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,WAAW,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAC7C;IACL,aAAC;AAAD,CAPA,CAA4B,GAAG,GAO9B;AAED;IAA+B,6BAAG;IAC9B,mBAAY,IAAe,EAAS,UAAe;QAAnD,YAAuD,kBAAM,IAAI,CAAC,SAAG;QAAjC,gBAAU,GAAV,UAAU,CAAK;;KAAkB;IACrE,yBAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,cAAc,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAChD;IACL,gBAAC;AAAD,CALA,CAA+B,GAAG,GAKjC;AAED;IAAgC,8BAAG;IAC/B,oBAAY,IAAe,EAAS,QAAa,EAAS,IAAY,EAAS,IAAW;QAA1F,YACI,kBAAM,IAAI,CAAC,SACd;QAFmC,cAAQ,GAAR,QAAQ,CAAK;QAAS,UAAI,GAAJ,IAAI,CAAQ;QAAS,UAAI,GAAJ,IAAI,CAAO;;KAEzF;IACD,0BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACjD;IACL,iBAAC;AAAD,CAPA,CAAgC,GAAG,GAOlC;AAED;IAAoC,kCAAG;IACnC,wBAAY,IAAe,EAAS,QAAa,EAAS,IAAY,EAAS,IAAW;QAA1F,YACI,kBAAM,IAAI,CAAC,SACd;QAFmC,cAAQ,GAAR,QAAQ,CAAK;QAAS,UAAI,GAAJ,IAAI,CAAQ;QAAS,UAAI,GAAJ,IAAI,CAAO;;KAEzF;IACD,8BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,mBAAmB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACrD;IACL,qBAAC;AAAD,CAPA,CAAoC,GAAG,GAOtC;AAED;IAAkC,gCAAG;IACjC,sBAAY,IAAe,EAAS,MAAW,EAAS,IAAW;QAAnE,YAAuE,kBAAM,IAAI,CAAC,SAAG;QAAjD,YAAM,GAAN,MAAM,CAAK;QAAS,UAAI,GAAJ,IAAI,CAAO;;KAAkB;IACrF,4BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAC1C,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACnD;IACL,mBAAC;AAAD,CALA,CAAkC,GAAG,GAKpC;AAED;IAAmC,iCAAG;IAClC,uBACW,GAAQ,EAAS,MAAc,EAAS,QAAgB,EACxD,MAAqB;QAFhC,YAGI,kBAAM,IAAI,SAAS,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,SAC/D;QAHU,SAAG,GAAH,GAAG,CAAK;QAAS,YAAM,GAAN,MAAM,CAAQ;QAAS,cAAQ,GAAR,QAAQ,CAAQ;QACxD,YAAM,GAAN,MAAM,CAAe;;KAE/B;IACD,6BAAK,GAAL,UAAM,OAAmB,EAAE,OAAmB;QAAnB,wBAAA,EAAA,cAAmB;QAAS,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;KAAE;IACjG,gCAAQ,GAAR,cAAqB,OAAU,IAAI,CAAC,MAAM,YAAO,IAAI,CAAC,QAAU,CAAC,EAAE;IACvE,oBAAC;AAAD,CARA,CAAmC,GAAG,GAQrC;AAED;IACI,yBACW,IAAe,EAAS,GAAW,EAAS,QAAiB,EAAS,IAAY,EAClF,UAAyB;QADzB,SAAI,GAAJ,IAAI,CAAW;QAAS,QAAG,GAAH,GAAG,CAAQ;QAAS,aAAQ,GAAR,QAAQ,CAAS;QAAS,SAAI,GAAJ,IAAI,CAAQ;QAClF,eAAU,GAAV,UAAU,CAAe;KAAI;IAC5C,sBAAC;AAAD,CAAC,IAAA;AAwBD;IAAA;KAyEC;IAxEG,yCAAW,GAAX,UAAY,GAAW,EAAE,OAAY;QACjC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACrB,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACtB,OAAO,IAAI,CAAC;KACf;IACD,wCAAU,GAAV,UAAW,GAAU,EAAE,OAAY,IAAS,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC,EAAE;IAC7F,8CAAgB,GAAhB,UAAiB,GAAgB,EAAE,OAAY;QAC3C,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC1B,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACxB,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACzB,OAAO,IAAI,CAAC;KACf;IACD,uCAAS,GAAT,UAAU,GAAgB,EAAE,OAAY;QACpC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACpB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjC,OAAO,IAAI,CAAC;KACf;IACD,+CAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY;QAC7C,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACvB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjC,OAAO,IAAI,CAAC;KACf;IACD,mDAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY,IAAS,OAAO,IAAI,CAAC,EAAE;IAChF,gDAAkB,GAAlB,UAAmB,GAAkB,EAAE,OAAY;QAC/C,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;KAClD;IACD,4CAAc,GAAd,UAAe,GAAc,EAAE,OAAY;QACvC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACpB,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACpB,OAAO,IAAI,CAAC;KACf;IACD,6CAAe,GAAf,UAAgB,GAAe,EAAE,OAAY;QACzC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACpB,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACpB,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACtB,OAAO,IAAI,CAAC;KACf;IACD,+CAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY;QAC7C,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;KAClD;IACD,6CAAe,GAAf,UAAgB,GAAe,EAAE,OAAY,IAAS,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,EAAE;IAClG,mDAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY,IAAS,OAAO,IAAI,CAAC,EAAE;IAChF,6CAAe,GAAf,UAAgB,GAAe,EAAE,OAAY;QACzC,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACzB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAC3C;IACD,4CAAc,GAAd,UAAe,GAAc,EAAE,OAAY;QACvC,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC3B,OAAO,IAAI,CAAC;KACf;IACD,+CAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY;QAC7C,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACzB,OAAO,IAAI,CAAC;KACf;IACD,gDAAkB,GAAlB,UAAmB,GAAkB,EAAE,OAAY;QAC/C,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACzB,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACtB,OAAO,IAAI,CAAC;KACf;IACD,mDAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY;QACrD,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACzB,OAAO,IAAI,CAAC;KACf;IACD,iDAAmB,GAAnB,UAAoB,GAAmB,EAAE,OAAY;QACjD,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACzB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAC3C;IACD,sCAAQ,GAAR,UAAS,IAAW,EAAE,OAAY;QAAlC,iBAGC;QAFG,IAAI,CAAC,OAAO,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,KAAK,CAAC,KAAI,EAAE,OAAO,CAAC,GAAA,CAAC,CAAC;QAC9C,OAAO,IAAI,CAAC;KACf;IACD,wCAAU,GAAV,UAAW,GAAU,EAAE,OAAY,IAAS,OAAO,IAAI,CAAC,EAAE;IAC9D,0BAAC;AAAD,CAAC,IAAA;AAED;IAAA;KAqFC;IApFG,8CAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY,IAAS,OAAO,GAAG,CAAC,EAAE;IAE/E,2CAAkB,GAAlB,UAAmB,GAAkB,EAAE,OAAY;QAC/C,OAAO,IAAI,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;KACnF;IAED,8CAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY;QACrD,OAAO,IAAI,gBAAgB,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;KACpD;IAED,0CAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY;QAC7C,OAAO,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;KACzE;IAED,2CAAkB,GAAlB,UAAmB,GAAkB,EAAE,OAAY;QAC/C,OAAO,IAAI,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;KACrF;IAED,8CAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY;QACrD,OAAO,IAAI,gBAAgB,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;KAC7E;IAED,wCAAe,GAAf,UAAgB,GAAe,EAAE,OAAY;QACzC,OAAO,IAAI,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;KAChG;IAED,4CAAmB,GAAnB,UAAoB,GAAmB,EAAE,OAAY;QACjD,OAAO,IAAI,cAAc,CACrB,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;KAC9E;IAED,0CAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY;QAC7C,OAAO,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;KACtF;IAED,0CAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY;QAC7C,OAAO,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;KACrE;IAED,wCAAe,GAAf,UAAgB,GAAe,EAAE,OAAY;QACzC,OAAO,IAAI,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;KACxE;IAED,oCAAW,GAAX,UAAY,GAAW,EAAE,OAAY;QACjC,OAAO,IAAI,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,SAAS,EAAE,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;KAC3F;IAED,uCAAc,GAAd,UAAe,GAAc,EAAE,OAAY;QACvC,OAAO,IAAI,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;KAC9D;IAED,yCAAgB,GAAhB,UAAiB,GAAgB,EAAE,OAAY;QAC3C,OAAO,IAAI,WAAW,CAClB,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;KAC/F;IAED,kCAAS,GAAT,UAAU,GAAgB,EAAE,OAAY;QACpC,OAAO,IAAI,WAAW,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;KAC5F;IAED,uCAAc,GAAd,UAAe,GAAc,EAAE,OAAY;QACvC,OAAO,IAAI,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;KAC5E;IAED,wCAAe,GAAf,UAAgB,GAAe,EAAE,OAAY;QACzC,OAAO,IAAI,UAAU,CACjB,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;KAClF;IAED,iCAAQ,GAAR,UAAS,IAAW;QAChB,IAAM,GAAG,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YAClC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SAChC;QACD,OAAO,GAAG,CAAC;KACd;IAED,mCAAU,GAAV,UAAW,GAAU,EAAE,OAAY;QAC/B,OAAO,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;KAC9D;IAED,mCAAU,GAAV,UAAW,GAAU,EAAE,OAAY;QAC/B,OAAO,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,uBAAuB,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;KACrF;IACL,qBAAC;AAAD,CAAC,IAAA;;ACxYD;;;;;;;AAQA,AAAO,IAAM,IAAI,GAAG,CAAC,CAAC;AACtB,AAAO,IAAM,IAAI,GAAG,CAAC,CAAC;AACtB,AAAO,IAAM,GAAG,GAAG,EAAE,CAAC;AACtB,AAAO,IAAM,KAAK,GAAG,EAAE,CAAC;AACxB,AAAO,IAAM,GAAG,GAAG,EAAE,CAAC;AACtB,AAAO,IAAM,GAAG,GAAG,EAAE,CAAC;AACtB,AAAO,IAAM,MAAM,GAAG,EAAE,CAAC;AACzB,AAAO,IAAM,KAAK,GAAG,EAAE,CAAC;AACxB,AAAO,IAAM,GAAG,GAAG,EAAE,CAAC;AACtB,AAAO,IAAM,KAAK,GAAG,EAAE,CAAC;AACxB,AAAO,IAAM,EAAE,GAAG,EAAE,CAAC;AACrB,AAAO,IAAM,QAAQ,GAAG,EAAE,CAAC;AAC3B,AAAO,IAAM,UAAU,GAAG,EAAE,CAAC;AAC7B,AAAO,IAAM,GAAG,GAAG,EAAE,CAAC;AACtB,AAAO,IAAM,OAAO,GAAG,EAAE,CAAC;AAC1B,AAAO,IAAM,OAAO,GAAG,EAAE,CAAC;AAC1B,AAAO,IAAM,KAAK,GAAG,EAAE,CAAC;AACxB,AAAO,IAAM,KAAK,GAAG,EAAE,CAAC;AACxB,AAAO,IAAM,MAAM,GAAG,EAAE,CAAC;AACzB,AAAO,IAAM,MAAM,GAAG,EAAE,CAAC;AACzB,AAAO,IAAM,OAAO,GAAG,EAAE,CAAC;AAC1B,AAAO,IAAM,MAAM,GAAG,EAAE,CAAC;AACzB,AAAO,IAAM,MAAM,GAAG,EAAE,CAAC;AACzB,AAAO,IAAM,UAAU,GAAG,EAAE,CAAC;AAC7B,AAAO,IAAM,GAAG,GAAG,EAAE,CAAC;AACtB,AAAO,IAAM,GAAG,GAAG,EAAE,CAAC;AACtB,AAAO,IAAM,GAAG,GAAG,EAAE,CAAC;AACtB,AAAO,IAAM,SAAS,GAAG,EAAE,CAAC;AAE5B,AAAO,IAAM,EAAE,GAAG,EAAE,CAAC;AACrB,AAAO,IAAM,EAAE,GAAG,EAAE,CAAC;AAErB,AAAO,IAAM,EAAE,GAAG,EAAE,CAAC;AACrB,AAAO,IAAM,EAAE,GAAG,EAAE,CAAC;AACrB,AAAO,IAAM,EAAE,GAAG,EAAE,CAAC;AACrB,AAAO,IAAM,EAAE,GAAG,EAAE,CAAC;AACrB,AAAO,IAAM,EAAE,GAAG,EAAE,CAAC;AAErB,AAAO,IAAM,SAAS,GAAG,EAAE,CAAC;AAC5B,AAAO,IAAM,UAAU,GAAG,EAAE,CAAC;AAC7B,AAAO,IAAM,SAAS,GAAG,EAAE,CAAC;AAC5B,AAAO,IAAM,MAAM,GAAG,EAAE,CAAC;AACzB,AAAO,IAAM,EAAE,GAAG,EAAE,CAAC;AAErB,AAAO,IAAM,EAAE,GAAG,EAAE,CAAC;AACrB,AAAO,IAAM,EAAE,GAAG,GAAG,CAAC;AACtB,AAAO,IAAM,EAAE,GAAG,GAAG,CAAC;AACtB,AAAO,IAAM,EAAE,GAAG,GAAG,CAAC;AACtB,AAAO,IAAM,EAAE,GAAG,GAAG,CAAC;AACtB,AAAO,IAAM,EAAE,GAAG,GAAG,CAAC;AACtB,AAAO,IAAM,EAAE,GAAG,GAAG,CAAC;AACtB,AAAO,IAAM,EAAE,GAAG,GAAG,CAAC;AACtB,AAAO,IAAM,EAAE,GAAG,GAAG,CAAC;AACtB,AAAO,IAAM,EAAE,GAAG,GAAG,CAAC;AAEtB,AAAO,IAAM,OAAO,GAAG,GAAG,CAAC;AAC3B,AAAO,IAAM,IAAI,GAAG,GAAG,CAAC;AACxB,AAAO,IAAM,OAAO,GAAG,GAAG,CAAC;AAC3B,AAAO,IAAM,KAAK,GAAG,GAAG,CAAC;AAEzB,AAAO,IAAM,KAAK,GAAG,GAAG,CAAC;AACzB,AAAO,IAAM,MAAM,GAAG,GAAG,CAAC;AAC1B,AAAO,IAAM,GAAG,GAAG,EAAE,CAAC;AAEtB,AAAO,IAAM,GAAG,GAAG,EAAE,CAAC;AAEtB,SAAgB,YAAY,CAAC,IAAY;IACrC,OAAO,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,MAAM,MAAM,IAAI,IAAI,KAAK,CAAC,CAAC;AAC/D,CAAC;AAED,SAAgB,OAAO,CAAC,IAAY;IAChC,OAAO,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;AACpC,CAAC;AAED,SAAgB,aAAa,CAAC,IAAY;IACtC,OAAO,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,EAAE,CAAC;AAChE,CAAC;AAED,SAAgB,eAAe,CAAC,IAAY;IACxC,OAAO,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,EAAE,IAAI,IAAI,IAAI,EAAE,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC;AACjF,CAAC;;ACxFD;;;;;;;AAQA,AAEA;IAUI,6BAAmB,KAAa,EAAS,GAAW;QAAjC,UAAK,GAAL,KAAK,CAAQ;QAAS,QAAG,GAAH,GAAG,CAAQ;KAAG;IAThD,6BAAS,GAAhB,UAAiB,OAAyB;QACtC,IAAI,CAAC,OAAO,EAAE;YACV,OAAO,4BAA4B,CAAC;SACvC;QAED,0BAA0B,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;QACrD,OAAO,IAAI,mBAAmB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;KAC1D;IAEsD,CAAC;IAC5D,0BAAC;AAAD,CAAC,IAAA;AAEM,IAAM,4BAA4B,GACrC,IAAI,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;;ACxBxC;;;;;;;AAQA,AAGA,IAAY,SAQX;AARD,WAAY,SAAS;IACjB,mDAAS,CAAA;IACT,qDAAU,CAAA;IACV,+CAAO,CAAA;IACP,6CAAM,CAAA;IACN,iDAAQ,CAAA;IACR,6CAAM,CAAA;IACN,2CAAK,CAAA;AACT,CAAC,EARW,SAAS,KAAT,SAAS,QAQpB;AAED,IAAM,QAAQ,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AAE5F;IAAA;KAWC;IAVG,wBAAQ,GAAR,UAAS,IAAY;QACjB,IAAM,OAAO,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC;QACnC,IAAM,MAAM,GAAY,EAAE,CAAC;QAC3B,IAAI,KAAK,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;QAChC,OAAO,KAAK,IAAI,IAAI,EAAE;YAClB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACnB,KAAK,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;SAC/B;QACD,OAAO,MAAM,CAAC;KACjB;IACL,YAAC;AAAD,CAAC,IAAA;AAED;IACI,eACW,KAAa,EAAS,IAAe,EAAS,QAAgB,EAC9D,QAAgB;QADhB,UAAK,GAAL,KAAK,CAAQ;QAAS,SAAI,GAAJ,IAAI,CAAW;QAAS,aAAQ,GAAR,QAAQ,CAAQ;QAC9D,aAAQ,GAAR,QAAQ,CAAQ;KAAI;IAE/B,2BAAW,GAAX,UAAY,IAAY;QACpB,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,SAAS,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC;KACpE;IAED,wBAAQ,GAAR,cAAsB,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE;IAE7D,wBAAQ,GAAR,cAAsB,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE;IAE7D,0BAAU,GAAV,UAAW,QAAgB;QACvB,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC;KACvE;IAED,4BAAY,GAAZ,cAA0B,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,UAAU,CAAC,EAAE;IAErE,yBAAS,GAAT,cAAuB,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,OAAO,CAAC,EAAE;IAE/D,4BAAY,GAAZ,cAA0B,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,IAAI,KAAK,CAAC,EAAE;IAE5F,6BAAa,GAAb,cAA2B,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,EAAE;IAE9F,kCAAkB,GAAlB;QACI,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,IAAI,WAAW,CAAC;KACzE;IAED,6BAAa,GAAb,cAA2B,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,EAAE;IAE9F,8BAAc,GAAd,cAA4B,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,IAAI,OAAO,CAAC,EAAE;IAEhG,6BAAa,GAAb,cAA2B,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,EAAE;IAE9F,uBAAO,GAAP,cAAqB,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,KAAK,CAAC,EAAE;IAE3D,wBAAQ,GAAR,cAAqB,OAAO,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAAE;IAEjF,wBAAQ,GAAR;QACI,QAAQ,IAAI,CAAC,IAAI;YACb,KAAK,SAAS,CAAC,SAAS,CAAC;YACzB,KAAK,SAAS,CAAC,UAAU,CAAC;YAC1B,KAAK,SAAS,CAAC,OAAO,CAAC;YACvB,KAAK,SAAS,CAAC,QAAQ,CAAC;YACxB,KAAK,SAAS,CAAC,MAAM,CAAC;YACtB,KAAK,SAAS,CAAC,KAAK;gBAChB,OAAO,IAAI,CAAC,QAAQ,CAAC;YACzB,KAAK,SAAS,CAAC,MAAM;gBACjB,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;YACpC;gBACI,OAAO,IAAI,CAAC;SACnB;KACJ;IACL,YAAC;AAAD,CAAC,IAAA;AAED,SAAS,iBAAiB,CAAC,KAAa,EAAE,IAAY;IAClD,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,SAAS,EAAE,IAAI,EAAE,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;AAClF,CAAC;AAED,SAAS,kBAAkB,CAAC,KAAa,EAAE,IAAY;IACnD,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,UAAU,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AAC3D,CAAC;AAED,SAAS,eAAe,CAAC,KAAa,EAAE,IAAY;IAChD,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,OAAO,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AACxD,CAAC;AAED,SAAS,gBAAgB,CAAC,KAAa,EAAE,IAAY;IACjD,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AACzD,CAAC;AAED,SAAS,cAAc,CAAC,KAAa,EAAE,IAAY;IAC/C,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;AACvD,CAAC;AAED,SAAS,cAAc,CAAC,KAAa,EAAE,CAAS;IAC5C,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;AACrD,CAAC;AAED,SAAS,aAAa,CAAC,KAAa,EAAE,OAAe;IACjD,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC,KAAK,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC;AACzD,CAAC;AAED,AAAO,IAAM,GAAG,GAAU,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;AAEpE;IAKI,kBAAmB,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;QAHhC,SAAI,GAAW,CAAC,CAAC;QACjB,UAAK,GAAW,CAAC,CAAC,CAAC;QAGf,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;QAC3B,IAAI,CAAC,OAAO,EAAE,CAAC;KAClB;IAED,0BAAO,GAAP;QACI,IAAI,CAAC,IAAI,GAAG,EAAE,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,GAAGA,IAAU,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAC5F;IAED,4BAAS,GAAT;QACI,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC/C,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;;QAGzC,OAAO,IAAI,IAAIC,MAAY,EAAE;YACzB,IAAI,EAAE,KAAK,IAAI,MAAM,EAAE;gBACnB,IAAI,GAAGD,IAAU,CAAC;gBAClB,MAAM;aACT;iBAAM;gBACH,IAAI,GAAG,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;aAClC;SACJ;QAED,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QAEnB,IAAI,KAAK,IAAI,MAAM,EAAE;YACjB,OAAO,IAAI,CAAC;SACf;;QAGD,IAAI,iBAAiB,CAAC,IAAI,CAAC;YAAE,OAAO,IAAI,CAAC,cAAc,EAAE,CAAC;QAC1D,IAAIE,OAAa,CAAC,IAAI,CAAC;YAAE,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAEvD,IAAM,KAAK,GAAW,KAAK,CAAC;QAC5B,QAAQ,IAAI;YACR,KAAKC,OAAa;gBACd,IAAI,CAAC,OAAO,EAAE,CAAC;gBACf,OAAOD,OAAa,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;oBACpD,iBAAiB,CAAC,KAAK,EAAEC,OAAa,CAAC,CAAC;YAChD,KAAKC,OAAa,CAAC;YACnB,KAAKC,OAAa,CAAC;YACnB,KAAKC,OAAa,CAAC;YACnB,KAAKC,OAAa,CAAC;YACnB,KAAKC,SAAe,CAAC;YACrB,KAAKC,SAAe,CAAC;YACrB,KAAKC,MAAY,CAAC;YAClB,KAAKC,MAAY,CAAC;YAClB,KAAKC,UAAgB;gBACjB,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YAC3C,KAAKC,GAAS,CAAC;YACf,KAAKC,GAAS;gBACV,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;YAC7B,KAAKC,KAAW,CAAC;YACjB,KAAKC,KAAW,CAAC;YACjB,KAAKC,MAAY,CAAC;YAClB,KAAKC,KAAW,CAAC;YACjB,KAAKC,MAAY,CAAC;YAClB,KAAKC,QAAc,CAAC;YACpB,KAAKC,MAAY;gBACb,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;YAC/D,KAAKC,SAAe;gBAChB,OAAO,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,GAAG,EAAEnB,OAAa,EAAE,GAAG,CAAC,CAAC;YACpE,KAAKoB,GAAS,CAAC;YACf,KAAKC,GAAS;gBACV,OAAO,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,EAAEC,GAAS,EAAE,GAAG,CAAC,CAAC;YACtF,KAAKC,KAAW,CAAC;YACjB,KAAKD,GAAS;gBACV,OAAO,IAAI,CAAC,mBAAmB,CAC3B,KAAK,EAAE,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,EAAEA,GAAS,EAAE,GAAG,EAAEA,GAAS,EAAE,GAAG,CAAC,CAAC;YAC1E,KAAKE,UAAgB;gBACjB,OAAO,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,GAAG,EAAEA,UAAgB,EAAE,GAAG,CAAC,CAAC;YACvE,KAAKC,IAAU;gBACX,OAAO,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,GAAG,EAAEA,IAAU,EAAE,GAAG,CAAC,CAAC;YACjE,KAAKC,KAAW;gBACZ,OAAOC,YAAkB,CAAC,IAAI,CAAC,IAAI,CAAC;oBAAE,IAAI,CAAC,OAAO,EAAE,CAAC;gBACrD,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC;SAC/B;QAED,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,2BAAyB,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,MAAG,EAAE,CAAC,CAAC,CAAC;KAC/E;IAED,gCAAa,GAAb,UAAc,KAAa,EAAE,IAAY;QACrC,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,iBAAiB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;KACzC;IAGD,+BAAY,GAAZ,UAAa,KAAa,EAAE,GAAW;QACnC,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,gBAAgB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;KACvC;;;;;;;;;;;;IAaD,sCAAmB,GAAnB,UACI,KAAa,EAAE,GAAW,EAAE,OAAe,EAAE,GAAW,EAAE,SAAkB,EAC5E,KAAc;QACd,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,IAAI,GAAG,GAAW,GAAG,CAAC;QACtB,IAAI,IAAI,CAAC,IAAI,IAAI,OAAO,EAAE;YACtB,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,GAAG,IAAI,GAAG,CAAC;SACd;QACD,IAAI,SAAS,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,SAAS,EAAE;YAC7C,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,GAAG,IAAI,KAAK,CAAC;SAChB;QACD,OAAO,gBAAgB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;KACvC;IAED,iCAAc,GAAd;QACI,IAAM,KAAK,GAAW,IAAI,CAAC,KAAK,CAAC;QACjC,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC;YAAE,IAAI,CAAC,OAAO,EAAE,CAAC;QACnD,IAAM,GAAG,GAAW,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QAC5D,OAAO,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,eAAe,CAAC,KAAK,EAAE,GAAG,CAAC;YAC3D,kBAAkB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;KACtC;IAED,6BAAU,GAAV,UAAW,KAAa;QACpB,IAAI,MAAM,IAAa,IAAI,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC;QAC7C,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,IAAI,EAAE;YACT,IAAI5B,OAAa,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;;aAE7B;iBAAM,IAAI,IAAI,CAAC,IAAI,IAAIC,OAAa,EAAE;gBACnC,MAAM,GAAG,KAAK,CAAC;aAClB;iBAAM,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBACnC,IAAI,CAAC,OAAO,EAAE,CAAC;gBACf,IAAI,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC;oBAAE,IAAI,CAAC,OAAO,EAAE,CAAC;gBAC9C,IAAI,CAACD,OAAa,CAAC,IAAI,CAAC,IAAI,CAAC;oBAAE,OAAO,IAAI,CAAC,KAAK,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC,CAAC;gBACzE,MAAM,GAAG,KAAK,CAAC;aAClB;iBAAM;gBACH,MAAM;aACT;YACD,IAAI,CAAC,OAAO,EAAE,CAAC;SAClB;QACD,IAAM,GAAG,GAAW,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QAC5D,IAAM,KAAK,GAAW,MAAM,GAAG,aAAa,CAAC,iBAAiB,CAAC,GAAG,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;QACtF,OAAO,cAAc,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;KACvC;IAED,6BAAU,GAAV;QACI,IAAM,KAAK,GAAW,IAAI,CAAC,KAAK,CAAC;QACjC,IAAM,KAAK,GAAW,IAAI,CAAC,IAAI,CAAC;QAChC,IAAI,CAAC,OAAO,EAAE,CAAC;QAEf,IAAI,MAAM,GAAW,EAAE,CAAC;QACxB,IAAI,MAAM,GAAW,IAAI,CAAC,KAAK,CAAC;QAChC,IAAM,KAAK,GAAW,IAAI,CAAC,KAAK,CAAC;QAEjC,OAAO,IAAI,CAAC,IAAI,IAAI,KAAK,EAAE;YACvB,IAAI,IAAI,CAAC,IAAI,IAAI6B,UAAgB,EAAE;gBAC/B,MAAM,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;gBAC9C,IAAI,CAAC,OAAO,EAAE,CAAC;gBACf,IAAI,aAAa,SAAQ,CAAC;;gBAE1B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;gBACtB,IAAI,IAAI,CAAC,IAAI,IAAIC,EAAQ,EAAE;;oBAEvB,IAAM,GAAG,GAAW,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;oBACpE,IAAI,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;wBAC1B,aAAa,GAAG,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;qBACrC;yBAAM;wBACH,OAAO,IAAI,CAAC,KAAK,CAAC,gCAA8B,GAAG,MAAG,EAAE,CAAC,CAAC,CAAC;qBAC9D;oBACD,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;wBAChC,IAAI,CAAC,OAAO,EAAE,CAAC;qBAClB;iBACJ;qBAAM;oBACH,aAAa,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACpC,IAAI,CAAC,OAAO,EAAE,CAAC;iBAClB;gBACD,MAAM,IAAI,MAAM,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC;gBAC7C,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;aACvB;iBAAM,IAAI,IAAI,CAAC,IAAI,IAAIhC,IAAU,EAAE;gBAChC,OAAO,IAAI,CAAC,KAAK,CAAC,oBAAoB,EAAE,CAAC,CAAC,CAAC;aAC9C;iBAAM;gBACH,IAAI,CAAC,OAAO,EAAE,CAAC;aAClB;SACJ;QAED,IAAM,IAAI,GAAW,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACzD,IAAI,CAAC,OAAO,EAAE,CAAC;QAEf,OAAO,cAAc,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC,CAAC;KAC/C;IAED,wBAAK,GAAL,UAAM,OAAe,EAAE,MAAc;QACjC,IAAM,QAAQ,GAAW,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC;QAC7C,OAAO,aAAa,CAChB,QAAQ,EAAE,kBAAgB,OAAO,mBAAc,QAAQ,wBAAmB,IAAI,CAAC,KAAK,MAAG,CAAC,CAAC;KAChG;IACL,eAAC;AAAD,CAAC,IAAA;AAED,SAAS,iBAAiB,CAAC,IAAY;IACnC,OAAO,CAACiC,EAAQ,IAAI,IAAI,IAAI,IAAI,IAAIC,EAAQ,MAAMC,EAAQ,IAAI,IAAI,IAAI,IAAI,IAAIC,EAAQ,CAAC;SAClF,IAAI,IAAIC,EAAQ,CAAC,KAAK,IAAI,IAAIC,EAAQ,CAAC,CAAC;AACjD,CAAC;AAED,SAAgB,YAAY,CAAC,KAAa;IACtC,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC;QAAE,OAAO,KAAK,CAAC;IACpC,IAAM,OAAO,GAAG,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC;IACpC,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC;QAAE,OAAO,KAAK,CAAC;IACnD,OAAO,CAAC,OAAO,EAAE,CAAC;IAClB,OAAO,OAAO,CAAC,IAAI,KAAKtC,IAAU,EAAE;QAChC,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC;YAAE,OAAO,KAAK,CAAC;QAClD,OAAO,CAAC,OAAO,EAAE,CAAC;KACrB;IACD,OAAO,IAAI,CAAC;AAChB,CAAC;AAED,SAAS,gBAAgB,CAAC,IAAY;IAClC,OAAOuC,aAAmB,CAAC,IAAI,CAAC,IAAIrC,OAAa,CAAC,IAAI,CAAC,KAAK,IAAI,IAAImC,EAAQ,CAAC;SACxE,IAAI,IAAIC,EAAQ,CAAC,CAAC;AAC3B,CAAC;AAED,SAAS,eAAe,CAAC,IAAY;IACjC,OAAO,IAAI,IAAIE,EAAQ,IAAI,IAAI,IAAIC,EAAQ,CAAC;AAChD,CAAC;AAED,SAAS,cAAc,CAAC,IAAY;IAChC,OAAO,IAAI,IAAIxB,MAAY,IAAI,IAAI,IAAID,KAAW,CAAC;AACvD,CAAC;AAED,SAAgB,OAAO,CAAC,IAAY;IAChC,OAAO,IAAI,KAAKH,GAAS,IAAI,IAAI,KAAKC,GAAS,IAAI,IAAI,KAAK4B,GAAS,CAAC;AAC1E,CAAC;AAED,SAAS,QAAQ,CAAC,IAAY;IAC1B,QAAQ,IAAI;QACR,KAAKC,EAAQ;YACT,OAAOC,GAAS,CAAC;QACrB,KAAKC,EAAQ;YACT,OAAOC,GAAS,CAAC;QACrB,KAAKC,EAAQ;YACT,OAAOC,GAAS,CAAC;QACrB,KAAKC,EAAQ;YACT,OAAOC,IAAU,CAAC;QACtB,KAAKC,EAAQ;YACT,OAAOC,KAAW,CAAC;QACvB;YACI,OAAO,IAAI,CAAC;KACnB;AACL,CAAC;;AC9XD;;;;;;;AAgBA;IACI,4BAAmB,OAAiB,EAAS,WAAqB,EAAS,OAAiB;QAAzE,YAAO,GAAP,OAAO,CAAU;QAAS,gBAAW,GAAX,WAAW,CAAU;QAAS,YAAO,GAAP,OAAO,CAAU;KAAI;IACpG,yBAAC;AAAD,CAAC,IAAA;AAED;IACI,oCACW,gBAAmC,EAAS,QAAkB,EAC9D,MAAqB;QADrB,qBAAgB,GAAhB,gBAAgB,CAAmB;QAAS,aAAQ,GAAR,QAAQ,CAAU;QAC9D,WAAM,GAAN,MAAM,CAAe;KAAI;IACxC,iCAAC;AAAD,CAAC,IAAA;AAED,SAAS,wBAAwB,CAAC,MAA2B;IACzD,IAAM,OAAO,GAAG,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,cAAc,GAAG,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACvF,OAAO,IAAI,MAAM,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;AACpC,CAAC;AAED;IAGI,gBAAoB,MAAa;QAAb,WAAM,GAAN,MAAM,CAAO;QAFzB,WAAM,GAAkB,EAAE,CAAC;KAEE;IAErC,4BAAW,GAAX,UACI,KAAa,EAAE,QAAa,EAC5B,mBAAuE;QAAvE,oCAAA,EAAA,kDAAuE;QACvE,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;QACjE,IAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;QAC/C,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;QAChE,IAAM,GAAG,GAAG,IAAI,SAAS,CACrB,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,MAAM,EAC9D,KAAK,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;aACjC,UAAU,EAAE,CAAC;QAClB,OAAO,IAAI,aAAa,CAAC,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KAC/D;IAED,6BAAY,GAAZ,UACI,KAAa,EAAE,QAAa,EAC5B,mBAAuE;QAAvE,oCAAA,EAAA,kDAAuE;QACvE,IAAM,GAAG,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;QACxE,OAAO,IAAI,aAAa,CAAC,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KAC/D;IAED,mCAAkB,GAAlB,UACI,KAAa,EAAE,QAAgB,EAC/B,mBAAuE;QAAvE,oCAAA,EAAA,kDAAuE;QACvE,IAAM,GAAG,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;QACxE,IAAM,MAAM,GAAG,uBAAuB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAClD,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YACnB,IAAI,CAAC,YAAY,CACb,4CAA0C,MAAM,CAAC,IAAI,CAAC,GAAG,CAAG,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;SACtF;QACD,OAAO,IAAI,aAAa,CAAC,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KAC/D;IAEO,6BAAY,GAApB,UAAqB,OAAe,EAAE,KAAa,EAAE,WAAmB,EAAE,WAAiB;QACvF,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,OAAO,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,CAAC;KAC/E;IAEO,iCAAgB,GAAxB,UACI,KAAa,EAAE,QAAgB,EAAE,mBAAwC;;;QAGzE,IAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QAEhD,IAAI,SAAS,CAAC,KAAK,CAAC,EAAE;YAClB,OAAO,KAAK,CAAC;SAChB;QAED,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;QACjE,IAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;QAC/C,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QACjD,OAAO,IAAI,SAAS,CAChB,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,WAAW,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAC/D,KAAK,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;aACjC,UAAU,EAAE,CAAC;KACrB;IAEO,4BAAW,GAAnB,UAAoB,KAAa,EAAE,QAAa;QAC5C,IAAI,OAAO,CAAC,KAAK,CAAC;YAAE,OAAO,IAAI,CAAC;QAChC,IAAM,oBAAoB,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAChD,IAAI,oBAAoB,IAAI,CAAC,CAAC;YAAE,OAAO,IAAI,CAAC;QAC5C,IAAM,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,oBAAoB,CAAC,CAAC,IAAI,EAAE,CAAC;QAC/D,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC;YAAE,OAAO,IAAI,CAAC;QACvC,IAAM,uBAAuB,GAAG,KAAK,CAAC,SAAS,CAAC,oBAAoB,GAAG,CAAC,CAAC,CAAC;QAC1E,OAAO,IAAI,KAAK,CAAC,IAAI,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE,uBAAuB,EAAE,QAAQ,CAAC,CAAC;KAC/F;IAED,sCAAqB,GAArB,UAAsB,WAAmB,EAAE,KAAa,EAAE,QAAa;QAEnE,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC3C,IAAI,WAAW,EAAE;;YAEb,IAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC;gBACxD,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC;gBACZ,OAAO,CAAC,CAAC;aACZ,CAAC,CAAC;YACH,MAAM,CAAC,OAAO,OAAd,MAAM,WAAY,YAAY,GAAE;SACnC;QACD,OAAO,IAAI,SAAS,CAAC,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;aAC7E,qBAAqB,EAAE,CAAC;KAChC;IAED,mCAAkB,GAAlB,UACI,KAAa,EAAE,QAAa,EAC5B,mBAAuE;QAAvE,oCAAA,EAAA,kDAAuE;QACvE,IAAM,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;QAC5E,IAAI,KAAK,IAAI,IAAI;YAAE,OAAO,IAAI,CAAC;QAE/B,IAAM,WAAW,GAAU,EAAE,CAAC;QAE9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,WAAW,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YAC/C,IAAM,cAAc,GAAG,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;YAC5C,IAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;YACxD,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/E,IAAM,GAAG,GAAG,IAAI,SAAS,CACrB,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,WAAW,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAC/D,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,cAAc,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;iBAC/D,UAAU,EAAE,CAAC;YAClB,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SACzB;QAED,OAAO,IAAI,aAAa,CACpB,IAAI,aAAa,CACb,IAAI,SAAS,CAAC,CAAC,EAAE,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC,OAAO,EAAE,WAAW,CAAC,EACpF,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KACrC;IAED,mCAAkB,GAAlB,UACI,KAAa,EAAE,QAAgB,EAC/B,mBAAuE;QAAvE,oCAAA,EAAA,kDAAuE;QACvE,IAAM,MAAM,GAAG,wBAAwB,CAAC,mBAAmB,CAAC,CAAC;QAC7D,IAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QAClC,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE;YACnB,OAAO,IAAI,CAAC;SACf;QACD,IAAM,OAAO,GAAa,EAAE,CAAC;QAC7B,IAAM,WAAW,GAAa,EAAE,CAAC;QACjC,IAAM,OAAO,GAAa,EAAE,CAAC;QAC7B,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnC,IAAM,IAAI,GAAW,KAAK,CAAC,CAAC,CAAC,CAAC;YAC9B,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;;gBAEb,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACnB,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC;aACzB;iBAAM,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC/B,MAAM,IAAI,mBAAmB,CAAC,KAAK,CAAC,MAAM,CAAC;gBAC3C,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACvB,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACrB,MAAM,IAAI,IAAI,CAAC,MAAM,GAAG,mBAAmB,CAAC,GAAG,CAAC,MAAM,CAAC;aAC1D;iBAAM;gBACH,IAAI,CAAC,YAAY,CACb,2DAA2D,EAAE,KAAK,EAClE,eAAa,IAAI,CAAC,6BAA6B,CAAC,KAAK,EAAE,CAAC,EAAE,mBAAmB,CAAC,QAAK,EACnF,QAAQ,CAAC,CAAC;gBACd,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBAC7B,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aACxB;SACJ;QACD,OAAO,IAAI,kBAAkB,CAAC,OAAO,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;KAChE;IAED,qCAAoB,GAApB,UAAqB,KAAa,EAAE,QAAa;QAC7C,OAAO,IAAI,aAAa,CACpB,IAAI,gBAAgB,CAAC,IAAI,SAAS,CAAC,CAAC,EAAE,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,EACvF,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KAC9B;IAEO,+BAAc,GAAtB,UAAuB,KAAa;QAChC,IAAM,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QACpC,OAAO,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,KAAK,CAAC;KAC9D;IAEO,8BAAa,GAArB,UAAsB,KAAa;QAC/B,IAAI,UAAU,GAAW,IAAI,CAAC;QAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;YACvC,IAAM,IAAI,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACjC,IAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAEzC,IAAI,IAAI,KAAKjC,MAAY,IAAI,QAAQ,IAAIA,MAAY,IAAI,OAAO,CAAC,UAAU,CAAC;gBAAE,OAAO,CAAC,CAAC;YAEvF,IAAI,UAAU,KAAK,IAAI,EAAE;gBACrB,UAAU,GAAG,IAAI,CAAC;aACrB;iBAAM,IAAI,OAAO,CAAC,UAAU,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;gBAC7C,UAAU,GAAG,IAAI,CAAC;aACrB;SACJ;QACD,OAAO,IAAI,CAAC;KACf;IAEO,sCAAqB,GAA7B,UACI,KAAa,EAAE,QAAa,EAAE,mBAAwC;QACtE,IAAM,MAAM,GAAG,wBAAwB,CAAC,mBAAmB,CAAC,CAAC;QAC7D,IAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QAClC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YAClB,IAAI,CAAC,YAAY,CACb,wBAAsB,mBAAmB,CAAC,KAAK,GAAG,mBAAmB,CAAC,GAAG,oCAAiC,EAC1G,KAAK,EACL,eAAa,IAAI,CAAC,6BAA6B,CAAC,KAAK,EAAE,CAAC,EAAE,mBAAmB,CAAC,QAAK,EACnF,QAAQ,CAAC,CAAC;SACjB;KACJ;IAEO,8CAA6B,GAArC,UACI,KAAe,EAAE,YAAoB,EAAE,mBAAwC;QAC/E,IAAI,WAAW,GAAG,EAAE,CAAC;QACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE;YACnC,WAAW,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;gBACtB,KAAK,CAAC,CAAC,CAAC;gBACR,KAAG,mBAAmB,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,mBAAmB,CAAC,GAAK,CAAC;SAC3E;QAED,OAAO,WAAW,CAAC,MAAM,CAAC;KAC7B;IACL,aAAC;AAAD,CAAC,IAAA;AAED;IAOI,mBACW,KAAa,EAAS,QAAa,EAAS,MAAe,EAC3D,WAAmB,EAAS,WAAoB,EAAU,MAAqB,EAC9E,MAAc;QAFf,UAAK,GAAL,KAAK,CAAQ;QAAS,aAAQ,GAAR,QAAQ,CAAK;QAAS,WAAM,GAAN,MAAM,CAAS;QAC3D,gBAAW,GAAX,WAAW,CAAQ;QAAS,gBAAW,GAAX,WAAW,CAAS;QAAU,WAAM,GAAN,MAAM,CAAe;QAC9E,WAAM,GAAN,MAAM,CAAQ;QATlB,oBAAe,GAAG,CAAC,CAAC;QACpB,sBAAiB,GAAG,CAAC,CAAC;QACtB,oBAAe,GAAG,CAAC,CAAC;QAE5B,UAAK,GAAW,CAAC,CAAC;KAKY;IAE9B,wBAAI,GAAJ,UAAK,MAAc;QACf,IAAM,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC;QAC9B,OAAO,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;KACxD;IAED,sBAAI,2BAAI;aAAR,cAAoB,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;;;OAAA;IAE1C,sBAAI,iCAAU;aAAd;YACI,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM;gBACpE,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC;SACtC;;;OAAA;IAED,wBAAI,GAAJ,UAAK,KAAa,IAAI,OAAO,IAAI,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE;IAErE,2BAAO,GAAP,cAAY,IAAI,CAAC,KAAK,EAAE,CAAC,EAAE;IAE3B,qCAAiB,GAAjB,UAAkB,IAAY;QAC1B,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;YAC7B,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,CAAC;SACf;aAAM;YACH,OAAO,KAAK,CAAC;SAChB;KACJ;IAED,kCAAc,GAAd,cAA4B,OAAO,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,EAAE;IAE9D,mCAAe,GAAf,UAAgB,IAAY;QACxB,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC;YAAE,OAAO;QACzC,IAAI,CAAC,KAAK,CAAC,sBAAoB,MAAM,CAAC,YAAY,CAAC,IAAI,CAAG,CAAC,CAAC;KAC/D;IAED,oCAAgB,GAAhB,UAAiB,EAAU;QACvB,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE;YAC1B,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,CAAC;SACf;aAAM;YACH,OAAO,KAAK,CAAC;SAChB;KACJ;IAED,kCAAc,GAAd,UAAe,QAAgB;QAC3B,IAAI,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC;YAAE,OAAO;QAC5C,IAAI,CAAC,KAAK,CAAC,+BAA6B,QAAU,CAAC,CAAC;KACvD;IAED,6CAAyB,GAAzB;QACI,IAAM,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;QACpB,IAAI,CAAC,CAAC,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC,CAAC,SAAS,EAAE,EAAE;YACrC,IAAI,CAAC,KAAK,CAAC,sBAAoB,CAAC,qCAAkC,CAAC,CAAC;YACpE,OAAO,EAAE,CAAC;SACb;QACD,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC;KACvB;IAED,qDAAiC,GAAjC;QACI,IAAM,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;QACpB,IAAI,CAAC,CAAC,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE,EAAE;YACtD,IAAI,CAAC,KAAK,CAAC,sBAAoB,CAAC,8CAA2C,CAAC,CAAC;YAC7E,OAAO,EAAE,CAAC;SACb;QACD,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC;KACvB;IAED,8BAAU,GAAV;QACI,IAAM,KAAK,GAAU,EAAE,CAAC;QACxB,IAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;QAC9B,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACpC,IAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;YAC9B,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAEjB,IAAI,IAAI,CAAC,iBAAiB,CAACP,UAAgB,CAAC,EAAE;gBAC1C,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;oBACnB,IAAI,CAAC,KAAK,CAAC,sDAAsD,CAAC,CAAC;iBACtE;gBACD,OAAO,IAAI,CAAC,iBAAiB,CAACA,UAAgB,CAAC,EAAE;iBAChD;aACJ;iBAAM,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;gBACxC,IAAI,CAAC,KAAK,CAAC,uBAAqB,IAAI,CAAC,IAAI,MAAG,CAAC,CAAC;aACjD;SACJ;QACD,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC;YAAE,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAC9D,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC;YAAE,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;QACvC,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;KAC7C;IAED,6BAAS,GAAT;QACI,IAAI,MAAM,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QACpC,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE;YAC5B,IAAI,IAAI,CAAC,WAAW,EAAE;gBAClB,IAAI,CAAC,KAAK,CAAC,4CAA4C,CAAC,CAAC;aAC5D;YAED,GAAG;gBACC,IAAM,MAAI,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;gBAC9C,IAAM,IAAI,GAAU,EAAE,CAAC;gBACvB,OAAO,IAAI,CAAC,iBAAiB,CAACD,MAAY,CAAC,EAAE;oBACzC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC;iBACrC;gBACD,MAAM,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,MAAI,EAAE,IAAI,CAAC,CAAC;aAC9E,QAAQ,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE;SACxC;QAED,OAAO,MAAM,CAAC;KACjB;IAED,mCAAe,GAAf,cAAyB,OAAO,IAAI,CAAC,gBAAgB,EAAE,CAAC,EAAE;IAE1D,oCAAgB,GAAhB;QACI,IAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;QAC9B,IAAM,MAAM,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QAErC,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE;YAC5B,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;YAC7B,IAAI,EAAE,SAAK,CAAC;YACZ,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAACA,MAAY,CAAC,EAAE;gBACvC,IAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC;gBAC5B,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;gBACpD,IAAI,CAAC,KAAK,CAAC,4BAA0B,UAAU,gCAA6B,CAAC,CAAC;gBAC9E,EAAE,GAAG,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;aACxC;iBAAM;gBACH,EAAE,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;aACzB;YACD,OAAO,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;SAC7D;aAAM;YACH,OAAO,MAAM,CAAC;SACjB;KACJ;IAED,kCAAc,GAAd;;QAEI,IAAI,MAAM,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QACpC,OAAO,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;YAChC,IAAM,KAAK,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;YACrC,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;SAC1E;QACD,OAAO,MAAM,CAAC;KACjB;IAED,mCAAe,GAAf;;QAEI,IAAI,MAAM,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QAClC,OAAO,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;YAChC,IAAM,KAAK,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;YACnC,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;SAC1E;QACD,OAAO,MAAM,CAAC;KACjB;IAED,iCAAa,GAAb;;QAEI,IAAI,MAAM,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QACpC,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,QAAQ,EAAE;YACzC,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;YACpC,QAAQ,QAAQ;gBACZ,KAAK,IAAI,CAAC;gBACV,KAAK,KAAK,CAAC;gBACX,KAAK,IAAI,CAAC;gBACV,KAAK,KAAK;oBACN,IAAI,CAAC,OAAO,EAAE,CAAC;oBACf,IAAM,KAAK,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;oBACrC,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;oBAC3E,SAAS;aAChB;YACD,MAAM;SACT;QACD,OAAO,MAAM,CAAC;KACjB;IAED,mCAAe,GAAf;;QAEI,IAAI,MAAM,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QAClC,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,QAAQ,EAAE;YACzC,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;YACpC,QAAQ,QAAQ;gBACZ,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG,CAAC;gBACT,KAAK,IAAI,CAAC;gBACV,KAAK,IAAI;oBACL,IAAI,CAAC,OAAO,EAAE,CAAC;oBACf,IAAM,KAAK,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;oBACnC,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;oBAC3E,SAAS;aAChB;YACD,MAAM;SACT;QACD,OAAO,MAAM,CAAC;KACjB;IAED,iCAAa,GAAb;;QAEI,IAAI,MAAM,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACxC,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,QAAQ,EAAE;YACzC,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;YACpC,QAAQ,QAAQ;gBACZ,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG;oBACJ,IAAI,CAAC,OAAO,EAAE,CAAC;oBACf,IAAI,KAAK,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBACvC,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;oBAC3E,SAAS;aAChB;YACD,MAAM;SACT;QACD,OAAO,MAAM,CAAC;KACjB;IAED,uCAAmB,GAAnB;;QAEI,IAAI,MAAM,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;QAChC,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,QAAQ,EAAE;YACzC,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;YACpC,QAAQ,QAAQ;gBACZ,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG;oBACJ,IAAI,CAAC,OAAO,EAAE,CAAC;oBACf,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;oBAC/B,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;oBAC3E,SAAS;aAChB;YACD,MAAM;SACT;QACD,OAAO,MAAM,CAAC;KACjB;IAED,+BAAW,GAAX;QACI,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC,QAAQ,EAAE;YACtC,IAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;YAC9B,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;YACpC,IAAI,MAAM,SAAK,CAAC;YAChB,QAAQ,QAAQ;gBACZ,KAAK,GAAG;oBACJ,IAAI,CAAC,OAAO,EAAE,CAAC;oBACf,OAAO,IAAI,CAAC,WAAW,EAAE,CAAC;gBAC9B,KAAK,GAAG;oBACJ,IAAI,CAAC,OAAO,EAAE,CAAC;oBACf,MAAM,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;oBAC5B,OAAO,IAAI,MAAM,CACb,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,gBAAgB,CAAC,IAAI,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,EAChF,MAAM,CAAC,CAAC;gBAChB,KAAK,GAAG;oBACJ,IAAI,CAAC,OAAO,EAAE,CAAC;oBACf,MAAM,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;oBAC5B,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;aACtD;SACJ;QACD,OAAO,IAAI,CAAC,cAAc,EAAE,CAAC;KAChC;IAED,kCAAc,GAAd;QACI,IAAI,MAAM,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACjC,OAAO,IAAI,EAAE;YACT,IAAI,IAAI,CAAC,iBAAiB,CAACR,OAAa,CAAC,EAAE;gBACvC,MAAM,GAAG,IAAI,CAAC,6BAA6B,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;aAE9D;iBAAM,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;gBACpC,MAAM,GAAG,IAAI,CAAC,6BAA6B,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;aAE7D;iBAAM,IAAI,IAAI,CAAC,iBAAiB,CAACK,SAAe,CAAC,EAAE;gBAChD,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACzB,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;gBAC7B,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACzB,IAAI,CAAC,eAAe,CAACC,SAAe,CAAC,CAAC;gBACtC,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE;oBAC5B,IAAM,KAAK,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;oBACtC,MAAM,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;iBAC7E;qBAAM;oBACH,MAAM,GAAG,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;iBACrE;aAEJ;iBAAM,IAAI,IAAI,CAAC,iBAAiB,CAACL,OAAa,CAAC,EAAE;gBAC9C,IAAI,CAAC,eAAe,EAAE,CAAC;gBACvB,IAAM,IAAI,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;gBACvC,IAAI,CAAC,eAAe,EAAE,CAAC;gBACvB,IAAI,CAAC,eAAe,CAACC,OAAa,CAAC,CAAC;gBACpC,MAAM,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;aAEzE;iBAAM;gBACH,OAAO,MAAM,CAAC;aACjB;SACJ;KACJ;IAED,gCAAY,GAAZ;QACI,IAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;QAC9B,IAAI,IAAI,CAAC,iBAAiB,CAACD,OAAa,CAAC,EAAE;YACvC,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,IAAM,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;YAChC,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,IAAI,CAAC,eAAe,CAACC,OAAa,CAAC,CAAC;YACpC,OAAO,MAAM,CAAC;SAEjB;aAAM,IAAI,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE;YAClC,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;SAEvD;aAAM,IAAI,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE,EAAE;YACvC,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;SAEzD;aAAM,IAAI,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE;YAClC,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;SAEvD;aAAM,IAAI,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;YACnC,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;SAExD;aAAM,IAAI,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE;YAClC,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;SAEjD;aAAM,IAAI,IAAI,CAAC,iBAAiB,CAACG,SAAe,CAAC,EAAE;YAChD,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACzB,IAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAACC,SAAe,CAAC,CAAC;YAC3D,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACzB,IAAI,CAAC,eAAe,CAACA,SAAe,CAAC,CAAC;YACtC,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,QAAQ,CAAC,CAAC;SAEvD;aAAM,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,CAACH,OAAa,CAAC,EAAE;YAC7C,OAAO,IAAI,CAAC,eAAe,EAAE,CAAC;SAEjC;aAAM,IAAI,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE;YACjC,OAAO,IAAI,CAAC,6BAA6B,CAAC,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;SAE5F;aAAM,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE;YAC7B,IAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YACnC,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;SAExD;aAAM,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE;YAC7B,IAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC1C,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,YAAY,CAAC,CAAC;SAE/D;aAAM,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACzC,IAAI,CAAC,KAAK,CAAC,mCAAiC,IAAI,CAAC,KAAO,CAAC,CAAC;YAC1D,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;SAC1C;aAAM;YACH,IAAI,CAAC,KAAK,CAAC,sBAAoB,IAAI,CAAC,IAAM,CAAC,CAAC;YAC5C,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;SAC1C;KACJ;IAED,uCAAmB,GAAnB,UAAoB,UAAkB;QAClC,IAAM,MAAM,GAAU,EAAE,CAAC;QACzB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,EAAE;YACpC,GAAG;gBACC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;aACjC,QAAQ,IAAI,CAAC,iBAAiB,CAACI,MAAY,CAAC,EAAE;SAClD;QACD,OAAO,MAAM,CAAC;KACjB;IAED,mCAAe,GAAf;QACI,IAAM,IAAI,GAAa,EAAE,CAAC;QAC1B,IAAM,MAAM,GAAU,EAAE,CAAC;QACzB,IAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;QAC9B,IAAI,CAAC,eAAe,CAACJ,OAAa,CAAC,CAAC;QACpC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAACC,OAAa,CAAC,EAAE;YACxC,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,GAAG;gBACC,IAAM,GAAG,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;gBACrD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACf,IAAI,CAAC,eAAe,CAACI,MAAY,CAAC,CAAC;gBACnC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;aACjC,QAAQ,IAAI,CAAC,iBAAiB,CAACD,MAAY,CAAC,EAAE;YAC/C,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,IAAI,CAAC,eAAe,CAACH,OAAa,CAAC,CAAC;SACvC;QACD,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;KACzD;IAED,iDAA6B,GAA7B,UAA8B,QAAa,EAAE,MAAuB;QAAvB,uBAAA,EAAA,cAAuB;QAChE,IAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;QAClC,IAAM,EAAE,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;QAE5C,IAAI,IAAI,CAAC,iBAAiB,CAACH,OAAa,CAAC,EAAE;YACvC,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,IAAM,IAAI,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;YACvC,IAAI,CAAC,eAAe,CAACC,OAAa,CAAC,CAAC;YACpC,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC9B,OAAO,MAAM,GAAG,IAAI,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAE,EAAE,IAAI,CAAC;gBACxD,IAAI,UAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC;SAEhD;aAAM;YACH,IAAI,MAAM,EAAE;gBACR,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE;oBAC5B,IAAI,CAAC,KAAK,CAAC,sDAAsD,CAAC,CAAC;oBACnE,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;iBAC1C;qBAAM;oBACH,OAAO,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAC;iBAC/D;aACJ;iBAAM;gBACH,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE;oBAC5B,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;wBACnB,IAAI,CAAC,KAAK,CAAC,qCAAqC,CAAC,CAAC;wBAClD,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;qBAC1C;oBAED,IAAM,KAAK,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;oBACtC,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;iBACnE;qBAAM;oBACH,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAC;iBAC3D;aACJ;SACJ;KACJ;IAED,sCAAkB,GAAlB;QACI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,CAACA,OAAa,CAAC;YAAE,OAAO,EAAE,CAAC;QACpD,IAAM,WAAW,GAAU,EAAE,CAAC;QAC9B,GAAG;YACC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;SACtC,QAAQ,IAAI,CAAC,iBAAiB,CAACK,MAAY,CAAC,EAAE;QAC/C,OAAO,WAA4B,CAAC;KACvC;;;;IAKD,4CAAwB,GAAxB;QACI,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,aAAa,GAAG,KAAK,CAAC;QAC1B,GAAG;YACC,MAAM,IAAI,IAAI,CAAC,iCAAiC,EAAE,CAAC;YACnD,aAAa,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;YAC3C,IAAI,aAAa,EAAE;gBACf,MAAM,IAAI,GAAG,CAAC;aACjB;SACJ,QAAQ,aAAa,EAAE;QAExB,OAAO,MAAM,CAAC,QAAQ,EAAE,CAAC;KAC5B;IAED,yCAAqB,GAArB;QACI,IAAM,QAAQ,GAAsB,EAAE,CAAC;QACvC,IAAI,MAAM,GAAW,IAAI,CAAC;QAC1B,IAAM,QAAQ,GAAa,EAAE,CAAC;QAC9B,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACpC,IAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;YAC9B,IAAM,QAAQ,GAAY,IAAI,CAAC,cAAc,EAAE,CAAC;YAChD,IAAI,QAAQ,EAAE;gBACV,IAAI,CAAC,OAAO,EAAE,CAAC;aAClB;YACD,IAAI,GAAG,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAC1C,IAAI,CAAC,QAAQ,EAAE;gBACX,IAAI,MAAM,IAAI,IAAI,EAAE;oBAChB,MAAM,GAAG,GAAG,CAAC;iBAChB;qBAAM;oBACH,GAAG,GAAG,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;iBAC1D;aACJ;YACD,IAAI,CAAC,iBAAiB,CAACC,MAAY,CAAC,CAAC;YACrC,IAAI,MAAI,GAAW,IAAI,CAAC;YACxB,IAAI,UAAU,GAAkB,IAAI,CAAC;YACrC,IAAI,QAAQ,EAAE;gBACV,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE;oBAC5B,MAAI,GAAG,IAAI,CAAC,wBAAwB,EAAE,CAAC;iBAC1C;qBAAM;oBACH,MAAI,GAAG,YAAY,CAAC;iBACvB;aACJ;iBAAM,IAAI,IAAI,CAAC,IAAI,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE;gBACpD,IAAM,OAAK,GAAG,IAAI,CAAC,UAAU,CAAC;gBAC9B,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;gBAC7B,IAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,OAAK,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;gBACxF,UAAU,GAAG,IAAI,aAAa,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;aAC3E;YACD,QAAQ,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAI,EAAE,UAAU,CAAC,CAAC,CAAC;YACtF,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAACC,UAAgB,CAAC,EAAE;gBAC3C,IAAI,CAAC,iBAAiB,CAACF,MAAY,CAAC,CAAC;aACxC;SACJ;QACD,OAAO,IAAI,0BAA0B,CAAC,QAAQ,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;KAC1E;IAED,yBAAK,GAAL,UAAM,OAAe,EAAE,KAAoB;QAApB,sBAAA,EAAA,YAAoB;QACvC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QAChG,IAAI,CAAC,IAAI,EAAE,CAAC;KACf;IAEO,gCAAY,GAApB,UAAqB,KAAoB;QAApB,sBAAA,EAAA,YAAoB;QACrC,IAAI,OAAO,CAAC,KAAK,CAAC;YAAE,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACvC,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,gBAAa,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,KAAK,GAAG,CAAC,SAAK;YAChF,8BAA8B,CAAC;KACtC;;;;;;;;;;;;;IAeO,wBAAI,GAAZ;QACI,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;QAClB,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,WAAW,CAACE,UAAgB,CAAC;aACzE,IAAI,CAAC,eAAe,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,CAACP,OAAa,CAAC,CAAC;aAC3D,IAAI,CAAC,eAAe,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,CAACE,OAAa,CAAC,CAAC;aAC3D,IAAI,CAAC,iBAAiB,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,CAACE,SAAe,CAAC,CAAC,EAAE;YAC9D,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE;gBACrB,IAAI,CAAC,MAAM,CAAC,IAAI,CACZ,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,YAAY,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;aAC9F;YACD,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;SACjB;KACJ;IACL,gBAAC;AAAD,CAAC,IAAA;AAED;IAAA;QAOI,WAAM,GAAa,EAAE,CAAC;KAyCzB;IA/CU,6BAAK,GAAZ,UAAa,GAAQ;QACjB,IAAM,CAAC,GAAG,IAAI,uBAAuB,EAAE,CAAC;QACxC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACb,OAAO,CAAC,CAAC,MAAM,CAAC;KACnB;IAID,uDAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY,KAAI;IAE7D,oDAAkB,GAAlB,UAAmB,GAAkB,EAAE,OAAY,KAAI;IAEvD,uDAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY,KAAI;IAE7D,mDAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY,KAAI;IAErD,oDAAkB,GAAlB,UAAmB,GAAkB,EAAE,OAAY,KAAI;IAEvD,uDAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY,KAAI;IAE7D,iDAAe,GAAf,UAAgB,GAAe,EAAE,OAAY,KAAI;IAEjD,qDAAmB,GAAnB,UAAoB,GAAmB,EAAE,OAAY,KAAI;IAEzD,mDAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY,KAAI;IAErD,mDAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,EAAE;IAEtF,iDAAe,GAAf,UAAgB,GAAe,EAAE,OAAY,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE;IAE7E,6CAAW,GAAX,UAAY,GAAW,EAAE,OAAY,KAAI;IAEzC,gDAAc,GAAd,UAAe,GAAc,EAAE,OAAY,KAAI;IAE/C,kDAAgB,GAAhB,UAAiB,GAAgB,EAAE,OAAY,KAAI;IAEnD,2CAAS,GAAT,UAAU,GAAgB,EAAE,OAAY,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE;IAExE,gDAAc,GAAd,UAAe,GAAc,EAAE,OAAY,KAAI;IAE/C,iDAAe,GAAf,UAAgB,GAAe,EAAE,OAAY,KAAI;IAEjD,0CAAQ,GAAR,UAAS,IAAW;QAApB,iBAA2E;QAA5C,OAAO,IAAI,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,KAAK,CAAC,KAAI,CAAC,GAAA,CAAC,CAAC;KAAE;IAE3E,4CAAU,GAAV,UAAW,GAAU,EAAE,OAAY,KAAI;IAEvC,4CAAU,GAAV,UAAW,GAAU,EAAE,OAAY,KAAI;IAC3C,8BAAC;AAAD,CAAC,IAAA;;AC1yBM,IAAM,gBAAgB,GAAG,IAAI,GAAG,CAAc;IACjD,CAAC,IAAI,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,IAAI,KAAK,GAAA,CAAC;IAChD,CAAC,KAAK,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,KAAK,KAAK,GAAA,CAAC;IAClD,CAAC,IAAI,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,IAAI,KAAK,GAAA,CAAC;IAChD,CAAC,KAAK,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,KAAK,KAAK,GAAA,CAAC;IAClD,CAAC,IAAI,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,IAAI,KAAK,GAAA,CAAC;IAChD,CAAC,IAAI,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,IAAI,KAAK,GAAA,CAAC;IAChD,CAAC,GAAG,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,GAAG,KAAK,GAAA,CAAC;IAC9C,CAAC,GAAG,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,GAAG,KAAK,GAAA,CAAC;IAC9C,CAAC,GAAG,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,GAAG,KAAK,GAAA,CAAC;IAC9C,CAAC,GAAG,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,GAAG,KAAK,GAAA,CAAC;IAC9C,CAAC,GAAG,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,GAAG,KAAK,GAAA,CAAC;IAC9C,CAAC,GAAG,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,GAAG,KAAK,GAAA,CAAC;IAC9C,CAAC,IAAI,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,IAAI,KAAK,GAAA,CAAC;IAChD,CAAC,GAAG,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,GAAG,KAAK,GAAA,CAAC;IAC9C,CAAC,IAAI,EAAE,UAAC,IAAS,EAAE,KAAU,IAAK,OAAA,IAAI,IAAI,KAAK,GAAA,CAAC;CACnD,CAAC,CAAC;;SChBa,aAAa,CAAC,IAAS;IACnC,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;AAClD,CAAC;AAED,SAAgB4C,WAAS,CAAC,GAAQ;IAC9B,OAAO,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,SAAS,CAAC;AAC7C,CAAC;AAED,SAAgBC,YAAU,CAAC,GAAQ;IAC/B,OAAO,GAAG,KAAK,IAAI,KAAK,OAAO,GAAG,KAAK,UAAU,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC;AAClF,CAAC;AAED,SAAgB,UAAU,CAAC,GAAQ;IAC/B,OAAO,OAAO,GAAG,KAAK,UAAU,CAAC;AACrC,CAAC;;ACWD;IAA0C,wCAAmB;IAA7D;;KA2HC;IAzHG,0CAAW,GAAX,UAAY,GAAW;QACnB,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAClC,IAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAEpC,OAAU,IAAI,SAAI,GAAG,CAAC,SAAS,SAAI,KAAO,CAAC;KAC9C;;IAGD,yCAAU,GAAV,UAAW,GAAU;QACjB,OAAO,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;KACxD;IAED,+CAAgB,GAAhB,UAAiB,GAAgB;QAC7B,IAAM,SAAS,GAAG,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC5C,IAAM,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACxC,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAE1C,OAAU,SAAS,WAAM,OAAO,WAAM,QAAU,CAAC;KACpD;IAED,wCAAS,GAAT,UAAU,GAAgB;QACtB,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;QACtB,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACrC,IAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAClC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAEpB,OAAO,qBAAmB,IAAI,iCAA4B,aAAa,CAAC,IAAI,CAAC,MAAG,CAAC;KACpF;;IAGD,gDAAiB,GAAjB,UAAkB,GAAiB;QAC/B,IAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACtC,IAAM,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;QAEpD,OAAU,MAAM,eAAU,MAAM,UAAK,IAAI,MAAG,CAAC;KAChD;IAED,oDAAqB,GAArB,UAAsB,GAAqB;QACvC,OAAO,SAAS,CAAC;KACpB;IAED,iDAAkB,GAAlB,UAAmB,GAAkB;QACjC,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;KAC5C;IAED,6CAAc,GAAd,UAAe,GAAc;QACzB,IAAM,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAChC,IAAM,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAEhC,OAAU,GAAG,SAAI,GAAG,MAAG,CAAC;KAC3B;IAED,8CAAe,GAAf,UAAgB,GAAe;QAC3B,OAAO,IAAI,CAAC;KACf;IAED,gDAAiB,GAAjB,UAAkB,GAAiB;QAC/B,OAAO,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;KACxD;IAED,8CAAe,GAAf,UAAgB,GAAe;QAC3B,IAAM,MAAM,GAAG,EAAE,CAAC;QAClB,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;QACtB,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAEzC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,QAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,QAAM,EAAE,CAAC,EAAE,EAAE;YACnD,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;SAC/B;QAED,OAAO,aAAa,CAAC,MAAM,CAAC,CAAC;KAChC;IAED,oDAAqB,GAArB,UAAsB,GAAqB;QACvC,OAAO,OAAO,GAAG,CAAC,KAAK,KAAK,QAAQ,GAAG,MAAI,GAAG,CAAC,KAAK,MAAG,GAAG,GAAG,CAAC,KAAK,CAAC;KACvE;IAED,8CAAe,GAAf,UAAgB,GAAe;QAC3B,IAAM,UAAU,GAAG,GAAG,CAAC,IAAI,CAAC;QAC5B,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC1C,IAAM,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;QAEpD,OAAU,QAAQ,UAAK,UAAU,iBAAY,QAAQ,UAAK,IAAI,MAAG,CAAC;KACrE;IAED,6CAAc,GAAd,UAAe,GAAc;QACzB,OAAO,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;KACrC;IAED,gDAAiB,GAAjB,UAAkB,GAAiB;QAC/B,IAAM,QAAQ,GAAG,GAAG,CAAC,IAAI,CAAC;QAC1B,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAE1C,OAAU,QAAQ,UAAK,QAAQ,OAAI,CAAC;KACvC;IAED,iDAAkB,GAAlB,UAAmB,GAAkB;QACjC,OAAO,IAAI,CAAC;KACf;IAED,oDAAqB,GAArB,UAAsB,GAAqB;QACvC,IAAM,QAAQ,GAAG,GAAG,CAAC,IAAI,CAAC;QAC1B,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAE1C,OAAU,QAAQ,UAAK,QAAQ,OAAI,CAAC;KACvC;IAED,kDAAmB,GAAnB,UAAoB,GAAmB;QACnC,IAAM,UAAU,GAAG,GAAG,CAAC,IAAI,CAAC;QAC5B,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC1C,IAAM,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;QAEpD,OAAU,QAAQ,UAAK,UAAU,iBAAY,QAAQ,UAAK,IAAI,MAAG,CAAC;KACrE;IAED,uCAAQ,GAAR,UAAS,IAAW;QAApB,iBAEC;QADG,OAAO,IAAI,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,KAAK,CAAC,KAAI,CAAC,GAAA,CAAC,CAAC;KAC3C;IAED,yCAAU,GAAV,UAAW,GAAU;QACjB,OAAO,IAAI,CAAC;KACf;IACL,2BAAC;AAAD,CA3HA,CAA0C,mBAAmB,GA2H5D;;AC1HD;IAA0C,wCAAmB;IAEzD,8BAAoB,KAAuB;QAA3C,YACI,iBAAO,SACV;QAFmB,WAAK,GAAL,KAAK,CAAkB;;KAE1C;IAAA,CAAC;IAEF,0CAAW,GAAX,UAAY,GAAW,EAAE,OAAY;QACjC,IAAM,MAAM,GAAG,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAEnD,IAAI,CAAC,MAAM,EAAE;YACT,MAAM,IAAI,KAAK,CAAC,mDAAiD,GAAG,CAAC,SAAW,CAAC,CAAC;SACrF;QAED,OAAO,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;KAChF;;IAGD,yCAAU,GAAV,UAAW,GAAU,EAAE,OAAY;QAC/B,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;KAClD;IAED,+CAAgB,GAAhB,UAAiB,GAAgB,EAAE,OAAY;QAC3C,IAAI,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE;YACpC,OAAO,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;SAC3C;aACI,IAAIC,WAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;YACnC,OAAO,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;SAC5C;QAED,OAAO,IAAI,CAAC;KACf;IAED,wCAAS,GAAT,UAAU,GAAgB,EAAE,OAAY;QACpC,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAEtC,IAAI,CAAC,IAAI,EAAE;YACP,MAAM,IAAI,KAAK,CAAC,UAAQ,GAAG,CAAC,IAAI,gBAAa,CAAC,CAAC;SAClD;QAED,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,uEAAqE,GAAG,CAAC,IAAI,MAAG,CAAC,CAAC;SACrG;QAED,IAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC3C,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAElD,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAExB,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;KAC/C;;IAGD,gDAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY;QAC7C,IAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAE/C,IAAI,CAACC,UAAe,CAAC,MAAM,CAAC,EAAE;YAC1B,MAAM,IAAI,KAAK,CAAC,8DAA8D,CAAC,CAAC;SACnF;QAED,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC9C,OAAO,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;KACrC;IAED,oDAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY;QACrD,OAAO,OAAO,CAAC;KAClB;IAED,iDAAkB,GAAlB,UAAmB,GAAkB,EAAE,OAAY;QAC/C,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;KACrD;IAED,6CAAc,GAAd,UAAe,GAAc,EAAE,OAAY;QACvC,IAAM,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACzC,IAAM,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACzC,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;KACnB;IAED,8CAAe,GAAf,UAAgB,GAAe,EAAE,OAAY;QACzC,IAAM,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACzC,IAAM,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACzC,IAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC7C,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACjB,OAAO,IAAI,CAAC;KACf;IAED,gDAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY;QAC7C,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;KAClD;IAED,8CAAe,GAAf,UAAgB,GAAe,EAAE,OAAY;QACzC,IAAM,MAAM,GAAG,EAAE,CAAC;QAClB,IAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;QACtB,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAElD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,QAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,QAAM,EAAE,CAAC,EAAE,EAAE;YACnD,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;SAC/B;QAED,OAAO,MAAM,CAAC;KACjB;IAED,oDAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY;QACrD,OAAO,GAAG,CAAC,KAAK,CAAC;KACpB;IAED,8CAAe,GAAf,UAAgB,GAAe,EAAE,OAAY;QACzC,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAEnD,IAAI,CAACC,YAAe,CAAC,QAAQ,CAAC,EAAE;YAC5B,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;SAChF;QAED,IAAM,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAElC,IAAI,CAACD,UAAe,CAAC,MAAM,CAAC,EAAE;YAC1B,MAAM,IAAI,KAAK,CAAC,6CAA2C,GAAG,CAAC,IAAI,gCAA6B,CAAC,CAAC;SACrG;QAED,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC9C,OAAO,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;KACvC;IAED,6CAAc,GAAd,UAAe,GAAc,EAAE,OAAY;QACvC,OAAO,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAC9C;IAED,gDAAiB,GAAjB,UAAkB,GAAiB,EAAE,OAAY;QAC7C,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAEnD,IAAI,CAACC,YAAe,CAAC,QAAQ,CAAC,EAAE;YAC5B,MAAM,IAAI,KAAK,CAAC,+DAA+D,CAAC,CAAC;SACpF;QAED,OAAO,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;KAC7B;IAED,iDAAkB,GAAlB,UAAmB,GAAkB,EAAE,OAAY;QAC/C,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAEnD,IAAI,CAACA,YAAe,CAAC,QAAQ,CAAC,EAAE;YAC5B,MAAM,IAAI,KAAK,CAAC,+DAA+D,CAAC,CAAC;SACpF;QAED,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACpD,OAAO,IAAI,CAAC;KACf;IAED,oDAAqB,GAArB,UAAsB,GAAqB,EAAE,OAAY;QACrD,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAEnD,IAAI,CAACA,YAAe,CAAC,QAAQ,CAAC,EAAE;YAC5B,MAAM,IAAI,KAAK,CAAC,mEAAmE,CAAC,CAAC;SACxF;QAED,OAAO,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;KAC7B;IAED,kDAAmB,GAAnB,UAAoB,GAAmB,EAAE,OAAY;QACjD,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAEnD,IAAI,CAACA,YAAe,CAAC,QAAQ,CAAC,EAAE;YAC5B,MAAM,IAAI,KAAK,CAAC,+DAA+D,CAAC,CAAC;SACpF;QAED,IAAM,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAElC,IAAI,CAACD,UAAe,CAAC,MAAM,CAAC,EAAE;YAC1B,MAAM,IAAI,KAAK,CAAC,iDAA+C,GAAG,CAAC,IAAI,gCAA6B,CAAC,CAAC;SACzG;QAED,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC9C,OAAO,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;KACvC;IAED,uCAAQ,GAAR,UAAS,IAAW,EAAE,OAAY;QAAlC,iBAEC;QADG,OAAO,IAAI,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,KAAK,CAAC,KAAI,EAAE,OAAO,CAAC,GAAA,CAAC,CAAC;KACpD;IAED,yCAAU,GAAV,UAAW,GAAU,EAAE,OAAY;QAC/B,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;KAChF;IACL,2BAAC;AAAD,CArLA,CAA0C,mBAAmB,GAqL5D;;IC3MY,YAAY,GAAG,IAAI,cAAc,CAAC,aAAa,CAAC,CAAC;AAQ9D;;;;IAUE,eAA8C,YAA6B;QAA3E,iBAMC;QAfO,YAAO,GAAW,IAAI,MAAM,CAAC,IAAI,KAAK,EAAE,CAAC,CAAC;QAC1C,gBAAW,GAAqB,IAAI,GAAG,EAAe,CAAC;QACvD,eAAU,GAA0B,IAAI,GAAG,EAAoB,CAAC;QAChE,eAAU,GAA0B,IAAI,GAAG,EAAoB,CAAC;QAOtE,IAAI,YAAY,IAAI,YAAY,CAAC,MAAM,EAAE;YACvC,YAAY;iBACT,MAAM,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,IAAI,KAAK,CAAC,MAAM,GAAA,CAAC;iBACtC,OAAO,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,OAAO,CAAC,UAAC,QAAQ,IAAK,OAAA,KAAI,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC,YAAY,CAAC,GAAA,CAAC,GAAA,CAAC,CAAC;SAClH;KACF;IAED,oBAAI,GAAJ,UAAK,UAAkB;QACrB,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;YACnC,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;SACxC;QAED,IAAM,OAAO,GAAG,IAAI,oBAAoB,EAAE,CAAC;QAE3C,IAAI,GAAG,GAAkB,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAE9E,IAAI,CAAC,GAAG,EAAE;YACR,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;SACtD;QAED,IAAM,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QAClC,IAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC;QACpC,IAAM,KAAK,GAAG,IAAI,QAAQ,CAAC,SAAS,EAAE,YAAY,EAAE,YAAU,MAAM,MAAG,CAAC,CAAC;QAEzE,IAAM,SAAS,GAAG,SAAS,SAAS,CAAC,OAAY;YAC/C,OAAO,KAAK,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;SACnC,CAAC;QAEF,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;QAE3C,OAAO,SAAS,CAAC;KAClB;IAED,oBAAI,GAAJ,UAAK,UAAkB;QACrB,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;YACnC,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;SACxC;QAED,IAAM,OAAO,GAAG,IAAI,oBAAoB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAE3D,IAAI,GAAG,GAAkB,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAE9E,IAAI,CAAC,GAAG,EAAE;YACR,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;SACtD;QAED,IAAM,SAAS,GAAG,SAAS,SAAS,CAAC,OAAY;YAC/C,OAAO,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;SACpC,CAAC;QAEF,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;QAE3C,OAAO,SAAS,CAAC;KAClB;;4CAtDY,QAAQ,YAAI,MAAM,SAAC,YAAY;;;IAVjC,KAAK;QADjB,UAAU,CAAC,EAAC,UAAU,EAAE,MAAM,EAAC,CAAC;QAWlB,WAAA,QAAQ,EAAE,CAAA,EAAE,WAAA,MAAM,CAAC,YAAY,CAAC,CAAA;OAVlC,KAAK,CAiEjB;gBA7ED;CAYA;;;ICRA;KAOC;4BAPY,mBAAmB;IACvB,2BAAO,GAAd,UAAe,cAA6B;QAC1C,OAAO;YACL,QAAQ,EAAE,qBAAmB;YAC7B,SAAS,EAAE,CAAC,EAAC,OAAO,EAAE,YAAY,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,IAAI,EAAE,EAAC,CAAC;SAClF,CAAC;KACH;;IANU,mBAAmB;QAD/B,QAAQ,EAAE;OACE,mBAAmB,CAO/B;IAAD,0BAAC;CAPD;;ACJA;;GAEG;;ACFH;;GAEG;;;;"}