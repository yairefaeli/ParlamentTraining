{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://angular2parse/lib/angular/facade/lang.ts","ng://angular2parse/lib/angular/compiler/ast.ts","ng://angular2parse/lib/angular/compiler/chars.ts","ng://angular2parse/lib/angular/compiler/interpolation-config.ts","ng://angular2parse/lib/angular/compiler/lexer.ts","ng://angular2parse/lib/angular/compiler/assertions.ts","ng://angular2parse/lib/angular/compiler/parser.ts","ng://angular2parse/lib/util/binary-operations.ts","ng://angular2parse/lib/util/lang.ts","ng://angular2parse/lib/visitors/parse-visitor-compiler.ts","ng://angular2parse/lib/visitors/parse-visitor-resolver.ts","ng://angular2parse/lib/parse.ts","ng://angular2parse/lib/module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__read","o","n","m","Symbol","iterator","e","call","ar","next","done","push","value","error","isPresent","obj","isBlank","getPrototypeOf","NumberWrapper","parseIntAutoRadix","text","result","parseInt","isNaN","Error","isNumeric","parseFloat","escapeRegExp","s","replace","ParserError","message","input","errLocation","ctxLocation","ParseSpan","start","end","AST","span","visit","visitor","context","toString","Quote","_super","prefix","uninterpretedExpression","location","_this","visitQuote","EmptyExpr","ImplicitReceiver","visitImplicitReceiver","Chain","expressions","visitChain","Conditional","condition","trueExp","falseExp","visitConditional","PropertyRead","receiver","name","visitPropertyRead","PropertyWrite","visitPropertyWrite","SafePropertyRead","visitSafePropertyRead","KeyedRead","visitKeyedRead","KeyedWrite","visitKeyedWrite","BindingPipe","exp","args","visitPipe","LiteralPrimitive","visitLiteralPrimitive","LiteralArray","visitLiteralArray","LiteralMap","keys","values","visitLiteralMap","Interpolation","strings","visitInterpolation","Binary","operation","left","right","visitBinary","PrefixNot","expression","visitPrefixNot","MethodCall","visitMethodCall","SafeMethodCall","visitSafeMethodCall","FunctionCall","visitFunctionCall","ASTWithSource","ast","source","errors","TemplateBinding","keyIsVar","RecursiveAstVisitor","visitAll","asts","forEach","AstTransformer","res","isDigit","code","TokenType","DEFAULT_INTERPOLATION_CONFIG","InterpolationConfig","fromArray","markers","identifier","isArray","assertInterpolationSymbols","KEYWORDS","Lexer","tokenize","scanner","_Scanner","tokens","token","scanToken","Token","index","type","numValue","strValue","isCharacter","Character","isNumber","Number","isString","String","isOperator","operater","Operator","isIdentifier","Identifier","isKeyword","Keyword","isKeywordLet","isKeywordNull","isKeywordUndefined","isKeywordTrue","isKeywordFalse","isKeywordThis","isError","toNumber","newCharacterToken","fromCharCode","newOperatorToken","EOF","peek","advance","charCodeAt","isIdentifierStart","scanIdentifier","chars.isDigit","scanNumber","scanCharacter","scanString","scanOperator","scanComplexOperator","str","one","twoCode","two","threeCode","three","isIdentifierPart","substring","indexOf","newIdentifierToken","simple","isExponentSign","quote","buffer","marker","unescapedCode","hex","test","unescape","last","offset","position","newErrorToken","chars.isAsciiLetter","SplitInterpolation","offsets","TemplateBindingParseResult","templateBindings","warnings","_createInterpolateRegExp","config","pattern","RegExp","Parser","_lexer","parseAction","interpolationConfig","_checkNoInterpolation","sourceToLex","_stripComments","_ParseAST","parseChain","parseBinding","_parseBindingAst","parseSimpleBinding","SimpleExpressionChecker","check","_reportError","join","_parseQuote","prefixSeparatorIndex","trim","parseTemplateBindings","prefixToken","prefixTokens","map","t","unshift","apply","concat","__spread","parseInterpolation","split","splitInterpolation","expressionText","regexp","parts","part","_findInterpolationErrorColumn","wrapLiteralPrimitive","_commentStart","outerQuote","char","nextChar","partInErrIdx","j","inputLength","rparensExpected","rbracketsExpected","rbracesExpected","inputIndex","optionalCharacter","peekKeywordLet","expectCharacter","optionalOperator","op","expectOperator","operator","expectIdentifierOrKeyword","expectIdentifierOrKeywordOrString","exprs","expr","parsePipe","parseExpression","name_1","parseConditional","parseLogicalOr","yes","no","parseLogicalAnd","parseEquality","parseRelational","parseAdditive","parseMultiplicative","parsePrefix","parseCallChain","parsePrimary","parseAccessMemberOrMethodCall","parseCallArguments","elements","parseExpressionList","parseLiteralMap","literalValue","terminator","isSafe","id","positionals","expectTemplateBindingKey","operatorFound","bindings","toUpperCase","name_2","start_1","locationText","skip","node","BinaryOperations","Map","compileToJSON","json","JSON","stringify","isJsObject","isFunction","val","ParseVisitorCompiler","pipe","length_1","methodName","property","ParseVisitorResolver","pipes","execFn","get","transform","pipeArgs","util.isFunction","util.isJsObject","method","PIPES_CONFIG","InjectionToken","Parse","pipesConfigs","_parser","_pipesCache","_evalCache","_calcCache","filter","pipeData","set","pipeName","pipeInstance","eval","has","fnBody","pipesCache","getFn","Function","evalParse","calc","calcParse","Optional","Inject","Injectable","providedIn","Angular2ParseModule","forRoot","pipesConfigMap","ngModule","Angular2ParseModule_1","providers","provide","multi","useValue","NgModule"],"mappings":";;;;;;;;;;;;;;oFAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IAGrB,SAASO,EAAUR,EAAGC,GAEzB,SAASQ,IAAOC,KAAKC,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEY,UAAkB,OAANX,EAAaC,OAAOW,OAAOZ,IAAMQ,EAAGG,UAAYX,EAAEW,UAAW,IAAIH,GA0B5E,SAASK,EAAWC,EAAYC,EAAQC,EAAKC,GAChD,IAA2HlB,EAAvHmB,EAAIC,UAAUC,OAAQC,EAAIH,EAAI,EAAIH,EAAkB,OAATE,EAAgBA,EAAOhB,OAAOqB,yBAAyBP,EAAQC,GAAOC,EACrH,GAAuB,iBAAZM,SAAoD,mBAArBA,QAAQC,SAAyBH,EAAIE,QAAQC,SAASV,EAAYC,EAAQC,EAAKC,QACpH,IAAK,IAAIQ,EAAIX,EAAWM,OAAS,EAAGK,GAAK,EAAGA,KAAS1B,EAAIe,EAAWW,MAAIJ,GAAKH,EAAI,EAAInB,EAAEsB,GAAKH,EAAI,EAAInB,EAAEgB,EAAQC,EAAKK,GAAKtB,EAAEgB,EAAQC,KAASK,GAChJ,OAAOH,EAAI,GAAKG,GAAKpB,OAAOyB,eAAeX,EAAQC,EAAKK,GAAIA,EAGzD,SAASM,EAAQC,EAAYC,GAChC,OAAO,SAAUd,EAAQC,GAAOa,EAAUd,EAAQC,EAAKY,IA6DpD,SAASE,EAAOC,EAAGC,GACtB,IAAIC,EAAsB,mBAAXC,QAAyBH,EAAEG,OAAOC,UACjD,IAAKF,EAAG,OAAOF,EACf,IAAmBV,EAAYe,EAA3BX,EAAIQ,EAAEI,KAAKN,GAAOO,EAAK,GAC3B,IACI,WAAc,IAANN,GAAgBA,KAAM,MAAQX,EAAII,EAAEc,QAAQC,MAAMF,EAAGG,KAAKpB,EAAEqB,OAExE,MAAOC,GAASP,EAAI,CAAEO,MAAOA,GACjC,QACQ,IACQtB,IAAMA,EAAEmB,OAASP,EAAIR,EAAU,SAAIQ,EAAEI,KAAKZ,GAE1D,QAAkB,GAAIW,EAAG,MAAMA,EAAEO,OAE7B,OAAOL,WCpGKM,EAAUC,GACtB,OAAc,MAAPA,WAGKC,EAAQD,GACpB,OAAc,MAAPA,EAGc5C,OAAO8C,eAAe,IA2B/C,IAAAC,EAAA,WAAA,SAAAA,KAUA,OATWA,EAAAC,kBAAP,SAAyBC,GACrB,IAAMC,EAAiBC,SAASF,GAChC,GAAIG,MAAMF,GACN,MAAM,IAAIG,MAAM,wCAA0CJ,GAE9D,OAAOC,GAGJH,EAAAO,UAAP,SAAiBb,GAAuB,OAAQW,MAAMX,EAAQc,WAAWd,KAC7EM,EAVA,YAmDgBS,EAAaC,GACzB,OAAOA,EAAEC,QAAQ,6BAA8B;;;;;;;;;;;;;;;AC/GnD,IAAAC,EAEI,SACIC,EAAwBC,EAAsBC,EAA4BC,GAAlDvD,KAAAqD,MAAAA,EAAsBrD,KAAAsD,YAAAA,EAA4BtD,KAAAuD,YAAAA,EAC1EvD,KAAKoD,QAAU,iBAAiBA,EAAO,IAAIE,EAAW,KAAKD,EAAK,QAAQE,GAIhFC,EACI,SAAmBC,EAAsBC,GAAtB1D,KAAAyD,MAAAA,EAAsBzD,KAAA0D,IAAAA,GAG7CC,EAAA,WACI,SAAAA,EAAmBC,GAAA5D,KAAA4D,KAAAA,EAGvB,OAFID,EAAAzD,UAAA2D,MAAA,SAAMC,EAAqBC,GAA4B,YAA5B,IAAAA,IAAAA,EAAA,MAAmC,MAC9DJ,EAAAzD,UAAA8D,SAAA,WAAqB,MAAO,OAChCL,EAJA,GAmBAM,EAAA,SAAAC,GACI,SAAAD,EACIL,EAAwBO,EAAuBC,EACxCC,GAFX,IAAAC,EAGIJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAFasE,EAAAH,OAAAA,EAAuBG,EAAAF,wBAAAA,EACxCE,EAAAD,SAAAA,IAKf,OAR2BvE,EAAAmE,EAAAC,GAMvBD,EAAA/D,UAAA2D,MAAA,SAAMC,EAAqBC,GAA4B,YAA5B,IAAAA,IAAAA,EAAA,MAAmCD,EAAQS,WAAWvE,KAAM+D,IACvFE,EAAA/D,UAAA8D,SAAA,WAAqB,MAAO,SAChCC,EARA,CAA2BN,GAU3Ba,EAAA,SAAAN,GAAA,SAAAM,mDAIA,OAJ+B1E,EAAA0E,EAAAN,GAC3BM,EAAAtE,UAAA2D,MAAA,SAAMC,EAAqBC,QAAA,IAAAA,IAAAA,EAAA,OAG/BS,EAJA,CAA+Bb,GAM/Bc,EAAA,SAAAP,GAAA,SAAAO,mDAIA,OAJsC3E,EAAA2E,EAAAP,GAClCO,EAAAvE,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQY,sBAAsB1E,KAAM+D,IAEnDU,EAJA,CAAsCd,GAStCgB,EAAA,SAAAT,GACI,SAAAS,EAAYf,EAAwBgB,GAApC,IAAAN,EAA0DJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAAjCsE,EAAAM,YAAAA,IAExC,OAH2B9E,EAAA6E,EAAAT,GAEvBS,EAAAzE,UAAA2D,MAAA,SAAMC,EAAqBC,GAA4B,YAA5B,IAAAA,IAAAA,EAAA,MAAmCD,EAAQe,WAAW7E,KAAM+D,IAC3FY,EAHA,CAA2BhB,GAK3BmB,EAAA,SAAAZ,GACI,SAAAY,EAAYlB,EAAwBmB,EAAuBC,EAAqBC,GAAhF,IAAAX,EACIJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YADqBsE,EAAAS,UAAAA,EAAuBT,EAAAU,QAAAA,EAAqBV,EAAAW,SAAAA,IAMpF,OAPiCnF,EAAAgF,EAAAZ,GAI7BY,EAAA5E,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQoB,iBAAiBlF,KAAM+D,IAE9Ce,EAPA,CAAiCnB,GASjCwB,EAAA,SAAAjB,GACI,SAAAiB,EAAYvB,EAAwBwB,EAAsBC,GAA1D,IAAAf,EAA0EJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAAjDsE,EAAAc,SAAAA,EAAsBd,EAAAe,KAAAA,IAI9D,OALkCvF,EAAAqF,EAAAjB,GAE9BiB,EAAAjF,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQwB,kBAAkBtF,KAAM+D,IAE/CoB,EALA,CAAkCxB,GAOlC4B,EAAA,SAAArB,GACI,SAAAqB,EAAY3B,EAAwBwB,EAAsBC,EAAqBpD,GAA/E,IAAAqC,EACIJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YADqBsE,EAAAc,SAAAA,EAAsBd,EAAAe,KAAAA,EAAqBf,EAAArC,MAAAA,IAMnF,OAPmCnC,EAAAyF,EAAArB,GAI/BqB,EAAArF,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQ0B,mBAAmBxF,KAAM+D,IAEhDwB,EAPA,CAAmC5B,GASnC8B,EAAA,SAAAvB,GACI,SAAAuB,EAAY7B,EAAwBwB,EAAsBC,GAA1D,IAAAf,EAA0EJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAAjDsE,EAAAc,SAAAA,EAAsBd,EAAAe,KAAAA,IAI9D,OALsCvF,EAAA2F,EAAAvB,GAElCuB,EAAAvF,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQ4B,sBAAsB1F,KAAM+D,IAEnD0B,EALA,CAAsC9B,GAOtCgC,EAAA,SAAAzB,GACI,SAAAyB,EAAY/B,EAAwBxB,EAAiB7B,GAArD,IAAA+D,EAAiEJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAAxCsE,EAAAlC,IAAAA,EAAiBkC,EAAA/D,IAAAA,IAIzD,OAL+BT,EAAA6F,EAAAzB,GAE3ByB,EAAAzF,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQ8B,eAAe5F,KAAM+D,IAE5C4B,EALA,CAA+BhC,GAO/BkC,EAAA,SAAA3B,GACI,SAAA2B,EAAYjC,EAAwBxB,EAAiB7B,EAAiB0B,GAAtE,IAAAqC,EAAoFJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAA3DsE,EAAAlC,IAAAA,EAAiBkC,EAAA/D,IAAAA,EAAiB+D,EAAArC,MAAAA,IAI1E,OALgCnC,EAAA+F,EAAA3B,GAE5B2B,EAAA3F,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQgC,gBAAgB9F,KAAM+D,IAE7C8B,EALA,CAAgClC,GAOhCoC,EAAA,SAAA7B,GACI,SAAA6B,EAAYnC,EAAwBoC,EAAiBX,EAAqBY,GAA1E,IAAA3B,EACIJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YADqBsE,EAAA0B,IAAAA,EAAiB1B,EAAAe,KAAAA,EAAqBf,EAAA2B,KAAAA,IAI9E,OALiCnG,EAAAiG,EAAA7B,GAI7B6B,EAAA7F,UAAA2D,MAAA,SAAMC,EAAqBC,GAA4B,YAA5B,IAAAA,IAAAA,EAAA,MAAmCD,EAAQoC,UAAUlG,KAAM+D,IAC1FgC,EALA,CAAiCpC,GAOjCwC,EAAA,SAAAjC,GACI,SAAAiC,EAAYvC,EAAwB3B,GAApC,IAAAqC,EAAkDJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAAzBsE,EAAArC,MAAAA,IAIxC,OALsCnC,EAAAqG,EAAAjC,GAElCiC,EAAAjG,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQsC,sBAAsBpG,KAAM+D,IAEnDoC,EALA,CAAsCxC,GAOtC0C,EAAA,SAAAnC,GACI,SAAAmC,EAAYzC,EAAwBgB,GAApC,IAAAN,EAA0DJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAAjCsE,EAAAM,YAAAA,IAIxC,OALkC9E,EAAAuG,EAAAnC,GAE9BmC,EAAAnG,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQwC,kBAAkBtG,KAAM+D,IAE/CsC,EALA,CAAkC1C,GAOlC4C,EAAA,SAAArC,GACI,SAAAqC,EAAY3C,EAAwB4C,EAAoBC,GAAxD,IAAAnC,EAAyEJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAAhDsE,EAAAkC,KAAAA,EAAoBlC,EAAAmC,OAAAA,IAI5D,OALgC3G,EAAAyG,EAAArC,GAE5BqC,EAAArG,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQ4C,gBAAgB1G,KAAM+D,IAE7CwC,EALA,CAAgC5C,GAOhCgD,EAAA,SAAAzC,GACI,SAAAyC,EAAY/C,EAAwBgD,EAAuBhC,GAA3D,IAAAN,EAAiFJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAAxDsE,EAAAsC,QAAAA,EAAuBtC,EAAAM,YAAAA,IAI/D,OALmC9E,EAAA6G,EAAAzC,GAE/ByC,EAAAzG,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQ+C,mBAAmB7G,KAAM+D,IAEhD4C,EALA,CAAmChD,GAOnCmD,EAAA,SAAA5C,GACI,SAAA4C,EAAYlD,EAAwBmD,EAA0BC,EAAkBC,GAAhF,IAAA3C,EACIJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YADqBsE,EAAAyC,UAAAA,EAA0BzC,EAAA0C,KAAAA,EAAkB1C,EAAA2C,MAAAA,IAMpF,OAP4BnH,EAAAgH,EAAA5C,GAIxB4C,EAAA5G,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQoD,YAAYlH,KAAM+D,IAEzC+C,EAPA,CAA4BnD,GAS5BwD,EAAA,SAAAjD,GACI,SAAAiD,EAAYvD,EAAwBwD,GAApC,IAAA9C,EAAuDJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAA9BsE,EAAA8C,WAAAA,IAIxC,OAL+BtH,EAAAqH,EAAAjD,GAE3BiD,EAAAjH,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQuD,eAAerH,KAAM+D,IAE5CoD,EALA,CAA+BxD,GAO/B2D,EAAA,SAAApD,GACI,SAAAoD,EAAY1D,EAAwBwB,EAAsBC,EAAqBY,GAA/E,IAAA3B,EACIJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YADqBsE,EAAAc,SAAAA,EAAsBd,EAAAe,KAAAA,EAAqBf,EAAA2B,KAAAA,IAMnF,OAPgCnG,EAAAwH,EAAApD,GAI5BoD,EAAApH,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQyD,gBAAgBvH,KAAM+D,IAE7CuD,EAPA,CAAgC3D,GAShC6D,EAAA,SAAAtD,GACI,SAAAsD,EAAY5D,EAAwBwB,EAAsBC,EAAqBY,GAA/E,IAAA3B,EACIJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YADqBsE,EAAAc,SAAAA,EAAsBd,EAAAe,KAAAA,EAAqBf,EAAA2B,KAAAA,IAMnF,OAPoCnG,EAAA0H,EAAAtD,GAIhCsD,EAAAtH,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQ2D,oBAAoBzH,KAAM+D,IAEjDyD,EAPA,CAAoC7D,GASpC+D,EAAA,SAAAxD,GACI,SAAAwD,EAAY9D,EAAwBtD,EAAoB2F,GAAxD,IAAA3B,EAAuEJ,EAAAtC,KAAA5B,KAAM4D,IAAK5D,YAA9CsE,EAAAhE,OAAAA,EAAoBgE,EAAA2B,KAAAA,IAI5D,OALkCnG,EAAA4H,EAAAxD,GAE9BwD,EAAAxH,UAAA2D,MAAA,SAAMC,EAAqBC,GACvB,YADuB,IAAAA,IAAAA,EAAA,MAChBD,EAAQ6D,kBAAkB3H,KAAM+D,IAE/C2D,EALA,CAAkC/D,GAOlCiE,EAAA,SAAA1D,GACI,SAAA0D,EACWC,EAAiBC,EAAuBzD,EACxC0D,GAFX,IAAAzD,EAGIJ,EAAAtC,KAAA5B,KAAM,IAAIwD,EAAU,EAAGnB,EAAQyF,GAAU,EAAIA,EAAOnH,UAAQX,YAFrDsE,EAAAuD,IAAAA,EAAiBvD,EAAAwD,OAAAA,EAAuBxD,EAAAD,SAAAA,EACxCC,EAAAyD,OAAAA,IAKf,OARmCjI,EAAA8H,EAAA1D,GAM/B0D,EAAA1H,UAAA2D,MAAA,SAAMC,EAAqBC,GAA4B,YAA5B,IAAAA,IAAAA,EAAA,MAAmC/D,KAAK6H,IAAIhE,MAAMC,EAASC,IACtF6D,EAAA1H,UAAA8D,SAAA,WAAqB,OAAUhE,KAAK8H,OAAM,OAAO9H,KAAKqE,UAC1DuD,EARA,CAAmCjE,GAUnCqE,EACI,SACWpE,EAAwBrD,EAAoB0H,EAA0B5C,EACtE+B,GADApH,KAAA4D,KAAAA,EAAwB5D,KAAAO,IAAAA,EAAoBP,KAAAiI,SAAAA,EAA0BjI,KAAAqF,KAAAA,EACtErF,KAAAoH,WAAAA,GAyBfc,EAAA,WAAA,SAAAA,KAyEA,OAxEIA,EAAAhI,UAAAgH,YAAA,SAAYW,EAAa9D,GAGrB,OAFA8D,EAAIb,KAAKnD,MAAM7D,MACf6H,EAAIZ,MAAMpD,MAAM7D,MACT,MAEXkI,EAAAhI,UAAA2E,WAAA,SAAWgD,EAAY9D,GAAqB,OAAO/D,KAAKmI,SAASN,EAAIjD,YAAab,IAClFmE,EAAAhI,UAAAgF,iBAAA,SAAiB2C,EAAkB9D,GAI/B,OAHA8D,EAAI9C,UAAUlB,MAAM7D,MACpB6H,EAAI7C,QAAQnB,MAAM7D,MAClB6H,EAAI5C,SAASpB,MAAM7D,MACZ,MAEXkI,EAAAhI,UAAAgG,UAAA,SAAU2B,EAAkB9D,GAGxB,OAFA8D,EAAI7B,IAAInC,MAAM7D,MACdA,KAAKmI,SAASN,EAAI5B,KAAMlC,GACjB,MAEXmE,EAAAhI,UAAAyH,kBAAA,SAAkBE,EAAmB9D,GAGjC,OAFA8D,EAAIvH,OAAOuD,MAAM7D,MACjBA,KAAKmI,SAASN,EAAI5B,KAAMlC,GACjB,MAEXmE,EAAAhI,UAAAwE,sBAAA,SAAsBmD,EAAuB9D,GAAqB,OAAO,MACzEmE,EAAAhI,UAAA2G,mBAAA,SAAmBgB,EAAoB9D,GACnC,OAAO/D,KAAKmI,SAASN,EAAIjD,YAAab,IAE1CmE,EAAAhI,UAAA0F,eAAA,SAAeiC,EAAgB9D,GAG3B,OAFA8D,EAAIzF,IAAIyB,MAAM7D,MACd6H,EAAItH,IAAIsD,MAAM7D,MACP,MAEXkI,EAAAhI,UAAA4F,gBAAA,SAAgB+B,EAAiB9D,GAI7B,OAHA8D,EAAIzF,IAAIyB,MAAM7D,MACd6H,EAAItH,IAAIsD,MAAM7D,MACd6H,EAAI5F,MAAM4B,MAAM7D,MACT,MAEXkI,EAAAhI,UAAAoG,kBAAA,SAAkBuB,EAAmB9D,GACjC,OAAO/D,KAAKmI,SAASN,EAAIjD,YAAab,IAE1CmE,EAAAhI,UAAAwG,gBAAA,SAAgBmB,EAAiB9D,GAAqB,OAAO/D,KAAKmI,SAASN,EAAIpB,OAAQ1C,IACvFmE,EAAAhI,UAAAkG,sBAAA,SAAsByB,EAAuB9D,GAAqB,OAAO,MACzEmE,EAAAhI,UAAAqH,gBAAA,SAAgBM,EAAiB9D,GAE7B,OADA8D,EAAIzC,SAASvB,MAAM7D,MACZA,KAAKmI,SAASN,EAAI5B,KAAMlC,IAEnCmE,EAAAhI,UAAAmH,eAAA,SAAeQ,EAAgB9D,GAE3B,OADA8D,EAAIT,WAAWvD,MAAM7D,MACd,MAEXkI,EAAAhI,UAAAoF,kBAAA,SAAkBuC,EAAmB9D,GAEjC,OADA8D,EAAIzC,SAASvB,MAAM7D,MACZ,MAEXkI,EAAAhI,UAAAsF,mBAAA,SAAmBqC,EAAoB9D,GAGnC,OAFA8D,EAAIzC,SAASvB,MAAM7D,MACnB6H,EAAI5F,MAAM4B,MAAM7D,MACT,MAEXkI,EAAAhI,UAAAwF,sBAAA,SAAsBmC,EAAuB9D,GAEzC,OADA8D,EAAIzC,SAASvB,MAAM7D,MACZ,MAEXkI,EAAAhI,UAAAuH,oBAAA,SAAoBI,EAAqB9D,GAErC,OADA8D,EAAIzC,SAASvB,MAAM7D,MACZA,KAAKmI,SAASN,EAAI5B,KAAMlC,IAEnCmE,EAAAhI,UAAAiI,SAAA,SAASC,EAAarE,GAAtB,IAAAO,EAAAtE,KAEI,OADAoI,EAAKC,SAAQ,SAAAR,GAAO,OAAAA,EAAIhE,MAAMS,EAAMP,MAC7B,MAEXmE,EAAAhI,UAAAqE,WAAA,SAAWsD,EAAY9D,GAAqB,OAAO,MACvDmE,EAzEA,IA2EA,WAAA,SAAAI,KACIA,EAAApI,UAAAwE,sBAAA,SAAsBmD,EAAuB9D,GAAqB,OAAO8D,GAEzES,EAAApI,UAAA2G,mBAAA,SAAmBgB,EAAoB9D,GACnC,OAAO,IAAI4C,EAAckB,EAAIjE,KAAMiE,EAAIjB,QAAS5G,KAAKmI,SAASN,EAAIjD,eAGtE0D,EAAApI,UAAAkG,sBAAA,SAAsByB,EAAuB9D,GACzC,OAAO,IAAIoC,EAAiB0B,EAAIjE,KAAMiE,EAAI5F,QAG9CqG,EAAApI,UAAAoF,kBAAA,SAAkBuC,EAAmB9D,GACjC,OAAO,IAAIoB,EAAa0C,EAAIjE,KAAMiE,EAAIzC,SAASvB,MAAM7D,MAAO6H,EAAIxC,OAGpEiD,EAAApI,UAAAsF,mBAAA,SAAmBqC,EAAoB9D,GACnC,OAAO,IAAIwB,EAAcsC,EAAIjE,KAAMiE,EAAIzC,SAASvB,MAAM7D,MAAO6H,EAAIxC,KAAMwC,EAAI5F,QAG/EqG,EAAApI,UAAAwF,sBAAA,SAAsBmC,EAAuB9D,GACzC,OAAO,IAAI0B,EAAiBoC,EAAIjE,KAAMiE,EAAIzC,SAASvB,MAAM7D,MAAO6H,EAAIxC,OAGxEiD,EAAApI,UAAAqH,gBAAA,SAAgBM,EAAiB9D,GAC7B,OAAO,IAAIuD,EAAWO,EAAIjE,KAAMiE,EAAIzC,SAASvB,MAAM7D,MAAO6H,EAAIxC,KAAMrF,KAAKmI,SAASN,EAAI5B,QAG1FqC,EAAApI,UAAAuH,oBAAA,SAAoBI,EAAqB9D,GACrC,OAAO,IAAIyD,EACPK,EAAIjE,KAAMiE,EAAIzC,SAASvB,MAAM7D,MAAO6H,EAAIxC,KAAMrF,KAAKmI,SAASN,EAAI5B,QAGxEqC,EAAApI,UAAAyH,kBAAA,SAAkBE,EAAmB9D,GACjC,OAAO,IAAI2D,EAAaG,EAAIjE,KAAMiE,EAAIvH,OAAOuD,MAAM7D,MAAOA,KAAKmI,SAASN,EAAI5B,QAGhFqC,EAAApI,UAAAoG,kBAAA,SAAkBuB,EAAmB9D,GACjC,OAAO,IAAIsC,EAAawB,EAAIjE,KAAM5D,KAAKmI,SAASN,EAAIjD,eAGxD0D,EAAApI,UAAAwG,gBAAA,SAAgBmB,EAAiB9D,GAC7B,OAAO,IAAIwC,EAAWsB,EAAIjE,KAAMiE,EAAIrB,KAAMxG,KAAKmI,SAASN,EAAIpB,UAGhE6B,EAAApI,UAAAgH,YAAA,SAAYW,EAAa9D,GACrB,OAAO,IAAI+C,EAAOe,EAAIjE,KAAMiE,EAAId,UAAWc,EAAIb,KAAKnD,MAAM7D,MAAO6H,EAAIZ,MAAMpD,MAAM7D,QAGrFsI,EAAApI,UAAAmH,eAAA,SAAeQ,EAAgB9D,GAC3B,OAAO,IAAIoD,EAAUU,EAAIjE,KAAMiE,EAAIT,WAAWvD,MAAM7D,QAGxDsI,EAAApI,UAAAgF,iBAAA,SAAiB2C,EAAkB9D,GAC/B,OAAO,IAAIe,EACP+C,EAAIjE,KAAMiE,EAAI9C,UAAUlB,MAAM7D,MAAO6H,EAAI7C,QAAQnB,MAAM7D,MAAO6H,EAAI5C,SAASpB,MAAM7D,QAGzFsI,EAAApI,UAAAgG,UAAA,SAAU2B,EAAkB9D,GACxB,OAAO,IAAIgC,EAAY8B,EAAIjE,KAAMiE,EAAI7B,IAAInC,MAAM7D,MAAO6H,EAAIxC,KAAMrF,KAAKmI,SAASN,EAAI5B,QAGtFqC,EAAApI,UAAA0F,eAAA,SAAeiC,EAAgB9D,GAC3B,OAAO,IAAI4B,EAAUkC,EAAIjE,KAAMiE,EAAIzF,IAAIyB,MAAM7D,MAAO6H,EAAItH,IAAIsD,MAAM7D,QAGtEsI,EAAApI,UAAA4F,gBAAA,SAAgB+B,EAAiB9D,GAC7B,OAAO,IAAI8B,EACPgC,EAAIjE,KAAMiE,EAAIzF,IAAIyB,MAAM7D,MAAO6H,EAAItH,IAAIsD,MAAM7D,MAAO6H,EAAI5F,MAAM4B,MAAM7D,QAG5EsI,EAAApI,UAAAiI,SAAA,SAASC,GAEL,IADA,IAAMG,EAAM,IAAI5I,MAAMyI,EAAKzH,QAClBK,EAAI,EAAGA,EAAIoH,EAAKzH,SAAUK,EAC/BuH,EAAIvH,GAAKoH,EAAKpH,GAAG6C,MAAM7D,MAE3B,OAAOuI,GAGXD,EAAApI,UAAA2E,WAAA,SAAWgD,EAAY9D,GACnB,OAAO,IAAIY,EAAMkD,EAAIjE,KAAM5D,KAAKmI,SAASN,EAAIjD,eAGjD0D,EAAApI,UAAAqE,WAAA,SAAWsD,EAAY9D,GACnB,OAAO,IAAIE,EAAM4D,EAAIjE,KAAMiE,EAAI1D,OAAQ0D,EAAIzD,wBAAyByD,EAAIxD,WAnFhF,GCrOA,SAAgBmE,EAAQC,GACpB,OA1Cc,IA0CDA,GAAQA,GAzCP;;;;;;;;AC9BlB,ICGYC,EDYCC,EACT,IAhBJ,WAYI,SAAAC,EAAmBnF,EAAsBC,GAAtB1D,KAAAyD,MAAAA,EAAsBzD,KAAA0D,IAAAA,EAC7C,OAVWkF,EAAAC,UAAP,SAAiBC,GACb,OAAKA,GEuBb,SAA2CC,EAAoB9G,GAC3D,GAAIE,EAAUF,MAAYtC,MAAMqJ,QAAQ/G,IAA0B,GAAhBA,EAAMtB,QACpD,MAAM,IAAIkC,MAAM,aAAakG,EAAU,mCFrBvCE,CAA2B,gBAAiBH,GACrC,IAAIF,EAAoBE,EAAQ,GAAIA,EAAQ,KAJxCH,GAQnBC,EAbA,GAgBI,CAAwB,KAAM,OCblC,SAAYF,GACRA,EAAAA,EAAA,UAAA,GAAA,YACAA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,OAAA,GAAA,SACAA,EAAAA,EAAA,SAAA,GAAA,WACAA,EAAAA,EAAA,OAAA,GAAA,SACAA,EAAAA,EAAA,MAAA,GAAA,QAPJ,CAAYA,IAAAA,EAAS,KAUrB,IAAMQ,EAAW,CAAC,MAAO,MAAO,OAAQ,YAAa,OAAQ,QAAS,KAAM,OAAQ,QAEpFC,EAAA,WAAA,SAAAA,KAWA,OAVIA,EAAAjJ,UAAAkJ,SAAA,SAAS3G,GAIL,IAHA,IAAM4G,EAAU,IAAIC,EAAS7G,GACvB8G,EAAkB,GACpBC,EAAQH,EAAQI,YACJ,MAATD,GACHD,EAAOvH,KAAKwH,GACZA,EAAQH,EAAQI,YAEpB,OAAOF,GAEfJ,EAXA,GAaAO,EAAA,WACI,SAAAA,EACWC,EAAsBC,EAAwBC,EAC9CC,GADA9J,KAAA2J,MAAAA,EAAsB3J,KAAA4J,KAAAA,EAAwB5J,KAAA6J,SAAAA,EAC9C7J,KAAA8J,SAAAA,EAmDf,OAjDIJ,EAAAxJ,UAAA6J,YAAA,SAAYtB,GACR,OAAOzI,KAAK4J,MAAQlB,EAAUsB,WAAahK,KAAK6J,UAAYpB,GAGhEiB,EAAAxJ,UAAA+J,SAAA,WAAsB,OAAOjK,KAAK4J,MAAQlB,EAAUwB,QAEpDR,EAAAxJ,UAAAiK,SAAA,WAAsB,OAAOnK,KAAK4J,MAAQlB,EAAU0B,QAEpDV,EAAAxJ,UAAAmK,WAAA,SAAWC,GACP,OAAOtK,KAAK4J,MAAQlB,EAAU6B,UAAYvK,KAAK8J,UAAYQ,GAG/DZ,EAAAxJ,UAAAsK,aAAA,WAA0B,OAAOxK,KAAK4J,MAAQlB,EAAU+B,YAExDf,EAAAxJ,UAAAwK,UAAA,WAAuB,OAAO1K,KAAK4J,MAAQlB,EAAUiC,SAErDjB,EAAAxJ,UAAA0K,aAAA,WAA0B,OAAO5K,KAAK4J,MAAQlB,EAAUiC,SAA4B,OAAjB3K,KAAK8J,UAExEJ,EAAAxJ,UAAA2K,cAAA,WAA2B,OAAO7K,KAAK4J,MAAQlB,EAAUiC,SAA4B,QAAjB3K,KAAK8J,UAEzEJ,EAAAxJ,UAAA4K,mBAAA,WACI,OAAO9K,KAAK4J,MAAQlB,EAAUiC,SAA4B,aAAjB3K,KAAK8J,UAGlDJ,EAAAxJ,UAAA6K,cAAA,WAA2B,OAAO/K,KAAK4J,MAAQlB,EAAUiC,SAA4B,QAAjB3K,KAAK8J,UAEzEJ,EAAAxJ,UAAA8K,eAAA,WAA4B,OAAOhL,KAAK4J,MAAQlB,EAAUiC,SAA4B,SAAjB3K,KAAK8J,UAE1EJ,EAAAxJ,UAAA+K,cAAA,WAA2B,OAAOjL,KAAK4J,MAAQlB,EAAUiC,SAA4B,QAAjB3K,KAAK8J,UAEzEJ,EAAAxJ,UAAAgL,QAAA,WAAqB,OAAOlL,KAAK4J,MAAQlB,EAAU7F,OAEnD6G,EAAAxJ,UAAAiL,SAAA,WAAqB,OAAOnL,KAAK4J,MAAQlB,EAAUwB,OAASlK,KAAK6J,UAAY,GAE7EH,EAAAxJ,UAAA8D,SAAA,WACI,OAAQhE,KAAK4J,MACT,KAAKlB,EAAUsB,UACf,KAAKtB,EAAU+B,WACf,KAAK/B,EAAUiC,QACf,KAAKjC,EAAU6B,SACf,KAAK7B,EAAU0B,OACf,KAAK1B,EAAU7F,MACX,OAAO7C,KAAK8J,SAChB,KAAKpB,EAAUwB,OACX,OAAOlK,KAAK6J,SAAS7F,WACzB,QACI,OAAO,OAGvB0F,EAtDA,GAwDA,SAAS0B,EAAkBzB,EAAelB,GACtC,OAAO,IAAIiB,EAAMC,EAAOjB,EAAUsB,UAAWvB,EAAM2B,OAAOiB,aAAa5C,IAW3E,SAAS6C,EAAiB3B,EAAelH,GACrC,OAAO,IAAIiH,EAAMC,EAAOjB,EAAU6B,SAAU,EAAG9H,GAe5C,IAAM8I,EAAa,IAAI7B,GAAO,EAAGhB,EAAUsB,UAAW,EAAG,IAEhEV,EAAA,WAKI,SAAAA,EAAmBjG,GAAArD,KAAAqD,MAAAA,EAHnBrD,KAAAwL,KAAe,EACfxL,KAAA2J,OAAiB,EAGb3J,KAAKW,OAAS0C,EAAM1C,OACpBX,KAAKyL,UA0Mb,OAvMInC,EAAApJ,UAAAuL,QAAA,WACIzL,KAAKwL,OAASxL,KAAK2J,OAAS3J,KAAKW,OF7HrB,EE6H2CX,KAAKqD,MAAMqI,WAAW1L,KAAK2J,QAGtFL,EAAApJ,UAAAuJ,UAAA,WAKI,IAJA,IAAMpG,EAAQrD,KAAKqD,MAAO1C,EAASX,KAAKW,OACpC6K,EAAOxL,KAAKwL,KAAM7B,EAAQ3J,KAAK2J,MAG5B6B,GF/HO,IE+He,CACzB,KAAM7B,GAAShJ,EAAQ,CACnB6K,EFvII,EEwIJ,MAEAA,EAAOnI,EAAMqI,WAAW/B,GAOhC,GAHA3J,KAAKwL,KAAOA,EACZxL,KAAK2J,MAAQA,EAETA,GAAShJ,EACT,OAAO,KAIX,GAAIgL,EAAkBH,GAAO,OAAOxL,KAAK4L,iBACzC,GAAIC,EAAcL,GAAO,OAAOxL,KAAK8L,WAAWnC,GAEhD,IFvFqBlB,EEuFfhF,EAAgBkG,EACtB,OAAQ6B,GACJ,KFvIW,GEyIP,OADAxL,KAAKyL,UACEI,EAAc7L,KAAKwL,MAAQxL,KAAK8L,WAAWrI,GAC9C2H,EAAkB3H,EF1If,IE2IX,KFjJW,GEkJX,KFjJW,GEkJX,KF1GW,IE2GX,KFzGW,IE0GX,KF7Ha,GE8Hb,KF5Ha,GE6Hb,KFnJU,GEoJV,KFhJU,GEiJV,KFhJc,GEiJV,OAAOzD,KAAK+L,cAActI,EAAO+H,GACrC,KF5JO,GE6JP,KFlKO,GEmKH,OAAOxL,KAAKgM,aAChB,KFnKS,GEoKT,KF5JS,GE6JT,KF3JU,GE4JV,KF/JS,GEgKT,KF3JU,GE4JV,KFtKY,GEuKZ,KFzIU,GE0IN,OAAOhM,KAAKiM,aAAaxI,EAAO2G,OAAOiB,aAAaG,IACxD,KFzJa,GE0JT,OAAOxL,KAAKkM,oBAAoBzI,EAAO,IFjKhC,GEiKoD,KAC/D,KF9JO,GE+JP,KF7JO,GE8JH,OAAOzD,KAAKkM,oBAAoBzI,EAAO2G,OAAOiB,aAAaG,GF/JxD,GE+J0E,KACjF,KFlLS,GEmLT,KFjKO,GEkKH,OAAOxL,KAAKkM,oBACRzI,EAAO2G,OAAOiB,aAAaG,GFnK5B,GEmK8C,IFnK9C,GEmK8D,KACrE,KFjLc,GEkLV,OAAOxL,KAAKkM,oBAAoBzI,EAAO,IFlL7B,GEkLoD,KAClE,KFvIQ,IEwIJ,OAAOzD,KAAKkM,oBAAoBzI,EAAO,IFxInC,IEwIoD,KAC5D,KFvIS,IEwIL,MFhIagF,EEgIazI,KAAKwL,OFjM3B,GAkEQ/C,GA7DN,IAoDD,KAS2BA,GE+HMzI,KAAKyL,UAC3C,OAAOzL,KAAKyJ,YAIpB,OADAzJ,KAAKyL,UACEzL,KAAKkC,MAAM,yBAAyBkI,OAAOiB,aAAaG,GAAK,IAAK,IAG7ElC,EAAApJ,UAAA6L,cAAA,SAActI,EAAegF,GAEzB,OADAzI,KAAKyL,UACEL,EAAkB3H,EAAOgF,IAIpCa,EAAApJ,UAAA+L,aAAA,SAAaxI,EAAe0I,GAExB,OADAnM,KAAKyL,UACEH,EAAiB7H,EAAO0I,IAcnC7C,EAAApJ,UAAAgM,oBAAA,SACIzI,EAAe2I,EAAaC,EAAiBC,EAAaC,EAC1DC,GACAxM,KAAKyL,UACL,IAAIU,EAAcC,EASlB,OARIpM,KAAKwL,MAAQa,IACbrM,KAAKyL,UACLU,GAAOG,GAEM,MAAbC,GAAqBvM,KAAKwL,MAAQe,IAClCvM,KAAKyL,UACLU,GAAOK,GAEJlB,EAAiB7H,EAAO0I,IAGnC7C,EAAApJ,UAAA0L,eAAA,WACI,IAAMnI,EAAgBzD,KAAK2J,MAE3B,IADA3J,KAAKyL,UACEgB,EAAiBzM,KAAKwL,OAAOxL,KAAKyL,UACzC,IAxJgChJ,EAwJ1B0J,EAAcnM,KAAKqD,MAAMqJ,UAAUjJ,EAAOzD,KAAK2J,OACrD,OAAOT,EAASyD,QAAQR,IAAQ,GAzJA1J,EAyJ2B0J,EAxJxD,IAAIzC,EAwJ6CjG,EAxJhCiF,EAAUiC,QAAS,EAAGlI,IALlD,SAA4BkH,EAAelH,GACvC,OAAO,IAAIiH,EAAMC,EAAOjB,EAAU+B,WAAY,EAAGhI,GA6JzCmK,CAAmBnJ,EAAO0I,IAGlC7C,EAAApJ,UAAA4L,WAAA,SAAWrI,GACP,IAiGiBgF,EAjGboE,EAAmB7M,KAAK2J,QAAUlG,EAEtC,IADAzD,KAAKyL,YACQ,CACT,GAAII,EAAc7L,KAAKwL,YAEhB,GF3OI,IE2OAxL,KAAKwL,KACZqB,GAAS,MACN,CAAA,GFpND,ME8SOpE,EA1FczI,KAAKwL,OFhO1B,IE2Ta/C,EArFf,MAHA,GAFAzI,KAAKyL,UACDqB,EAAe9M,KAAKwL,OAAOxL,KAAKyL,WAC/BI,EAAc7L,KAAKwL,MAAO,OAAOxL,KAAKkC,MAAM,oBAAqB,GACtE2K,GAAS,EAIb7M,KAAKyL,UAET,IAnK+BlK,EAmKzB4K,EAAcnM,KAAKqD,MAAMqJ,UAAUjJ,EAAOzD,KAAK2J,OAC/C1H,EAAgB4K,EAAStK,EAAcC,kBAAkB2J,GAAOpJ,WAAWoJ,GACjF,OArK+B5K,EAqKFU,EApK1B,IAAIyH,EAoKejG,EApKFiF,EAAUwB,OAAQ3I,EAAG,KAuK7C+H,EAAApJ,UAAA8L,WAAA,WACI,IAAMvI,EAAgBzD,KAAK2J,MACrBoD,EAAgB/M,KAAKwL,KAC3BxL,KAAKyL,UAML,IAJA,IAAIuB,EAAiB,GACjBC,EAAiBjN,KAAK2J,MACpBtG,EAAgBrD,KAAKqD,MAEpBrD,KAAKwL,MAAQuB,GAChB,GFnPc,IEmPV/M,KAAKwL,KAA0B,CAC/BwB,GAAU3J,EAAMqJ,UAAUO,EAAQjN,KAAK2J,OACvC3J,KAAKyL,UACL,IAAIyB,OAAa,EAGjB,GADAlN,KAAKwL,KAAOxL,KAAKwL,KF7Of,KE8OExL,KAAKwL,KAAkB,CAEvB,IAAM2B,EAAc9J,EAAMqJ,UAAU1M,KAAK2J,MAAQ,EAAG3J,KAAK2J,MAAQ,GACjE,IAAI,eAAeyD,KAAKD,GAGpB,OAAOnN,KAAKkC,MAAM,8BAA8BiL,EAAG,IAAK,GAFxDD,EAAgBvK,SAASwK,EAAK,IAIlC,IAAK,IAAInM,EAAY,EAAGA,EAAI,EAAGA,IAC3BhB,KAAKyL,eAGTyB,EAAgBG,EAASrN,KAAKwL,MAC9BxL,KAAKyL,UAETuB,GAAU5C,OAAOiB,aAAa6B,GAC9BD,EAASjN,KAAK2J,UACX,CAAA,GFjTC,GEiTG3J,KAAKwL,KACZ,OAAOxL,KAAKkC,MAAM,qBAAsB,GAExClC,KAAKyL,UAIb,IApN+BhJ,EAoNzB6K,EAAejK,EAAMqJ,UAAUO,EAAQjN,KAAK2J,OAGlD,OAFA3J,KAAKyL,UArN0BhJ,EAuNFuK,EAASM,EAtNnC,IAAI5D,EAsNejG,EAtNFiF,EAAU0B,OAAQ,EAAG3H,IAyN7C6G,EAAApJ,UAAAgC,MAAA,SAAMkB,EAAiBmK,GACnB,IAAMC,EAAmBxN,KAAK2J,MAAQ4D,EACtC,OApNR,SAAuB5D,EAAevG,GAClC,OAAO,IAAIsG,EAAMC,EAAOjB,EAAU7F,MAAO,EAAGO,GAmNjCqK,CACHD,EAAU,gBAAgBpK,EAAO,cAAcoK,EAAQ,mBAAmBxN,KAAKqD,MAAK,MAEhGiG,EAjNA,GAmNA,SAASqC,EAAkBlD,GACvB,OF1Rc,IE0RMA,GAAQA,GFjRd,KArBA,IEsSgDA,GAAQA,GFlSxD,IAMA,IE6RTA,GF7TS,IE6TaA,EAe/B,SAASgE,EAAiBhE,GACtB,OF7QJ,SAA8BA,GAC1B,OAAOA,GA/BO,IA+BOA,GAtBP,KAsBqBA,GA3CrB,IA2CmCA,GAvCnC,GEmTPiF,CAAoBjF,IAASoD,EAAcpD,IF7SpC,IE6S8CA,GF7U9C,IE8UTA,EAOT,SAASqE,EAAerE,GACpB,OF7UkB,IE6UXA,GF/UU,IE+UcA,EAOnC,SAAS4E,EAAS5E,GACd,OAAQA,GACJ,KF1TU,IE2TN,OFxWO,GEyWX,KF7TU,IE8TN,OFxWO,GEyWX,KF7TU,IE8TN,OFzWO,GE0WX,KF9TU,IE+TN,OF/WQ,EEgXZ,KF9TU,IE+TN,OF/WS,GEgXb,QACI,OAAOA;;;;;;;OE5WnB,IAAAkF,EACI,SAAmB/G,EAA0BhC,EAA8BgJ,GAAxD5N,KAAA4G,QAAAA,EAA0B5G,KAAA4E,YAAAA,EAA8B5E,KAAA4N,QAAAA,GAG/EC,EACI,SACWC,EAA4CC,EAC5ChG,GADA/H,KAAA8N,iBAAAA,EAA4C9N,KAAA+N,SAAAA,EAC5C/N,KAAA+H,OAAAA,GAGf,SAASiG,EAAyBC,GAC9B,IAAMC,EAAUlL,EAAaiL,EAAOxK,OAAS,eAAiBT,EAAaiL,EAAOvK,KAClF,OAAO,IAAIyK,OAAOD,EAAS,KAG/B,IAAAE,GAAA,WAGI,SAAAA,EAAoBC,GAAArO,KAAAqO,OAAAA,EAFZrO,KAAA+H,OAAwB,GAoMpC,OAhMIqG,EAAAlO,UAAAoO,YAAA,SACIjL,EAAegB,EACfkK,QAAA,IAAAA,IAAAA,EAAA5F,GACA3I,KAAKwO,sBAAsBnL,EAAOgB,EAAUkK,GAC5C,IAAME,EAAczO,KAAK0O,eAAerL,GAClCkG,EAASvJ,KAAKqO,OAAOjF,SAASpJ,KAAK0O,eAAerL,IAClDwE,EAAM,IAAI8G,GACZtL,EAAOgB,EAAUkF,EAAQkF,EAAY9N,QAAQ,EAAMX,KAAK+H,OACxD1E,EAAM1C,OAAS8N,EAAY9N,QAC1BiO,aACL,OAAO,IAAIhH,EAAcC,EAAKxE,EAAOgB,EAAUrE,KAAK+H,SAGxDqG,EAAAlO,UAAA2O,aAAA,SACIxL,EAAegB,EACfkK,QAAA,IAAAA,IAAAA,EAAA5F,GACA,IAAMd,EAAM7H,KAAK8O,iBAAiBzL,EAAOgB,EAAUkK,GACnD,OAAO,IAAI3G,EAAcC,EAAKxE,EAAOgB,EAAUrE,KAAK+H,SAGxDqG,EAAAlO,UAAA6O,mBAAA,SACI1L,EAAegB,EACfkK,QAAA,IAAAA,IAAAA,EAAA5F,GACA,IAAMd,EAAM7H,KAAK8O,iBAAiBzL,EAAOgB,EAAUkK,GAC7CxG,EAASiH,GAAwBC,MAAMpH,GAK7C,OAJIE,EAAOpH,OAAS,GAChBX,KAAKkP,aACD,0CAA0CnH,EAAOoH,KAAK,KAAQ9L,EAAOgB,GAEtE,IAAIuD,EAAcC,EAAKxE,EAAOgB,EAAUrE,KAAK+H,SAGhDqG,EAAAlO,UAAAgP,aAAR,SAAqB9L,EAAiBC,EAAeC,EAAqBC,GACtEvD,KAAK+H,OAAO/F,KAAK,IAAImB,EAAYC,EAASC,EAAOC,EAAaC,KAG1D6K,EAAAlO,UAAA4O,iBAAR,SACIzL,EAAegB,EAAkBkK,GAGjC,IAAMxB,EAAQ/M,KAAKoP,YAAY/L,EAAOgB,GAEtC,GAAIlC,EAAU4K,GACV,OAAOA,EAGX/M,KAAKwO,sBAAsBnL,EAAOgB,EAAUkK,GAC5C,IAAME,EAAczO,KAAK0O,eAAerL,GAClCkG,EAASvJ,KAAKqO,OAAOjF,SAASqF,GACpC,OAAO,IAAIE,GACPtL,EAAOgB,EAAUkF,EAAQkF,EAAY9N,QAAQ,EAAOX,KAAK+H,OACzD1E,EAAM1C,OAAS8N,EAAY9N,QAC1BiO,cAGDR,EAAAlO,UAAAkP,YAAR,SAAoB/L,EAAegB,GAC/B,GAAIhC,EAAQgB,GAAQ,OAAO,KAC3B,IAAMgM,EAAuBhM,EAAMsJ,QAAQ,KAC3C,IAA6B,GAAzB0C,EAA4B,OAAO,KACvC,IAAMlL,EAASd,EAAMqJ,UAAU,EAAG2C,GAAsBC,OACxD,IFkPR,SAA6BjM,GACzB,GAAoB,GAAhBA,EAAM1C,OAAa,OAAO,EAC9B,IAAM0I,EAAU,IAAIC,EAASjG,GAC7B,IAAKsI,EAAkBtC,EAAQmC,MAAO,OAAO,EAE7C,IADAnC,EAAQoC,UF9UQ,IE+UTpC,EAAQmC,MAAqB,CAChC,IAAKiB,EAAiBpD,EAAQmC,MAAO,OAAO,EAC5CnC,EAAQoC,UAEZ,OAAO,EE3PEjB,CAAarG,GAAS,OAAO,KAClC,IAAMC,EAA0Bf,EAAMqJ,UAAU2C,EAAuB,GACvE,OAAO,IAAIpL,EAAM,IAAIT,EAAU,EAAGH,EAAM1C,QAASwD,EAAQC,EAAyBC,IAGtF+J,EAAAlO,UAAAqP,sBAAA,SAAsBC,EAAqBnM,EAAegB,GAEtD,IAAMkF,EAASvJ,KAAKqO,OAAOjF,SAAS/F,GACpC,GAAImM,EAAa,CAEb,IAAMC,EAAezP,KAAKqO,OAAOjF,SAASoG,GAAaE,KAAI,SAAAC,GAEvD,OADAA,EAAEhG,MAAQ,EACHgG,KAEXpG,EAAOqG,QAAOC,MAAdtG,EP4BL,WACH,IAAK,IAAI1H,EAAK,GAAIb,EAAI,EAAGA,EAAIN,UAAUC,OAAQK,IAC3Ca,EAAKA,EAAGiO,OAAOzO,EAAOX,UAAUM,KACpC,OAAOa,EO/BOkO,CAAYN,IAEtB,OAAO,IAAId,GAAUtL,EAAOgB,EAAUkF,EAAQlG,EAAM1C,QAAQ,EAAOX,KAAK+H,OAAQ,GAC3EwH,yBAGTnB,EAAAlO,UAAA8P,mBAAA,SACI3M,EAAegB,EACfkK,QAAA,IAAAA,IAAAA,EAAA5F,GACA,IAAMsH,EAAQjQ,KAAKkQ,mBAAmB7M,EAAOgB,EAAUkK,GACvD,GAAa,MAAT0B,EAAe,OAAO,KAI1B,IAFA,IAAMrL,EAAqB,GAElB5D,EAAI,EAAGA,EAAIiP,EAAMrL,YAAYjE,SAAUK,EAAG,CAC/C,IAAMmP,EAAiBF,EAAMrL,YAAY5D,GACnCyN,EAAczO,KAAK0O,eAAeyB,GAClC5G,EAASvJ,KAAKqO,OAAOjF,SAASpJ,KAAK0O,eAAeuB,EAAMrL,YAAY5D,KACpE6G,EAAM,IAAI8G,GACZtL,EAAOgB,EAAUkF,EAAQkF,EAAY9N,QAAQ,EAAOX,KAAK+H,OACzDkI,EAAMrC,QAAQ5M,IAAMmP,EAAexP,OAAS8N,EAAY9N,SACvDiO,aACLhK,EAAY5C,KAAK6F,GAGrB,OAAO,IAAID,EACP,IAAIjB,EACA,IAAInD,EAAU,EAAGnB,EAAQgB,GAAS,EAAIA,EAAM1C,QAASsP,EAAMrJ,QAAShC,GACxEvB,EAAOgB,EAAUrE,KAAK+H,SAG9BqG,EAAAlO,UAAAgQ,mBAAA,SACI7M,EAAegB,EACfkK,QAAA,IAAAA,IAAAA,EAAA5F,GACA,IAAMyH,EAASpC,EAAyBO,GAClC8B,EAAQhN,EAAM4M,MAAMG,GAC1B,GAAIC,EAAM1P,QAAU,EAChB,OAAO,KAMX,IAJA,IAAMiG,EAAoB,GACpBhC,EAAwB,GACxBgJ,EAAoB,GACtBL,EAAS,EACJvM,EAAI,EAAGA,EAAIqP,EAAM1P,OAAQK,IAAK,CACnC,IAAMsP,EAAeD,EAAMrP,GACvBA,EAAI,GAAM,GAEV4F,EAAQ5E,KAAKsO,GACb/C,GAAU+C,EAAK3P,QACR2P,EAAKhB,OAAO3O,OAAS,GAC5B4M,GAAUgB,EAAoB9K,MAAM9C,OACpCiE,EAAY5C,KAAKsO,GACjB1C,EAAQ5L,KAAKuL,GACbA,GAAU+C,EAAK3P,OAAS4N,EAAoB7K,IAAI/C,SAEhDX,KAAKkP,aACD,4DAA6D7L,EAC7D,aAAarD,KAAKuQ,8BAA8BF,EAAOrP,EAAGuN,GAAoB,MAC9ElK,GACJO,EAAY5C,KAAK,YACjB4L,EAAQ5L,KAAKuL,IAGrB,OAAO,IAAII,EAAmB/G,EAAShC,EAAagJ,IAGxDQ,EAAAlO,UAAAsQ,qBAAA,SAAqBnN,EAAegB,GAChC,OAAO,IAAIuD,EACP,IAAIzB,EAAiB,IAAI3C,EAAU,EAAGnB,EAAQgB,GAAS,EAAIA,EAAM1C,QAAS0C,GAAQA,EAClFgB,EAAUrE,KAAK+H,SAGfqG,EAAAlO,UAAAwO,eAAR,SAAuBrL,GACnB,IAAMrC,EAAIhB,KAAKyQ,cAAcpN,GAC7B,OAAOlB,EAAUnB,GAAKqC,EAAMqJ,UAAU,EAAG1L,GAAGsO,OAASjM,GAGjD+K,EAAAlO,UAAAuQ,cAAR,SAAsBpN,GAElB,IADA,IF+KgBoF,EE/KZiI,EAAqB,KAChB1P,EAAI,EAAGA,EAAIqC,EAAM1C,OAAS,EAAGK,IAAK,CACvC,IAAM2P,EAAOtN,EAAMqI,WAAW1K,GACxB4P,EAAWvN,EAAMqI,WAAW1K,EAAI,GAEtC,GJpKU,KIoKN2P,GJpKM,IIoKmBC,GAA4BvO,EAAQqO,GAAa,OAAO1P,EAEjF0P,IAAeC,EACfD,EAAa,KACNrO,EAAQqO,KJhLZ,MEsVKjI,EEtK8BkI,IJrLnC,KE4VclI,GFpSd,KEoSoCA,KEtKvCiI,EAAaC,GAGrB,OAAO,MAGHvC,EAAAlO,UAAAsO,sBAAR,SACInL,EAAegB,EAAekK,GAC9B,IAAM6B,EAASpC,EAAyBO,GAClC8B,EAAQhN,EAAM4M,MAAMG,GACtBC,EAAM1P,OAAS,GACfX,KAAKkP,aACD,sBAAsBX,EAAoB9K,MAAQ8K,EAAoB7K,IAAG,kCACzEL,EACA,aAAarD,KAAKuQ,8BAA8BF,EAAO,EAAG9B,GAAoB,MAC9ElK,IAIJ+J,EAAAlO,UAAAqQ,8BAAR,SACIF,EAAiBQ,EAAsBtC,GAEvC,IADA,IAAIjL,EAAc,GACTwN,EAAI,EAAGA,EAAID,EAAcC,IAC9BxN,GAAewN,EAAI,GAAM,EACrBT,EAAMS,GACN,GAAGvC,EAAoB9K,MAAQ4M,EAAMS,GAAKvC,EAAoB7K,IAGtE,OAAOJ,EAAY3C,QAE3ByN,EArMA,GAuMAO,GAAA,WAOI,SAAAA,EACWtL,EAAsBgB,EAAsBkF,EAC5CwH,EAA4BzC,EAA8BvG,EACzDwF,GAFDvN,KAAAqD,MAAAA,EAAsBrD,KAAAqE,SAAAA,EAAsBrE,KAAAuJ,OAAAA,EAC5CvJ,KAAA+Q,YAAAA,EAA4B/Q,KAAAsO,YAAAA,EAA8BtO,KAAA+H,OAAAA,EACzD/H,KAAAuN,OAAAA,EATJvN,KAAAgR,gBAAkB,EAClBhR,KAAAiR,kBAAoB,EACpBjR,KAAAkR,gBAAkB,EAE1BlR,KAAA2J,MAAgB,EA6gBpB,OAtgBIgF,EAAAzO,UAAAsL,KAAA,SAAK+B,GACD,IAAMvM,EAAIhB,KAAK2J,MAAQ4D,EACvB,OAAOvM,EAAIhB,KAAKuJ,OAAO5I,OAASX,KAAKuJ,OAAOvI,GAAKuK,GAGrD/L,OAAAyB,eAAI0N,EAAAzO,UAAA,OAAI,KAAR,WAAoB,OAAOF,KAAKwL,KAAK,oCAErChM,OAAAyB,eAAI0N,EAAAzO,UAAA,aAAU,KAAd,WACI,OAAQF,KAAK2J,MAAQ3J,KAAKuJ,OAAO5I,OAAUX,KAAK8B,KAAK6H,MAAQ3J,KAAKuN,OAC9DvN,KAAK+Q,YAAc/Q,KAAKuN,wCAGhCoB,EAAAzO,UAAA0D,KAAA,SAAKH,GAAiB,OAAO,IAAID,EAAUC,EAAOzD,KAAKmR,aAEvDxC,EAAAzO,UAAAuL,QAAA,WAAYzL,KAAK2J,SAEjBgF,EAAAzO,UAAAkR,kBAAA,SAAkB3I,GACd,QAAIzI,KAAK8B,KAAKiI,YAAYtB,KACtBzI,KAAKyL,WACE,IAMfkD,EAAAzO,UAAAmR,eAAA,WAA4B,OAAOrR,KAAK8B,KAAK8I,gBAE7C+D,EAAAzO,UAAAoR,gBAAA,SAAgB7I,GACRzI,KAAKoR,kBAAkB3I,IAC3BzI,KAAKkC,MAAM,oBAAoBkI,OAAOiB,aAAa5C,KAGvDkG,EAAAzO,UAAAqR,iBAAA,SAAiBC,GACb,QAAIxR,KAAK8B,KAAKuI,WAAWmH,KACrBxR,KAAKyL,WACE,IAMfkD,EAAAzO,UAAAuR,eAAA,SAAeC,GACP1R,KAAKuR,iBAAiBG,IAC1B1R,KAAKkC,MAAM,6BAA6BwP,IAG5C/C,EAAAzO,UAAAyR,0BAAA,WACI,IAAMpQ,EAAIvB,KAAK8B,KACf,OAAKP,EAAEiJ,gBAAmBjJ,EAAEmJ,aAI5B1K,KAAKyL,UACElK,EAAEyC,aAJLhE,KAAKkC,MAAM,oBAAoBX,EAAC,oCACzB,KAMfoN,EAAAzO,UAAA0R,kCAAA,WACI,IAAMrQ,EAAIvB,KAAK8B,KACf,OAAKP,EAAEiJ,gBAAmBjJ,EAAEmJ,aAAgBnJ,EAAE4I,YAI9CnK,KAAKyL,UACElK,EAAEyC,aAJLhE,KAAKkC,MAAM,oBAAoBX,EAAC,6CACzB,KAMfoN,EAAAzO,UAAA0O,WAAA,WAGI,IAFA,IAAMiD,EAAe,GACfpO,EAAQzD,KAAKmR,WACZnR,KAAK2J,MAAQ3J,KAAKuJ,OAAO5I,QAAQ,CACpC,IAAMmR,EAAO9R,KAAK+R,YAGlB,GAFAF,EAAM7P,KAAK8P,GAEP9R,KAAKoR,kBJ5RK,IIgSV,IAHKpR,KAAKsO,aACNtO,KAAKkC,MAAM,wDAERlC,KAAKoR,kBJhSF,WIkSHpR,KAAK2J,MAAQ3J,KAAKuJ,OAAO5I,QAChCX,KAAKkC,MAAM,qBAAqBlC,KAAK8B,KAAI,KAGjD,OAAoB,GAAhB+P,EAAMlR,OAAoB,IAAI6D,EAAUxE,KAAK4D,KAAKH,IAClC,GAAhBoO,EAAMlR,OAAoBkR,EAAM,GAC7B,IAAIlN,EAAM3E,KAAK4D,KAAKH,GAAQoO,IAGvClD,EAAAzO,UAAA6R,UAAA,WACI,IAAIrP,EAAS1C,KAAKgS,kBAClB,GAAIhS,KAAKuR,iBAAiB,KAAM,CACxBvR,KAAKsO,aACLtO,KAAKkC,MAAM,8CAGf,EAAG,CAGC,IAFA,IAAM+P,EAAOjS,KAAK2R,4BACZ1L,EAAc,GACbjG,KAAKoR,kBJtTN,KIuTFnL,EAAKjE,KAAKhC,KAAKgS,mBAEnBtP,EAAS,IAAIqD,EAAY/F,KAAK4D,KAAKlB,EAAOkB,KAAKH,OAAQf,EAAQuP,EAAMhM,SAChEjG,KAAKuR,iBAAiB,MAGnC,OAAO7O,GAGXiM,EAAAzO,UAAA8R,gBAAA,WAAyB,OAAOhS,KAAKkS,oBAErCvD,EAAAzO,UAAAgS,iBAAA,WACI,IAAMzO,EAAQzD,KAAKmR,WACbzO,EAAS1C,KAAKmS,iBAEpB,GAAInS,KAAKuR,iBAAiB,KAAM,CAC5B,IAAMa,EAAMpS,KAAK+R,YACbM,OAAE,EACN,GAAKrS,KAAKoR,kBJzUA,II+UNiB,EAAKrS,KAAK+R,gBAN6B,CACvC,IAAMrO,EAAM1D,KAAKmR,WACX/J,EAAapH,KAAKqD,MAAMqJ,UAAUjJ,EAAOC,GAC/C1D,KAAKkC,MAAM,0BAA0BkF,EAAU,+BAC/CiL,EAAK,IAAI7N,EAAUxE,KAAK4D,KAAKH,IAIjC,OAAO,IAAIqB,EAAY9E,KAAK4D,KAAKH,GAAQf,EAAQ0P,EAAKC,GAEtD,OAAO3P,GAIfiM,EAAAzO,UAAAiS,eAAA,WAGI,IADA,IAAIzP,EAAS1C,KAAKsS,kBACXtS,KAAKuR,iBAAiB,OAAO,CAChC,IAAMtK,EAAQjH,KAAKsS,kBACnB5P,EAAS,IAAIoE,EAAO9G,KAAK4D,KAAKlB,EAAOkB,KAAKH,OAAQ,KAAMf,EAAQuE,GAEpE,OAAOvE,GAGXiM,EAAAzO,UAAAoS,gBAAA,WAGI,IADA,IAAI5P,EAAS1C,KAAKuS,gBACXvS,KAAKuR,iBAAiB,OAAO,CAChC,IAAMtK,EAAQjH,KAAKuS,gBACnB7P,EAAS,IAAIoE,EAAO9G,KAAK4D,KAAKlB,EAAOkB,KAAKH,OAAQ,KAAMf,EAAQuE,GAEpE,OAAOvE,GAGXiM,EAAAzO,UAAAqS,cAAA,WAGI,IADA,IAAI7P,EAAS1C,KAAKwS,kBACXxS,KAAK8B,KAAK8H,MAAQlB,EAAU6B,UAAU,CACzC,IAAMmH,EAAW1R,KAAK8B,KAAKgI,SAC3B,OAAQ4H,GACJ,IAAK,KACL,IAAK,MACL,IAAK,KACL,IAAK,MACD1R,KAAKyL,UACL,IAAMxE,EAAQjH,KAAKwS,kBACnB9P,EAAS,IAAIoE,EAAO9G,KAAK4D,KAAKlB,EAAOkB,KAAKH,OAAQiO,EAAUhP,EAAQuE,GACpE,SAER,MAEJ,OAAOvE,GAGXiM,EAAAzO,UAAAsS,gBAAA,WAGI,IADA,IAAI9P,EAAS1C,KAAKyS,gBACXzS,KAAK8B,KAAK8H,MAAQlB,EAAU6B,UAAU,CACzC,IAAMmH,EAAW1R,KAAK8B,KAAKgI,SAC3B,OAAQ4H,GACJ,IAAK,IACL,IAAK,IACL,IAAK,KACL,IAAK,KACD1R,KAAKyL,UACL,IAAMxE,EAAQjH,KAAKyS,gBACnB/P,EAAS,IAAIoE,EAAO9G,KAAK4D,KAAKlB,EAAOkB,KAAKH,OAAQiO,EAAUhP,EAAQuE,GACpE,SAER,MAEJ,OAAOvE,GAGXiM,EAAAzO,UAAAuS,cAAA,WAGI,IADA,IAAI/P,EAAS1C,KAAK0S,sBACX1S,KAAK8B,KAAK8H,MAAQlB,EAAU6B,UAAU,CACzC,IAAMmH,EAAW1R,KAAK8B,KAAKgI,SAC3B,OAAQ4H,GACJ,IAAK,IACL,IAAK,IACD1R,KAAKyL,UACL,IAAIxE,EAAQjH,KAAK0S,sBACjBhQ,EAAS,IAAIoE,EAAO9G,KAAK4D,KAAKlB,EAAOkB,KAAKH,OAAQiO,EAAUhP,EAAQuE,GACpE,SAER,MAEJ,OAAOvE,GAGXiM,EAAAzO,UAAAwS,oBAAA,WAGI,IADA,IAAIhQ,EAAS1C,KAAK2S,cACX3S,KAAK8B,KAAK8H,MAAQlB,EAAU6B,UAAU,CACzC,IAAMmH,EAAW1R,KAAK8B,KAAKgI,SAC3B,OAAQ4H,GACJ,IAAK,IACL,IAAK,IACL,IAAK,IACD1R,KAAKyL,UACL,IAAIxE,EAAQjH,KAAK2S,cACjBjQ,EAAS,IAAIoE,EAAO9G,KAAK4D,KAAKlB,EAAOkB,KAAKH,OAAQiO,EAAUhP,EAAQuE,GACpE,SAER,MAEJ,OAAOvE,GAGXiM,EAAAzO,UAAAyS,YAAA,WACI,GAAI3S,KAAK8B,KAAK8H,MAAQlB,EAAU6B,SAAU,CACtC,IAAM9G,EAAQzD,KAAKmR,WACbO,EAAW1R,KAAK8B,KAAKgI,SACvBpH,OAAM,EACV,OAAQgP,GACJ,IAAK,IAED,OADA1R,KAAKyL,UACEzL,KAAK2S,cAChB,IAAK,IAGD,OAFA3S,KAAKyL,UACL/I,EAAS1C,KAAK2S,cACP,IAAI7L,EACP9G,KAAK4D,KAAKH,GAAQiO,EAAU,IAAIvL,EAAiB,IAAI3C,EAAUC,EAAOA,GAAQ,GAC9Ef,GACR,IAAK,IAGD,OAFA1C,KAAKyL,UACL/I,EAAS1C,KAAK2S,cACP,IAAIxL,EAAUnH,KAAK4D,KAAKH,GAAQf,IAGnD,OAAO1C,KAAK4S,kBAGhBjE,EAAAzO,UAAA0S,eAAA,WAEI,IADA,IAAIlQ,EAAS1C,KAAK6S,iBAEd,GAAI7S,KAAKoR,kBJrdE,IIsdP1O,EAAS1C,KAAK8S,8BAA8BpQ,GAAQ,QAEjD,GAAI1C,KAAKuR,iBAAiB,MAC7B7O,EAAS1C,KAAK8S,8BAA8BpQ,GAAQ,QAEjD,GAAI1C,KAAKoR,kBJzcH,IIycuC,CAChDpR,KAAKiR,oBACL,IAAM1Q,EAAMP,KAAK+R,YAGjB,GAFA/R,KAAKiR,oBACLjR,KAAKsR,gBJ3cI,II4cLtR,KAAKuR,iBAAiB,KAAM,CAC5B,IAAMtP,EAAQjC,KAAKkS,mBACnBxP,EAAS,IAAImD,EAAW7F,KAAK4D,KAAKlB,EAAOkB,KAAKH,OAAQf,EAAQnC,EAAK0B,QAEnES,EAAS,IAAIiD,EAAU3F,KAAK4D,KAAKlB,EAAOkB,KAAKH,OAAQf,EAAQnC,OAG9D,CAAA,IAAIP,KAAKoR,kBJ7eL,IIqfP,OAAO1O,EAPP1C,KAAKgR,kBACL,IAAM/K,EAAOjG,KAAK+S,qBAClB/S,KAAKgR,kBACLhR,KAAKsR,gBJhfE,IIifP5O,EAAS,IAAIgF,EAAa1H,KAAK4D,KAAKlB,EAAOkB,KAAKH,OAAQf,EAAQuD,KAQ5E0I,EAAAzO,UAAA2S,aAAA,WACI,IAAMpP,EAAQzD,KAAKmR,WACnB,GAAInR,KAAKoR,kBJ5fM,II4f4B,CACvCpR,KAAKgR,kBACL,IAAMtO,EAAS1C,KAAK+R,YAGpB,OAFA/R,KAAKgR,kBACLhR,KAAKsR,gBJ/fM,IIggBJ5O,EAEJ,GAAI1C,KAAK8B,KAAK+I,gBAEjB,OADA7K,KAAKyL,UACE,IAAItF,EAAiBnG,KAAK4D,KAAKH,GAAQ,MAE3C,GAAIzD,KAAK8B,KAAKgJ,qBAEjB,OADA9K,KAAKyL,UACE,IAAItF,EAAiBnG,KAAK4D,KAAKH,QAAQ,GAE3C,GAAIzD,KAAK8B,KAAKiJ,gBAEjB,OADA/K,KAAKyL,UACE,IAAItF,EAAiBnG,KAAK4D,KAAKH,IAAQ,GAE3C,GAAIzD,KAAK8B,KAAKkJ,iBAEjB,OADAhL,KAAKyL,UACE,IAAItF,EAAiBnG,KAAK4D,KAAKH,IAAQ,GAE3C,GAAIzD,KAAK8B,KAAKmJ,gBAEjB,OADAjL,KAAKyL,UACE,IAAIhH,EAAiBzE,KAAK4D,KAAKH,IAEnC,GAAIzD,KAAKoR,kBJ/fC,II+fmC,CAChDpR,KAAKiR,oBACL,IAAM+B,EAAWhT,KAAKiT,oBJ/fT,IIkgBb,OAFAjT,KAAKiR,oBACLjR,KAAKsR,gBJjgBQ,IIkgBN,IAAIjL,EAAarG,KAAK4D,KAAKH,GAAQuP,GAEvC,GAAIhT,KAAK8B,KAAKiI,YJrfN,KIsfX,OAAO/J,KAAKkT,kBAET,GAAIlT,KAAK8B,KAAK0I,eACjB,OAAOxK,KAAK8S,8BAA8B,IAAIrO,EAAiBzE,KAAK4D,KAAKH,KAAS,GAE/E,GAAIzD,KAAK8B,KAAKmI,WAAY,CAC7B,IAAMhI,EAAQjC,KAAK8B,KAAKqJ,WAExB,OADAnL,KAAKyL,UACE,IAAItF,EAAiBnG,KAAK4D,KAAKH,GAAQxB,GAE3C,GAAIjC,KAAK8B,KAAKqI,WAAY,CAC7B,IAAMgJ,EAAenT,KAAK8B,KAAKkC,WAE/B,OADAhE,KAAKyL,UACE,IAAItF,EAAiBnG,KAAK4D,KAAKH,GAAQ0P,GAE3C,OAAInT,KAAK2J,OAAS3J,KAAKuJ,OAAO5I,QACjCX,KAAKkC,MAAM,iCAAiClC,KAAKqD,OAC1C,IAAImB,EAAUxE,KAAK4D,KAAKH,MAE/BzD,KAAKkC,MAAM,oBAAoBlC,KAAK8B,MAC7B,IAAI0C,EAAUxE,KAAK4D,KAAKH,MAIvCkL,EAAAzO,UAAA+S,oBAAA,SAAoBG,GAChB,IAAM1Q,EAAgB,GACtB,IAAK1C,KAAK8B,KAAKiI,YAAYqJ,GACvB,GACI1Q,EAAOV,KAAKhC,KAAK+R,mBACZ/R,KAAKoR,kBJxjBJ,KI0jBd,OAAO1O,GAGXiM,EAAAzO,UAAAgT,gBAAA,WACI,IAAM1M,EAAiB,GACjBC,EAAgB,GAChBhD,EAAQzD,KAAKmR,WAEnB,GADAnR,KAAKsR,gBJ5hBU,MI6hBVtR,KAAKoR,kBJ3hBK,KI2hB6B,CACxCpR,KAAKkR,kBACL,EAAG,CACC,IAAM3Q,EAAMP,KAAK4R,oCACjBpL,EAAKxE,KAAKzB,GACVP,KAAKsR,gBJnkBC,IIokBN7K,EAAOzE,KAAKhC,KAAK+R,mBACZ/R,KAAKoR,kBJzkBJ,KI0kBVpR,KAAKkR,kBACLlR,KAAKsR,gBJpiBM,KIsiBf,OAAO,IAAI/K,EAAWvG,KAAK4D,KAAKH,GAAQ+C,EAAMC,IAGlDkI,EAAAzO,UAAA4S,8BAAA,SAA8B1N,EAAeiO,QAAA,IAAAA,IAAAA,GAAA,GACzC,IAAM5P,EAAQ2B,EAASxB,KAAKH,MACtB6P,EAAKtT,KAAK2R,4BAEhB,GAAI3R,KAAKoR,kBJxlBM,IIwlB4B,CACvCpR,KAAKgR,kBACL,IAAM/K,EAAOjG,KAAK+S,qBAClB/S,KAAKsR,gBJ1lBM,II2lBXtR,KAAKgR,kBACL,IAAMpN,EAAO5D,KAAK4D,KAAKH,GACvB,OAAO4P,EAAS,IAAI7L,EAAe5D,EAAMwB,EAAUkO,EAAIrN,GACnD,IAAIqB,EAAW1D,EAAMwB,EAAUkO,EAAIrN,GAGvC,GAAIoN,EACA,OAAIrT,KAAKuR,iBAAiB,MACtBvR,KAAKkC,MAAM,sDACJ,IAAIsC,EAAUxE,KAAK4D,KAAKH,KAExB,IAAIgC,EAAiBzF,KAAK4D,KAAKH,GAAQ2B,EAAUkO,GAG5D,GAAItT,KAAKuR,iBAAiB,KAAM,CAC5B,IAAKvR,KAAKsO,YAEN,OADAtO,KAAKkC,MAAM,uCACJ,IAAIsC,EAAUxE,KAAK4D,KAAKH,IAGnC,IAAMxB,EAAQjC,KAAKkS,mBACnB,OAAO,IAAI3M,EAAcvF,KAAK4D,KAAKH,GAAQ2B,EAAUkO,EAAIrR,GAEzD,OAAO,IAAIkD,EAAanF,KAAK4D,KAAKH,GAAQ2B,EAAUkO,IAMpE3E,EAAAzO,UAAA6S,mBAAA,WACI,GAAI/S,KAAK8B,KAAKiI,YJznBC,IIynB2B,MAAO,GACjD,IAAMwJ,EAAqB,GAC3B,GACIA,EAAYvR,KAAKhC,KAAK+R,mBACjB/R,KAAKoR,kBJ1nBA,KI2nBd,OAAOmC,GAMX5E,EAAAzO,UAAAsT,yBAAA,WACI,IAAI9Q,EAAS,GACT+Q,GAAgB,EACpB,GACI/Q,GAAU1C,KAAK4R,qCACf6B,EAAgBzT,KAAKuR,iBAAiB,QAElC7O,GAAU,WAET+Q,GAET,OAAO/Q,EAAOsB,YAGlB2K,EAAAzO,UAAAqP,sBAAA,WAII,IAHA,IAAMmE,EAA8B,GAChCvP,EAAiB,KAEdnE,KAAK2J,MAAQ3J,KAAKuJ,OAAO5I,QAAQ,CACpC,IAAM8C,EAAQzD,KAAKmR,WACblJ,EAAoBjI,KAAKqR,iBAC3BpJ,GACAjI,KAAKyL,UAET,IAAIlL,EAAMP,KAAKwT,2BACVvL,IACa,MAAV9D,EACAA,EAAS5D,EAETA,EAAM4D,EAAS5D,EAAI,GAAGoT,cAAgBpT,EAAImM,UAAU,IAG5D1M,KAAKoR,kBJ7pBK,II8pBV,IAAIwC,EAAe,KACfxM,EAA4B,KAChC,GAAIa,EAEI2L,EADA5T,KAAKuR,iBAAiB,KACfvR,KAAKwT,2BAEL,iBAER,GAAIxT,KAAK8B,OAASyJ,IAAQvL,KAAKqR,iBAAkB,CACpD,IAAMwC,EAAQ7T,KAAKmR,WACbtJ,EAAM7H,KAAK+R,YACXjK,EAAS9H,KAAKqD,MAAMqJ,UAAUmH,EAAQ7T,KAAKuN,OAAQvN,KAAKmR,WAAanR,KAAKuN,QAChFnG,EAAa,IAAIQ,EAAcC,EAAKC,EAAQ9H,KAAKqE,SAAUrE,KAAK+H,QAEpE2L,EAAS1R,KAAK,IAAIgG,EAAgBhI,KAAK4D,KAAKH,GAAQlD,EAAK0H,EAAU2L,EAAMxM,IACpEpH,KAAKoR,kBJ5qBI,KI6qBVpR,KAAKoR,kBJlrBC,IIqrBd,OAAO,IAAIvD,EAA2B6F,EAnCX,GAmC+B1T,KAAK+H,SAGnE4G,EAAAzO,UAAAgC,MAAA,SAAMkB,EAAiBuG,QAAA,IAAAA,IAAAA,EAAA,MACnB3J,KAAK+H,OAAO/F,KAAK,IAAImB,EAAYC,EAASpD,KAAKqD,MAAOrD,KAAK8T,aAAanK,GAAQ3J,KAAKqE,WACrFrE,KAAK+T,QAGDpF,EAAAzO,UAAA4T,aAAR,SAAqBnK,GAEjB,YAFiB,IAAAA,IAAAA,EAAA,MACbtH,EAAQsH,KAAQA,EAAQ3J,KAAK2J,OACzBA,EAAQ3J,KAAKuJ,OAAO5I,OAAU,cAAaX,KAAKuJ,OAAOI,GAAOA,MAAQ,GAAC,MAC3E,gCAgBAgF,EAAAzO,UAAA6T,KAAR,WAEI,IADA,IAAIxS,EAAIvB,KAAK8B,KACN9B,KAAK2J,MAAQ3J,KAAKuJ,OAAO5I,SAAWY,EAAEwI,YJ7sB3B,MI8sBjB/J,KAAKgR,iBAAmB,IAAMzP,EAAEwI,YJttBlB,OIutBd/J,KAAKkR,iBAAmB,IAAM3P,EAAEwI,YJ7qBlB,QI8qBd/J,KAAKiR,mBAAqB,IAAM1P,EAAEwI,YJ/rBlB,MIgsBT/J,KAAK8B,KAAKoJ,WACVlL,KAAK+H,OAAO/F,KACR,IAAImB,EAAYnD,KAAK8B,KAAKkC,WAAYhE,KAAKqD,MAAOrD,KAAK8T,eAAgB9T,KAAKqE,WAEpFrE,KAAKyL,UACLlK,EAAIvB,KAAK8B,MAGrB6M,EAlhBA,GAohBAK,GAAA,WAAA,SAAAA,IAOIhP,KAAA+H,OAAmB,GAyCvB,OA/CWiH,EAAAC,MAAP,SAAapH,GACT,IAAM5E,EAAI,IAAI+L,EAEd,OADAnH,EAAIhE,MAAMZ,GACHA,EAAE8E,QAKbiH,EAAA9O,UAAAwE,sBAAA,SAAsBmD,EAAuB9D,KAE7CiL,EAAA9O,UAAA2G,mBAAA,SAAmBgB,EAAoB9D,KAEvCiL,EAAA9O,UAAAkG,sBAAA,SAAsByB,EAAuB9D,KAE7CiL,EAAA9O,UAAAoF,kBAAA,SAAkBuC,EAAmB9D,KAErCiL,EAAA9O,UAAAsF,mBAAA,SAAmBqC,EAAoB9D,KAEvCiL,EAAA9O,UAAAwF,sBAAA,SAAsBmC,EAAuB9D,KAE7CiL,EAAA9O,UAAAqH,gBAAA,SAAgBM,EAAiB9D,KAEjCiL,EAAA9O,UAAAuH,oBAAA,SAAoBI,EAAqB9D,KAEzCiL,EAAA9O,UAAAyH,kBAAA,SAAkBE,EAAmB9D,KAErCiL,EAAA9O,UAAAoG,kBAAA,SAAkBuB,EAAmB9D,GAAgB/D,KAAKmI,SAASN,EAAIjD,cAEvEoK,EAAA9O,UAAAwG,gBAAA,SAAgBmB,EAAiB9D,GAAgB/D,KAAKmI,SAASN,EAAIpB,SAEnEuI,EAAA9O,UAAAgH,YAAA,SAAYW,EAAa9D,KAEzBiL,EAAA9O,UAAAmH,eAAA,SAAeQ,EAAgB9D,KAE/BiL,EAAA9O,UAAAgF,iBAAA,SAAiB2C,EAAkB9D,KAEnCiL,EAAA9O,UAAAgG,UAAA,SAAU2B,EAAkB9D,GAAgB/D,KAAK+H,OAAO/F,KAAK,UAE7DgN,EAAA9O,UAAA0F,eAAA,SAAeiC,EAAgB9D,KAE/BiL,EAAA9O,UAAA4F,gBAAA,SAAgB+B,EAAiB9D,KAEjCiL,EAAA9O,UAAAiI,SAAA,SAASC,GAAT,IAAA9D,EAAAtE,KAA+B,OAAOoI,EAAKsH,KAAI,SAAAsE,GAAQ,OAAAA,EAAKnQ,MAAMS,OAElE0K,EAAA9O,UAAA2E,WAAA,SAAWgD,EAAY9D,KAEvBiL,EAAA9O,UAAAqE,WAAA,SAAWsD,EAAY9D,KAC3BiL,EAhDA,GC1vBaiF,GAAmB,IAAIC,IAAiB,CACjD,CAAC,KAAM,SAAClN,EAAWC,GAAe,OAAAD,GAAQC,IAC1C,CAAC,MAAO,SAACD,EAAWC,GAAe,OAAAD,IAASC,IAC5C,CAAC,KAAM,SAACD,EAAWC,GAAe,OAAAD,GAAQC,IAC1C,CAAC,MAAO,SAACD,EAAWC,GAAe,OAAAD,IAASC,IAC5C,CAAC,KAAM,SAACD,EAAWC,GAAe,OAAAD,GAAQC,IAC1C,CAAC,KAAM,SAACD,EAAWC,GAAe,OAAAD,GAAQC,IAC1C,CAAC,IAAK,SAACD,EAAWC,GAAe,OAAAD,EAAOC,IACxC,CAAC,IAAK,SAACD,EAAWC,GAAe,OAAAD,EAAOC,IACxC,CAAC,IAAK,SAACD,EAAWC,GAAe,OAAAD,EAAOC,IACxC,CAAC,IAAK,SAACD,EAAWC,GAAe,OAAAD,EAAOC,IACxC,CAAC,IAAK,SAACD,EAAWC,GAAe,OAAAD,EAAOC,IACxC,CAAC,IAAK,SAACD,EAAWC,GAAe,OAAAD,EAAOC,IACxC,CAAC,KAAM,SAACD,EAAWC,GAAe,OAAAD,GAAQC,IAC1C,CAAC,IAAK,SAACD,EAAWC,GAAe,OAAAD,EAAOC,IACxC,CAAC,KAAM,SAACD,EAAWC,GAAe,OAAAD,GAAQC,eCf9BkN,GAAcC,GAC1B,OAAOC,KAAKC,UAAUF,GAAMlR,QAAQ,KAAM,IAO9C,SAAgBqR,GAAWnS,GACvB,OAAe,OAARA,IAAgC,mBAARA,GAAqC,iBAARA,GAGhE,SAAgBoS,GAAWC,GACvB,MAAsB,mBAARA,ECYlB,IAAAC,GAAA,SAAAxQ,GAAA,SAAAwQ,mDA2HA,OA3H0C5U,EAAA4U,EAAAxQ,GAEtCwQ,EAAAxU,UAAAgH,YAAA,SAAYW,GACR,IAAMb,EAAOa,EAAIb,KAAKnD,MAAM7D,MACtBiH,EAAQY,EAAIZ,MAAMpD,MAAM7D,MAE9B,OAAUgH,EAAI,IAAIa,EAAId,UAAS,IAAIE,GAIvCyN,EAAAxU,UAAA2E,WAAA,SAAWgD,GACP,OAAOsM,GAAcnU,KAAKmI,SAASN,EAAIjD,eAG3C8P,EAAAxU,UAAAgF,iBAAA,SAAiB2C,GAKb,OAJkBA,EAAI9C,UAAUlB,MAAM7D,MAInB,MAHH6H,EAAI7C,QAAQnB,MAAM7D,MAGF,MAFf6H,EAAI5C,SAASpB,MAAM7D,OAKxC0U,EAAAxU,UAAAgG,UAAA,SAAU2B,GACN,IAAM8M,EAAO9M,EAAIxC,KACXY,EAAOjG,KAAKmI,SAASN,EAAI5B,MACzBhE,EAAQ4F,EAAI7B,IAAInC,MAAM7D,MAG5B,OAFAiG,EAAK2J,QAAQ3N,GAEN,mBAAmB0S,EAAI,4BAA4BR,GAAclO,GAAK,KAIjFyO,EAAAxU,UAAAyH,kBAAA,SAAkBE,GACd,IAAMvH,EAASuH,EAAIvH,OAAOuD,MAAM7D,MAGhC,OAAUM,EAAM,UAAUA,EAAM,KAFnB6T,GAAcnU,KAAKmI,SAASN,EAAI5B,OAEJ,KAG7CyO,EAAAxU,UAAAwE,sBAAA,SAAsBmD,GAClB,MAAO,WAGX6M,EAAAxU,UAAA2G,mBAAA,SAAmBgB,GACf,OAAO7H,KAAKmI,SAASN,EAAIjD,aAAa,IAG1C8P,EAAAxU,UAAA0F,eAAA,SAAeiC,GAIX,OAHYA,EAAIzF,IAAIyB,MAAM7D,MAGb,IAFD6H,EAAItH,IAAIsD,MAAM7D,MAEN,KAGxB0U,EAAAxU,UAAA4F,gBAAA,SAAgB+B,GACZ,OAAO,MAGX6M,EAAAxU,UAAAoG,kBAAA,SAAkBuB,GACd,OAAOsM,GAAcnU,KAAKmI,SAASN,EAAIjD,eAG3C8P,EAAAxU,UAAAwG,gBAAA,SAAgBmB,GAKZ,IAJA,IAAMnF,EAAS,GACT8D,EAAOqB,EAAIrB,KACXC,EAASzG,KAAKmI,SAASN,EAAIpB,QAExBzF,EAAI,EAAG4T,EAASpO,EAAK7F,OAAQK,EAAI4T,EAAQ5T,IAC9C0B,EAAO8D,EAAKxF,IAAMyF,EAAOzF,GAG7B,OAAOmT,GAAczR,IAGzBgS,EAAAxU,UAAAkG,sBAAA,SAAsByB,GAClB,MAA4B,iBAAdA,EAAI5F,MAAqB,IAAI4F,EAAI5F,MAAK,IAAM4F,EAAI5F,OAGlEyS,EAAAxU,UAAAqH,gBAAA,SAAgBM,GACZ,IAAMgN,EAAahN,EAAIxC,KACjBD,EAAWyC,EAAIzC,SAASvB,MAAM7D,MAGpC,OAAUoF,EAAQ,KAAKyP,EAAU,YAAYzP,EAAQ,KAFxC+O,GAAcnU,KAAKmI,SAASN,EAAI5B,OAEiB,KAGlEyO,EAAAxU,UAAAmH,eAAA,SAAeQ,GACX,OAAOA,EAAIT,WAAWvD,MAAM7D,OAGhC0U,EAAAxU,UAAAoF,kBAAA,SAAkBuC,GACd,IAAMiN,EAAWjN,EAAIxC,KAGrB,OAFiBwC,EAAIzC,SAASvB,MAAM7D,MAElB,KAAK8U,EAAQ,MAGnCJ,EAAAxU,UAAAsF,mBAAA,SAAmBqC,GACf,OAAO,MAGX6M,EAAAxU,UAAAwF,sBAAA,SAAsBmC,GAClB,IAAMiN,EAAWjN,EAAIxC,KAGrB,OAFiBwC,EAAIzC,SAASvB,MAAM7D,MAElB,KAAK8U,EAAQ,MAGnCJ,EAAAxU,UAAAuH,oBAAA,SAAoBI,GAChB,IAAMgN,EAAahN,EAAIxC,KACjBD,EAAWyC,EAAIzC,SAASvB,MAAM7D,MAGpC,OAAUoF,EAAQ,KAAKyP,EAAU,YAAYzP,EAAQ,KAFxC+O,GAAcnU,KAAKmI,SAASN,EAAI5B,OAEiB,KAGlEyO,EAAAxU,UAAAiI,SAAA,SAASC,GAAT,IAAA9D,EAAAtE,KACI,OAAOoI,EAAKsH,KAAI,SAAA7H,GAAO,OAAAA,EAAIhE,MAAMS,OAGrCoQ,EAAAxU,UAAAqE,WAAA,SAAWsD,GACP,OAAO,MAEf6M,EA3HA,CAA0CxM,GCC1C6M,GAAA,SAAA7Q,GAEI,SAAA6Q,EAAoBC,GAApB,IAAA1Q,EACIJ,EAAAtC,KAAA5B,OAAOA,YADSsE,EAAA0Q,MAAAA,IAmLxB,OArL0ClV,EAAAiV,EAAA7Q,GAMtC6Q,EAAA7U,UAAAgH,YAAA,SAAYW,EAAa9D,GACrB,IAAMkR,EAAShB,GAAiBiB,IAAIrN,EAAId,WAExC,IAAKkO,EACD,MAAM,IAAIpS,MAAM,iDAAiDgF,EAAId,WAGzE,OAAOkO,EAAOpN,EAAIb,KAAKnD,MAAM7D,KAAM+D,GAAU8D,EAAIZ,MAAMpD,MAAM7D,KAAM+D,KAIvEgR,EAAA7U,UAAA2E,WAAA,SAAWgD,EAAY9D,GACnB,OAAO/D,KAAKmI,SAASN,EAAIjD,YAAab,IAG1CgR,EAAA7U,UAAAgF,iBAAA,SAAiB2C,EAAkB9D,GAC/B,OAAI8D,EAAI9C,UAAUlB,MAAM7D,KAAM+D,GACnB8D,EAAI7C,QAAQnB,MAAM7D,KAAM+D,GF5ChC3B,ME8CqByF,EAAI5C,SACjB4C,EAAI5C,SAASpB,MAAM7D,KAAM+D,GAG7B,MAGXgR,EAAA7U,UAAAgG,UAAA,SAAU2B,EAAkB9D,GACxB,IAAM4Q,EAAO3U,KAAKgV,MAAME,IAAIrN,EAAIxC,MAEhC,IAAKsP,EACD,MAAM,IAAI9R,MAAM,QAAQgF,EAAIxC,KAAI,eAGpC,IAAKsP,EAAKQ,UACN,MAAM,IAAItS,MAAM,qEAAqEgF,EAAIxC,KAAI,KAGjG,IAAMpD,EAAQ4F,EAAI7B,IAAInC,MAAM7D,KAAM+D,GAC5BqR,EAAWpV,KAAKmI,SAASN,EAAI5B,KAAMlC,GAIzC,OAFAqR,EAASxF,QAAQ3N,GAEV0S,EAAKQ,UAAUtF,MAAM,KAAMuF,IAItCL,EAAA7U,UAAAyH,kBAAA,SAAkBE,EAAmB9D,GACjC,IAAMzD,EAASuH,EAAIvH,OAAOuD,MAAM7D,KAAM+D,GAEtC,IAAKsR,GAAgB/U,GACjB,MAAM,IAAIuC,MAAM,gEAGpB,IAAMoD,EAAOjG,KAAKmI,SAASN,EAAI5B,KAAMlC,GACrC,OAAOzD,EAAOuP,MAAMvP,EAAQ2F,IAGhC8O,EAAA7U,UAAAwE,sBAAA,SAAsBmD,EAAuB9D,GACzC,OAAOA,GAGXgR,EAAA7U,UAAA2G,mBAAA,SAAmBgB,EAAoB9D,GACnC,OAAO/D,KAAKmI,SAASN,EAAIjD,YAAab,GAAS,IAGnDgR,EAAA7U,UAAA0F,eAAA,SAAeiC,EAAgB9D,GAG3B,OAFY8D,EAAIzF,IAAIyB,MAAM7D,KAAM+D,GACpB8D,EAAItH,IAAIsD,MAAM7D,KAAM+D,KAIpCgR,EAAA7U,UAAA4F,gBAAA,SAAgB+B,EAAiB9D,GAC7B,IAAM3B,EAAMyF,EAAIzF,IAAIyB,MAAM7D,KAAM+D,GAC1BxD,EAAMsH,EAAItH,IAAIsD,MAAM7D,KAAM+D,GAC1B9B,EAAQ4F,EAAI5F,MAAM4B,MAAM7D,KAAM+D,GAEpC,OADA3B,EAAI7B,GAAO0B,EACJ,MAGX8S,EAAA7U,UAAAoG,kBAAA,SAAkBuB,EAAmB9D,GACjC,OAAO/D,KAAKmI,SAASN,EAAIjD,YAAab,IAG1CgR,EAAA7U,UAAAwG,gBAAA,SAAgBmB,EAAiB9D,GAK7B,IAJA,IAAMrB,EAAS,GACT8D,EAAOqB,EAAIrB,KACXC,EAASzG,KAAKmI,SAASN,EAAIpB,OAAQ1C,GAEhC/C,EAAI,EAAG4T,EAASpO,EAAK7F,OAAQK,EAAI4T,EAAQ5T,IAC9C0B,EAAO8D,EAAKxF,IAAMyF,EAAOzF,GAG7B,OAAO0B,GAGXqS,EAAA7U,UAAAkG,sBAAA,SAAsByB,EAAuB9D,GACzC,OAAO8D,EAAI5F,OAGf8S,EAAA7U,UAAAqH,gBAAA,SAAgBM,EAAiB9D,GAC7B,IAAMqB,EAAWyC,EAAIzC,SAASvB,MAAM7D,KAAM+D,GAE1C,IAAKuR,GAAgBlQ,GACjB,MAAM,IAAIvC,MAAM,6DAGpB,IAAM0S,EAASnQ,EAASyC,EAAIxC,MAE5B,IAAKgQ,GAAgBE,GACjB,MAAM,IAAI1S,MAAM,2CAA2CgF,EAAIxC,KAAI,+BAGvE,IAAMY,EAAOjG,KAAKmI,SAASN,EAAI5B,KAAMlC,GACrC,OAAOwR,EAAO1F,MAAMzK,EAAUa,IAGlC8O,EAAA7U,UAAAmH,eAAA,SAAeQ,EAAgB9D,GAC3B,OAAO8D,EAAIT,WAAWvD,MAAM7D,KAAM+D,IAGtCgR,EAAA7U,UAAAoF,kBAAA,SAAkBuC,EAAmB9D,GACjC,IAAMqB,EAAWyC,EAAIzC,SAASvB,MAAM7D,KAAM+D,GAE1C,IAAKuR,GAAgBlQ,GACjB,MAAM,IAAIvC,MAAM,iEAGpB,OAAOuC,EAASyC,EAAIxC,OAGxB0P,EAAA7U,UAAAsF,mBAAA,SAAmBqC,EAAoB9D,GACnC,IAAMqB,EAAWyC,EAAIzC,SAASvB,MAAM7D,KAAM+D,GAE1C,IAAKuR,GAAgBlQ,GACjB,MAAM,IAAIvC,MAAM,iEAIpB,OADAuC,EAASyC,EAAIxC,MAAQwC,EAAI5F,MAAM4B,MAAM7D,KAAM+D,GACpC,MAGXgR,EAAA7U,UAAAwF,sBAAA,SAAsBmC,EAAuB9D,GACzC,IAAMqB,EAAWyC,EAAIzC,SAASvB,MAAM7D,KAAM+D,GAE1C,IAAKuR,GAAgBlQ,GACjB,MAAM,IAAIvC,MAAM,qEAGpB,OAAOuC,EAASyC,EAAIxC,OAGxB0P,EAAA7U,UAAAuH,oBAAA,SAAoBI,EAAqB9D,GACrC,IAAMqB,EAAWyC,EAAIzC,SAASvB,MAAM7D,KAAM+D,GAE1C,IAAKuR,GAAgBlQ,GACjB,MAAM,IAAIvC,MAAM,iEAGpB,IAAM0S,EAASnQ,EAASyC,EAAIxC,MAE5B,IAAKgQ,GAAgBE,GACjB,MAAM,IAAI1S,MAAM,+CAA+CgF,EAAIxC,KAAI,+BAG3E,IAAMY,EAAOjG,KAAKmI,SAASN,EAAI5B,KAAMlC,GACrC,OAAOwR,EAAO1F,MAAMzK,EAAUa,IAGlC8O,EAAA7U,UAAAiI,SAAA,SAASC,EAAarE,GAAtB,IAAAO,EAAAtE,KACI,OAAOoI,EAAKsH,KAAI,SAAA7H,GAAO,OAAAA,EAAIhE,MAAMS,EAAMP,OAG3CgR,EAAA7U,UAAAqE,WAAA,SAAWsD,EAAY9D,GACnB,MAAM,IAAIlB,MAAM,8DAExBkS,EArLA,CAA0C7M,GCtB7BsN,GAAe,IAAIC,EAAAA,eAAe,eAQ/CC,GAAA,WAUE,SAAAA,EAA8CC,GAA9C,IAAArR,EAAAtE,KATQA,KAAA4V,QAAkB,IAAIxH,GAAO,IAAIjF,GACjCnJ,KAAA6V,YAAgC,IAAI3B,IACpClU,KAAA8V,WAAoC,IAAI5B,IACxClU,KAAA+V,WAAoC,IAAI7B,IAO1CyB,GAAgBA,EAAahV,QAC/BgV,EACGK,QAAO,SAAAhB,GAAS,OAAAA,GAASA,EAAMrU,UAC/B0H,SAAQ,SAAA2M,GAAS,OAAAA,EAAM3M,SAAQ,SAAC4N,GAAa,OAAA3R,EAAKuR,YAAYK,IAAID,EAASE,SAAUF,EAASG,2BAIrGV,EAAAxV,UAAAmW,KAAA,SAAKjP,GACH,GAAIpH,KAAK8V,WAAWQ,IAAIlP,GACtB,OAAOpH,KAAK8V,WAAWZ,IAAI9N,GAG7B,IAAMtD,EAAU,IAAI4Q,GAEhB7M,EAAqB7H,KAAK4V,QAAQ5F,mBAAmB5I,EAAY,SAEhES,IACHA,EAAM7H,KAAK4V,QAAQ/G,aAAazH,EAAY,UAG9C,IAAMmP,EAAS1O,EAAIhE,MAAMC,GACnB0S,EAAaxW,KAAK6V,YAClBY,EAAQ,IAAIC,SAAS,UAAW,aAAc,UAAUH,EAAM,KAE9DI,EAAY,SAAmB5S,GACnC,OAAO0S,EAAM1S,EAASyS,IAKxB,OAFAxW,KAAK8V,WAAWI,IAAI9O,EAAYuP,GAEzBA,GAGTjB,EAAAxV,UAAA0W,KAAA,SAAKxP,GACH,GAAIpH,KAAK+V,WAAWO,IAAIlP,GACtB,OAAOpH,KAAK+V,WAAWb,IAAI9N,GAG7B,IAAMtD,EAAU,IAAIiR,GAAqB/U,KAAK6V,aAE1ChO,EAAqB7H,KAAK4V,QAAQ5F,mBAAmB5I,EAAY,SAEhES,IACHA,EAAM7H,KAAK4V,QAAQ/G,aAAazH,EAAY,UAG9C,IAAMyP,EAAY,SAAmB9S,GACnC,OAAO8D,EAAIhE,MAAMC,EAASC,IAK5B,OAFA/D,KAAK+V,WAAWG,IAAI9O,EAAYyP,GAEzBA,oEArDIC,EAAAA,UAAQ,CAAAlN,KAAImN,EAAAA,OAAM9Q,KAAA,CAACuP,4HAVrBE,EAAKtV,EAAA,CADjB4W,EAAAA,WAAW,CAACC,WAAY,SAWV/V,EAAA,EAAA4V,EAAAA,YAAY5V,EAAA,EAAA6V,EAAAA,OAAOvB,MAVrBE,GAAb,iBCRA,SAAAwB,WAOA,SAPaA,EACJA,EAAAC,QAAP,SAAeC,GACb,MAAO,CACLC,SAAUC,EACVC,UAAW,CAAC,CAACC,QAAShC,GAAciC,OAAO,EAAMC,SAAUN,GAAkB,OAJtEF,EAAmBI,EAAAlX,EAAA,CAD/BuX,EAAAA,YACYT","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface BrowserNodeGlobal {\n    Object: typeof Object;\n    Array: typeof Array;\n    Map: typeof Map;\n    Set: typeof Set;\n    Date: DateConstructor;\n    RegExp: RegExpConstructor;\n    JSON: typeof JSON;\n    Math: any;  // typeof Math;\n    assert(condition: any): void;\n    Reflect: any;\n    getAngularTestability: Function;\n    getAllAngularTestabilities: Function;\n    getAllAngularRootElements: Function;\n    frameworkStabilizers: Array<Function>;\n    setTimeout: Function;\n    clearTimeout: Function;\n    setInterval: Function;\n    clearInterval: Function;\n    encodeURI: Function;\n}\n\n\nexport function getTypeNameForDebugging(type: any): string {\n    return type['name'] || typeof type;\n}\n\nexport function isPresent(obj: any): boolean {\n    return obj != null;\n}\n\nexport function isBlank(obj: any): boolean {\n    return obj == null;\n}\n\nconst STRING_MAP_PROTO = Object.getPrototypeOf({});\nexport function isStrictStringMap(obj: any): boolean {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n\nexport function stringify(token: any): string {\n    if (typeof token === 'string') {\n        return token;\n    }\n\n    if (token == null) {\n        return '' + token;\n    }\n\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n\n    if (token.name) {\n        return `${token.name}`;\n    }\n\n    const res = token.toString();\n    const newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\nexport class NumberWrapper {\n    static parseIntAutoRadix(text: string): number {\n        const result: number = parseInt(text);\n        if (isNaN(result)) {\n            throw new Error('Invalid integer literal when parsing ' + text);\n        }\n        return result;\n    }\n\n    static isNumeric(value: any): boolean { return !isNaN(value - parseFloat(value)); }\n}\n\n// JS has NaN !== NaN\nexport function looseIdentical(a: any, b: any): boolean {\n    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n}\n\nexport function isJsObject(o: any): boolean {\n    return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n\nexport function print(obj: Error | Object) {\n    // tslint:disable-next-line:no-console\n    console.log(obj);\n}\n\nexport function warn(obj: Error | Object) {\n    console.warn(obj);\n}\n\nexport function setValueOnPath(global: any, path: string, value: any) {\n    const parts = path.split('.');\n    let obj: any = global;\n    while (parts.length > 1) {\n        const name = parts.shift();\n        if (obj.hasOwnProperty(name) && obj[name] != null) {\n            obj = obj[name];\n        } else {\n            obj = obj[name] = {};\n        }\n    }\n    if (obj === undefined || obj === null) {\n        obj = {};\n    }\n    obj[parts.shift()] = value;\n}\n\nexport function isPrimitive(obj: any): boolean {\n    return !isJsObject(obj);\n}\n\nexport function escapeRegExp(s: string): string {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {isBlank} from '../facade/lang';\n\nexport class ParserError {\n    public message: string;\n    constructor(\n        message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n        this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n    }\n}\n\nexport class ParseSpan {\n    constructor(public start: number, public end: number) {}\n}\n\nexport class AST {\n    constructor(public span: ParseSpan) {}\n    visit(visitor: AstVisitor, context: any = null): any { return null; }\n    toString(): string { return 'AST'; }\n}\n\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nexport class Quote extends AST {\n    constructor(\n        span: ParseSpan, public prefix: string, public uninterpretedExpression: string,\n        public location: any) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitQuote(this, context); }\n    toString(): string { return 'Quote'; }\n}\n\nexport class EmptyExpr extends AST {\n    visit(visitor: AstVisitor, context: any = null) {\n        // do nothing\n    }\n}\n\nexport class ImplicitReceiver extends AST {\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitImplicitReceiver(this, context);\n    }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n    constructor(span: ParseSpan, public expressions: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitChain(this, context); }\n}\n\nexport class Conditional extends AST {\n    constructor(span: ParseSpan, public condition: AST, public trueExp: AST, public falseExp: AST) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitConditional(this, context);\n    }\n}\n\nexport class PropertyRead extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitPropertyRead(this, context);\n    }\n}\n\nexport class PropertyWrite extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public value: AST) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitPropertyWrite(this, context);\n    }\n}\n\nexport class SafePropertyRead extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitSafePropertyRead(this, context);\n    }\n}\n\nexport class KeyedRead extends AST {\n    constructor(span: ParseSpan, public obj: AST, public key: AST) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitKeyedRead(this, context);\n    }\n}\n\nexport class KeyedWrite extends AST {\n    constructor(span: ParseSpan, public obj: AST, public key: AST, public value: AST) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitKeyedWrite(this, context);\n    }\n}\n\nexport class BindingPipe extends AST {\n    constructor(span: ParseSpan, public exp: AST, public name: string, public args: any[]) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitPipe(this, context); }\n}\n\nexport class LiteralPrimitive extends AST {\n    constructor(span: ParseSpan, public value: any) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitLiteralPrimitive(this, context);\n    }\n}\n\nexport class LiteralArray extends AST {\n    constructor(span: ParseSpan, public expressions: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitLiteralArray(this, context);\n    }\n}\n\nexport class LiteralMap extends AST {\n    constructor(span: ParseSpan, public keys: any[], public values: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitLiteralMap(this, context);\n    }\n}\n\nexport class Interpolation extends AST {\n    constructor(span: ParseSpan, public strings: any[], public expressions: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitInterpolation(this, context);\n    }\n}\n\nexport class Binary extends AST {\n    constructor(span: ParseSpan, public operation: string, public left: AST, public right: AST) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitBinary(this, context);\n    }\n}\n\nexport class PrefixNot extends AST {\n    constructor(span: ParseSpan, public expression: AST) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitPrefixNot(this, context);\n    }\n}\n\nexport class MethodCall extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitMethodCall(this, context);\n    }\n}\n\nexport class SafeMethodCall extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitSafeMethodCall(this, context);\n    }\n}\n\nexport class FunctionCall extends AST {\n    constructor(span: ParseSpan, public target: AST, public args: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitFunctionCall(this, context);\n    }\n}\n\nexport class ASTWithSource extends AST {\n    constructor(\n        public ast: AST, public source: string, public location: string,\n        public errors: ParserError[]) {\n        super(new ParseSpan(0, isBlank(source) ? 0 : source.length));\n    }\n    visit(visitor: AstVisitor, context: any = null): any { return this.ast.visit(visitor, context); }\n    toString(): string { return `${this.source} in ${this.location}`; }\n}\n\nexport class TemplateBinding {\n    constructor(\n        public span: ParseSpan, public key: string, public keyIsVar: boolean, public name: string,\n        public expression: ASTWithSource) {}\n}\n\nexport interface AstVisitor {\n    visitBinary(ast: Binary, context: any): any;\n    visitChain(ast: Chain, context: any): any;\n    visitConditional(ast: Conditional, context: any): any;\n    visitFunctionCall(ast: FunctionCall, context: any): any;\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n    visitInterpolation(ast: Interpolation, context: any): any;\n    visitKeyedRead(ast: KeyedRead, context: any): any;\n    visitKeyedWrite(ast: KeyedWrite, context: any): any;\n    visitLiteralArray(ast: LiteralArray, context: any): any;\n    visitLiteralMap(ast: LiteralMap, context: any): any;\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n    visitMethodCall(ast: MethodCall, context: any): any;\n    visitPipe(ast: BindingPipe, context: any): any;\n    visitPrefixNot(ast: PrefixNot, context: any): any;\n    visitPropertyRead(ast: PropertyRead, context: any): any;\n    visitPropertyWrite(ast: PropertyWrite, context: any): any;\n    visitQuote(ast: Quote, context: any): any;\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n    visitBinary(ast: Binary, context: any): any {\n        ast.left.visit(this);\n        ast.right.visit(this);\n        return null;\n    }\n    visitChain(ast: Chain, context: any): any { return this.visitAll(ast.expressions, context); }\n    visitConditional(ast: Conditional, context: any): any {\n        ast.condition.visit(this);\n        ast.trueExp.visit(this);\n        ast.falseExp.visit(this);\n        return null;\n    }\n    visitPipe(ast: BindingPipe, context: any): any {\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n    visitFunctionCall(ast: FunctionCall, context: any): any {\n        ast.target.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any { return null; }\n    visitInterpolation(ast: Interpolation, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n    visitKeyedRead(ast: KeyedRead, context: any): any {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        return null;\n    }\n    visitKeyedWrite(ast: KeyedWrite, context: any): any {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        ast.value.visit(this);\n        return null;\n    }\n    visitLiteralArray(ast: LiteralArray, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n    visitLiteralMap(ast: LiteralMap, context: any): any { return this.visitAll(ast.values, context); }\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any { return null; }\n    visitMethodCall(ast: MethodCall, context: any): any {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    }\n    visitPrefixNot(ast: PrefixNot, context: any): any {\n        ast.expression.visit(this);\n        return null;\n    }\n    visitPropertyRead(ast: PropertyRead, context: any): any {\n        ast.receiver.visit(this);\n        return null;\n    }\n    visitPropertyWrite(ast: PropertyWrite, context: any): any {\n        ast.receiver.visit(this);\n        ast.value.visit(this);\n        return null;\n    }\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n        ast.receiver.visit(this);\n        return null;\n    }\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    }\n    visitAll(asts: AST[], context: any): any {\n        asts.forEach(ast => ast.visit(this, context));\n        return null;\n    }\n    visitQuote(ast: Quote, context: any): any { return null; }\n}\n\nexport class AstTransformer implements AstVisitor {\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST { return ast; }\n\n    visitInterpolation(ast: Interpolation, context: any): AST {\n        return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n    }\n\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n        return new LiteralPrimitive(ast.span, ast.value);\n    }\n\n    visitPropertyRead(ast: PropertyRead, context: any): AST {\n        return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    }\n\n    visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n        return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value);\n    }\n\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n        return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    }\n\n    visitMethodCall(ast: MethodCall, context: any): AST {\n        return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    }\n\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n        return new SafeMethodCall(\n            ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    }\n\n    visitFunctionCall(ast: FunctionCall, context: any): AST {\n        return new FunctionCall(ast.span, ast.target.visit(this), this.visitAll(ast.args));\n    }\n\n    visitLiteralArray(ast: LiteralArray, context: any): AST {\n        return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n    }\n\n    visitLiteralMap(ast: LiteralMap, context: any): AST {\n        return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n    }\n\n    visitBinary(ast: Binary, context: any): AST {\n        return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    }\n\n    visitPrefixNot(ast: PrefixNot, context: any): AST {\n        return new PrefixNot(ast.span, ast.expression.visit(this));\n    }\n\n    visitConditional(ast: Conditional, context: any): AST {\n        return new Conditional(\n            ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    }\n\n    visitPipe(ast: BindingPipe, context: any): AST {\n        return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n    }\n\n    visitKeyedRead(ast: KeyedRead, context: any): AST {\n        return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n    }\n\n    visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n        return new KeyedWrite(\n            ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    }\n\n    visitAll(asts: any[]): any[] {\n        const res = new Array(asts.length);\n        for (let i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    }\n\n    visitChain(ast: Chain, context: any): AST {\n        return new Chain(ast.span, this.visitAll(ast.expressions));\n    }\n\n    visitQuote(ast: Quote, context: any): AST {\n        return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n    }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n\nexport function isDigit(code: number): boolean {\n    return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInterpolationSymbols} from './assertions';\n\nexport class InterpolationConfig {\n    static fromArray(markers: [string, string]): InterpolationConfig {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    }\n\n    constructor(public start: string, public end: string){};\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig =\n    new InterpolationConfig('{{', '}}');","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from './chars';\nimport {NumberWrapper} from '../facade/lang';\n\nexport enum TokenType {\n    Character,\n    Identifier,\n    Keyword,\n    String,\n    Operator,\n    Number,\n    Error\n}\n\nconst KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nexport class Lexer {\n    tokenize(text: string): Token[] {\n        const scanner = new _Scanner(text);\n        const tokens: Token[] = [];\n        let token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    }\n}\n\nexport class Token {\n    constructor(\n        public index: number, public type: TokenType, public numValue: number,\n        public strValue: string) {}\n\n    isCharacter(code: number): boolean {\n        return this.type == TokenType.Character && this.numValue == code;\n    }\n\n    isNumber(): boolean { return this.type == TokenType.Number; }\n\n    isString(): boolean { return this.type == TokenType.String; }\n\n    isOperator(operater: string): boolean {\n        return this.type == TokenType.Operator && this.strValue == operater;\n    }\n\n    isIdentifier(): boolean { return this.type == TokenType.Identifier; }\n\n    isKeyword(): boolean { return this.type == TokenType.Keyword; }\n\n    isKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n\n    isKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n\n    isKeywordUndefined(): boolean {\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    }\n\n    isKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n\n    isKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n\n    isKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n\n    isError(): boolean { return this.type == TokenType.Error; }\n\n    toNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\n\n    toString(): string {\n        switch (this.type) {\n            case TokenType.Character:\n            case TokenType.Identifier:\n            case TokenType.Keyword:\n            case TokenType.Operator:\n            case TokenType.String:\n            case TokenType.Error:\n                return this.strValue;\n            case TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    }\n}\n\nfunction newCharacterToken(index: number, code: number): Token {\n    return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, text: string): Token {\n    return new Token(index, TokenType.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, text: string): Token {\n    return new Token(index, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, text: string): Token {\n    return new Token(index, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, text: string): Token {\n    return new Token(index, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, n: number): Token {\n    return new Token(index, TokenType.Number, n, '');\n}\n\nfunction newErrorToken(index: number, message: string): Token {\n    return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, TokenType.Character, 0, '');\n\nclass _Scanner {\n    length: number;\n    peek: number = 0;\n    index: number = -1;\n\n    constructor(public input: string) {\n        this.length = input.length;\n        this.advance();\n    }\n\n    advance() {\n        this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n    }\n\n    scanToken(): Token {\n        const input = this.input, length = this.length;\n        let peek = this.peek, index = this.index;\n\n        // Skip whitespace.\n        while (peek <= chars.$SPACE) {\n            if (++index >= length) {\n                peek = chars.$EOF;\n                break;\n            } else {\n                peek = input.charCodeAt(index);\n            }\n        }\n\n        this.peek = peek;\n        this.index = index;\n\n        if (index >= length) {\n            return null;\n        }\n\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek)) return this.scanIdentifier();\n        if (chars.isDigit(peek)) return this.scanNumber(index);\n\n        const start: number = index;\n        switch (peek) {\n            case chars.$PERIOD:\n                this.advance();\n                return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, chars.$PERIOD);\n            case chars.$LPAREN:\n            case chars.$RPAREN:\n            case chars.$LBRACE:\n            case chars.$RBRACE:\n            case chars.$LBRACKET:\n            case chars.$RBRACKET:\n            case chars.$COMMA:\n            case chars.$COLON:\n            case chars.$SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case chars.$SQ:\n            case chars.$DQ:\n                return this.scanString();\n            case chars.$HASH:\n            case chars.$PLUS:\n            case chars.$MINUS:\n            case chars.$STAR:\n            case chars.$SLASH:\n            case chars.$PERCENT:\n            case chars.$CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case chars.$QUESTION:\n                return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n            case chars.$LT:\n            case chars.$GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n            case chars.$BANG:\n            case chars.$EQ:\n                return this.scanComplexOperator(\n                    start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n            case chars.$AMPERSAND:\n                return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n            case chars.$BAR:\n                return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n            case chars.$NBSP:\n                while (chars.isWhitespace(this.peek)) this.advance();\n                return this.scanToken();\n        }\n\n        this.advance();\n        return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n    }\n\n    scanCharacter(start: number, code: number): Token {\n        this.advance();\n        return newCharacterToken(start, code);\n    }\n\n\n    scanOperator(start: number, str: string): Token {\n        this.advance();\n        return newOperatorToken(start, str);\n    }\n\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param start start index in the expression\n     * @param one first symbol (always part of the operator)\n     * @param twoCode code point for the second symbol\n     * @param two second symbol (part of the operator when the second code point matches)\n     * @param threeCode code point for the third symbol\n     * @param three third symbol (part of the operator when provided and matches source expression)\n     * @returns {Token}\n     */\n    scanComplexOperator(\n        start: number, one: string, twoCode: number, two: string, threeCode?: number,\n        three?: string): Token {\n        this.advance();\n        let str: string = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, str);\n    }\n\n    scanIdentifier(): Token {\n        const start: number = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek)) this.advance();\n        const str: string = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n            newIdentifierToken(start, str);\n    }\n\n    scanNumber(start: number): Token {\n        let simple: boolean = (this.index === start);\n        this.advance();  // Skip initial digit.\n        while (true) {\n            if (chars.isDigit(this.peek)) {\n                // Do nothing.\n            } else if (this.peek == chars.$PERIOD) {\n                simple = false;\n            } else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek)) this.advance();\n                if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n                simple = false;\n            } else {\n                break;\n            }\n            this.advance();\n        }\n        const str: string = this.input.substring(start, this.index);\n        const value: number = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, value);\n    }\n\n    scanString(): Token {\n        const start: number = this.index;\n        const quote: number = this.peek;\n        this.advance();  // Skip initial quote.\n\n        let buffer: string = '';\n        let marker: number = this.index;\n        const input: string = this.input;\n\n        while (this.peek != quote) {\n            if (this.peek == chars.$BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                let unescapedCode: number;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == chars.$u) {\n                    // 4 character hex code for unicode character.\n                    const hex: string = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    } else {\n                        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n                    }\n                    for (let i: number = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                } else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            } else if (this.peek == chars.$EOF) {\n                return this.error('Unterminated quote', 0);\n            } else {\n                this.advance();\n            }\n        }\n\n        const last: string = input.substring(marker, this.index);\n        this.advance();  // Skip terminating quote.\n\n        return newStringToken(start, buffer + last);\n    }\n\n    error(message: string, offset: number): Token {\n        const position: number = this.index + offset;\n        return newErrorToken(\n            position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n    }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n    return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n        (code == chars.$_) || (code == chars.$$);\n}\n\nexport function isIdentifier(input: string): boolean {\n    if (input.length == 0) return false;\n    const scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek)) return false;\n    scanner.advance();\n    while (scanner.peek !== chars.$EOF) {\n        if (!isIdentifierPart(scanner.peek)) return false;\n        scanner.advance();\n    }\n    return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n    return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n        (code == chars.$$);\n}\n\nfunction isExponentStart(code: number): boolean {\n    return code == chars.$e || code == chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n    return code == chars.$MINUS || code == chars.$PLUS;\n}\n\nexport function isQuote(code: number): boolean {\n    return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n\nfunction unescape(code: number): number {\n    switch (code) {\n        case chars.$n:\n            return chars.$LF;\n        case chars.$f:\n            return chars.$FF;\n        case chars.$r:\n            return chars.$CR;\n        case chars.$t:\n            return chars.$TAB;\n        case chars.$v:\n            return chars.$VTAB;\n        default:\n            return code;\n    }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {isBlank, isPresent} from '../facade/lang';\n\nconst isDevMode = () => false;\n\nexport function assertArrayOfStrings(identifier: string, value: any) {\n    if (!isDevMode() || isBlank(value)) {\n        return;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(`Expected '${identifier}' to be an array of strings.`);\n    }\n    for (let i = 0; i < value.length; i += 1) {\n        if (typeof value[i] !== 'string') {\n            throw new Error(`Expected '${identifier}' to be an array of strings.`);\n        }\n    }\n}\n\nconst INTERPOLATION_BLACKLIST_REGEXPS = [\n    /^\\s*$/,        // empty\n    /[<>]/,         // html tag\n    /^[{}]$/,       // i18n expansion\n    /&(#|[a-z])/i,  // character reference,\n    /^\\/\\//,        // comment\n];\n\nexport function assertInterpolationSymbols(identifier: string, value: any): void {\n    if (isPresent(value) && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n    } else if (isDevMode() && !isBlank(value)) {\n        const start = value[0] as string;\n        const end = value[1] as string;\n        // black list checking\n        INTERPOLATION_BLACKLIST_REGEXPS.forEach(regexp => {\n            if (regexp.test(start) || regexp.test(end)) {\n                throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n            }\n        });\n    }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from './chars';\nimport {escapeRegExp, isBlank, isPresent} from '../facade/lang';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './interpolation-config';\n\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, ParseSpan, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, TemplateBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from './lexer';\n\n\nexport class SplitInterpolation {\n    constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n    constructor(\n        public templateBindings: TemplateBinding[], public warnings: string[],\n        public errors: ParserError[]) {}\n}\n\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n    const pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n    return new RegExp(pattern, 'g');\n}\n\nexport class Parser {\n    private errors: ParserError[] = [];\n\n    constructor(private _lexer: Lexer) {}\n\n    parseAction(\n        input: string, location: any,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(this._stripComments(input));\n        const ast = new _ParseAST(\n            input, location, tokens, sourceToLex.length, true, this.errors,\n            input.length - sourceToLex.length)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n\n    parseBinding(\n        input: string, location: any,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        const ast = this._parseBindingAst(input, location, interpolationConfig);\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n\n    parseSimpleBinding(\n        input: string, location: string,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        const ast = this._parseBindingAst(input, location, interpolationConfig);\n        const errors = SimpleExpressionChecker.check(ast);\n        if (errors.length > 0) {\n            this._reportError(\n                `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n        }\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n\n    private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    }\n\n    private _parseBindingAst(\n        input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        const quote = this._parseQuote(input, location);\n\n        if (isPresent(quote)) {\n            return quote;\n        }\n\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(\n            input, location, tokens, sourceToLex.length, false, this.errors,\n            input.length - sourceToLex.length)\n            .parseChain();\n    }\n\n    private _parseQuote(input: string, location: any): AST {\n        if (isBlank(input)) return null;\n        const prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1) return null;\n        const prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix)) return null;\n        const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n    }\n\n    parseTemplateBindings(prefixToken: string, input: string, location: any):\n    TemplateBindingParseResult {\n        const tokens = this._lexer.tokenize(input);\n        if (prefixToken) {\n            // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n            const prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\n                t.index = 0;\n                return t;\n            });\n            tokens.unshift(...prefixTokens);\n        }\n        return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n            .parseTemplateBindings();\n    }\n\n    parseInterpolation(\n        input: string, location: any,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        const split = this.splitInterpolation(input, location, interpolationConfig);\n        if (split == null) return null;\n\n        const expressions: AST[] = [];\n\n        for (let i = 0; i < split.expressions.length; ++i) {\n            const expressionText = split.expressions[i];\n            const sourceToLex = this._stripComments(expressionText);\n            const tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));\n            const ast = new _ParseAST(\n                input, location, tokens, sourceToLex.length, false, this.errors,\n                split.offsets[i] + (expressionText.length - sourceToLex.length))\n                .parseChain();\n            expressions.push(ast);\n        }\n\n        return new ASTWithSource(\n            new Interpolation(\n                new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions),\n            input, location, this.errors);\n    }\n\n    splitInterpolation(\n        input: string, location: string,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\n        const regexp = _createInterpolateRegExp(interpolationConfig);\n        const parts = input.split(regexp);\n        if (parts.length <= 1) {\n            return null;\n        }\n        const strings: string[] = [];\n        const expressions: string[] = [];\n        const offsets: number[] = [];\n        let offset = 0;\n        for (let i = 0; i < parts.length; i++) {\n            const part: string = parts[i];\n            if (i % 2 === 0) {\n                // fixed string\n                strings.push(part);\n                offset += part.length;\n            } else if (part.trim().length > 0) {\n                offset += interpolationConfig.start.length;\n                expressions.push(part);\n                offsets.push(offset);\n                offset += part.length + interpolationConfig.end.length;\n            } else {\n                this._reportError(\n                    'Blank expressions are not allowed in interpolated strings', input,\n                    `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n                    location);\n                expressions.push('$implict');\n                offsets.push(offset);\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    }\n\n    wrapLiteralPrimitive(input: string, location: any): ASTWithSource {\n        return new ASTWithSource(\n            new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input,\n            location, this.errors);\n    }\n\n    private _stripComments(input: string): string {\n        const i = this._commentStart(input);\n        return isPresent(i) ? input.substring(0, i).trim() : input;\n    }\n\n    private _commentStart(input: string): number {\n        let outerQuote: number = null;\n        for (let i = 0; i < input.length - 1; i++) {\n            const char = input.charCodeAt(i);\n            const nextChar = input.charCodeAt(i + 1);\n\n            if (char === chars.$SLASH && nextChar == chars.$SLASH && isBlank(outerQuote)) return i;\n\n            if (outerQuote === char) {\n                outerQuote = null;\n            } else if (isBlank(outerQuote) && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    }\n\n    private _checkNoInterpolation(\n        input: string, location: any, interpolationConfig: InterpolationConfig): void {\n        const regexp = _createInterpolateRegExp(interpolationConfig);\n        const parts = input.split(regexp);\n        if (parts.length > 1) {\n            this._reportError(\n                `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n                input,\n                `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n                location);\n        }\n    }\n\n    private _findInterpolationErrorColumn(\n        parts: string[], partInErrIdx: number, interpolationConfig: InterpolationConfig): number {\n        let errLocation = '';\n        for (let j = 0; j < partInErrIdx; j++) {\n            errLocation += j % 2 === 0 ?\n                parts[j] :\n                `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n        }\n\n        return errLocation.length;\n    }\n}\n\nexport class _ParseAST {\n    private rparensExpected = 0;\n    private rbracketsExpected = 0;\n    private rbracesExpected = 0;\n\n    index: number = 0;\n\n    constructor(\n        public input: string, public location: any, public tokens: Token[],\n        public inputLength: number, public parseAction: boolean, private errors: ParserError[],\n        private offset: number) {}\n\n    peek(offset: number): Token {\n        const i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    }\n\n    get next(): Token { return this.peek(0); }\n\n    get inputIndex(): number {\n        return (this.index < this.tokens.length) ? this.next.index + this.offset :\n            this.inputLength + this.offset;\n    }\n\n    span(start: number) { return new ParseSpan(start, this.inputIndex); }\n\n    advance() { this.index++; }\n\n    optionalCharacter(code: number): boolean {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    peekKeywordLet(): boolean { return this.next.isKeywordLet(); }\n\n    expectCharacter(code: number) {\n        if (this.optionalCharacter(code)) return;\n        this.error(`Missing expected ${String.fromCharCode(code)}`);\n    }\n\n    optionalOperator(op: string): boolean {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    expectOperator(operator: string) {\n        if (this.optionalOperator(operator)) return;\n        this.error(`Missing expected operator ${operator}`);\n    }\n\n    expectIdentifierOrKeyword(): string {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            this.error(`Unexpected token ${n}, expected identifier or keyword`);\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    }\n\n    expectIdentifierOrKeywordOrString(): string {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    }\n\n    parseChain(): AST {\n        const exprs: AST[] = [];\n        const start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            const expr = this.parsePipe();\n            exprs.push(expr);\n\n            if (this.optionalCharacter(chars.$SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.optionalCharacter(chars.$SEMICOLON)) {\n                }  // read all semicolons\n            } else if (this.index < this.tokens.length) {\n                this.error(`Unexpected token '${this.next}'`);\n            }\n        }\n        if (exprs.length == 0) return new EmptyExpr(this.span(start));\n        if (exprs.length == 1) return exprs[0];\n        return new Chain(this.span(start), exprs);\n    }\n\n    parsePipe(): AST {\n        let result = this.parseExpression();\n        if (this.optionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n\n            do {\n                const name = this.expectIdentifierOrKeyword();\n                const args: AST[] = [];\n                while (this.optionalCharacter(chars.$COLON)) {\n                    args.push(this.parseExpression());\n                }\n                result = new BindingPipe(this.span(result.span.start), result, name, args);\n            } while (this.optionalOperator('|'));\n        }\n\n        return result;\n    }\n\n    parseExpression(): AST { return this.parseConditional(); }\n\n    parseConditional(): AST {\n        const start = this.inputIndex;\n        const result = this.parseLogicalOr();\n\n        if (this.optionalOperator('?')) {\n            const yes = this.parsePipe();\n            let no: AST;\n            if (!this.optionalCharacter(chars.$COLON)) {\n                const end = this.inputIndex;\n                const expression = this.input.substring(start, end);\n                this.error(`Conditional expression ${expression} requires all 3 expressions`);\n                no = new EmptyExpr(this.span(start));\n            } else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), result, yes, no);\n        } else {\n            return result;\n        }\n    }\n\n    parseLogicalOr(): AST {\n        // '||'\n        let result = this.parseLogicalAnd();\n        while (this.optionalOperator('||')) {\n            const right = this.parseLogicalAnd();\n            result = new Binary(this.span(result.span.start), '||', result, right);\n        }\n        return result;\n    }\n\n    parseLogicalAnd(): AST {\n        // '&&'\n        let result = this.parseEquality();\n        while (this.optionalOperator('&&')) {\n            const right = this.parseEquality();\n            result = new Binary(this.span(result.span.start), '&&', result, right);\n        }\n        return result;\n    }\n\n    parseEquality(): AST {\n        // '==','!=','===','!=='\n        let result = this.parseRelational();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    const right = this.parseRelational();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parseRelational(): AST {\n        // '<', '>', '<=', '>='\n        let result = this.parseAdditive();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    const right = this.parseAdditive();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parseAdditive(): AST {\n        // '+', '-'\n        let result = this.parseMultiplicative();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    let right = this.parseMultiplicative();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parseMultiplicative(): AST {\n        // '*', '%', '/'\n        let result = this.parsePrefix();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    let right = this.parsePrefix();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parsePrefix(): AST {\n        if (this.next.type == TokenType.Operator) {\n            const start = this.inputIndex;\n            const operator = this.next.strValue;\n            let result: AST;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    return this.parsePrefix();\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(\n                        this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0),\n                        result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), result);\n            }\n        }\n        return this.parseCallChain();\n    }\n\n    parseCallChain(): AST {\n        let result = this.parsePrimary();\n        while (true) {\n            if (this.optionalCharacter(chars.$PERIOD)) {\n                result = this.parseAccessMemberOrMethodCall(result, false);\n\n            } else if (this.optionalOperator('?.')) {\n                result = this.parseAccessMemberOrMethodCall(result, true);\n\n            } else if (this.optionalCharacter(chars.$LBRACKET)) {\n                this.rbracketsExpected++;\n                const key = this.parsePipe();\n                this.rbracketsExpected--;\n                this.expectCharacter(chars.$RBRACKET);\n                if (this.optionalOperator('=')) {\n                    const value = this.parseConditional();\n                    result = new KeyedWrite(this.span(result.span.start), result, key, value);\n                } else {\n                    result = new KeyedRead(this.span(result.span.start), result, key);\n                }\n\n            } else if (this.optionalCharacter(chars.$LPAREN)) {\n                this.rparensExpected++;\n                const args = this.parseCallArguments();\n                this.rparensExpected--;\n                this.expectCharacter(chars.$RPAREN);\n                result = new FunctionCall(this.span(result.span.start), result, args);\n\n            } else {\n                return result;\n            }\n        }\n    }\n\n    parsePrimary(): AST {\n        const start = this.inputIndex;\n        if (this.optionalCharacter(chars.$LPAREN)) {\n            this.rparensExpected++;\n            const result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter(chars.$RPAREN);\n            return result;\n\n        } else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), null);\n\n        } else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), void 0);\n\n        } else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), true);\n\n        } else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), false);\n\n        } else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ImplicitReceiver(this.span(start));\n\n        } else if (this.optionalCharacter(chars.$LBRACKET)) {\n            this.rbracketsExpected++;\n            const elements = this.parseExpressionList(chars.$RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter(chars.$RBRACKET);\n            return new LiteralArray(this.span(start), elements);\n\n        } else if (this.next.isCharacter(chars.$LBRACE)) {\n            return this.parseLiteralMap();\n\n        } else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n\n        } else if (this.next.isNumber()) {\n            const value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), value);\n\n        } else if (this.next.isString()) {\n            const literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), literalValue);\n\n        } else if (this.index >= this.tokens.length) {\n            this.error(`Unexpected end of expression: ${this.input}`);\n            return new EmptyExpr(this.span(start));\n        } else {\n            this.error(`Unexpected token ${this.next}`);\n            return new EmptyExpr(this.span(start));\n        }\n    }\n\n    parseExpressionList(terminator: number): AST[] {\n        const result: AST[] = [];\n        if (!this.next.isCharacter(terminator)) {\n            do {\n                result.push(this.parsePipe());\n            } while (this.optionalCharacter(chars.$COMMA));\n        }\n        return result;\n    }\n\n    parseLiteralMap(): LiteralMap {\n        const keys: string[] = [];\n        const values: AST[] = [];\n        const start = this.inputIndex;\n        this.expectCharacter(chars.$LBRACE);\n        if (!this.optionalCharacter(chars.$RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                const key = this.expectIdentifierOrKeywordOrString();\n                keys.push(key);\n                this.expectCharacter(chars.$COLON);\n                values.push(this.parsePipe());\n            } while (this.optionalCharacter(chars.$COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter(chars.$RBRACE);\n        }\n        return new LiteralMap(this.span(start), keys, values);\n    }\n\n    parseAccessMemberOrMethodCall(receiver: AST, isSafe: boolean = false): AST {\n        const start = receiver.span.start;\n        const id = this.expectIdentifierOrKeyword();\n\n        if (this.optionalCharacter(chars.$LPAREN)) {\n            this.rparensExpected++;\n            const args = this.parseCallArguments();\n            this.expectCharacter(chars.$RPAREN);\n            this.rparensExpected--;\n            const span = this.span(start);\n            return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                new MethodCall(span, receiver, id, args);\n\n        } else {\n            if (isSafe) {\n                if (this.optionalOperator('=')) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                    return new EmptyExpr(this.span(start));\n                } else {\n                    return new SafePropertyRead(this.span(start), receiver, id);\n                }\n            } else {\n                if (this.optionalOperator('=')) {\n                    if (!this.parseAction) {\n                        this.error('Bindings cannot contain assignments');\n                        return new EmptyExpr(this.span(start));\n                    }\n\n                    const value = this.parseConditional();\n                    return new PropertyWrite(this.span(start), receiver, id, value);\n                } else {\n                    return new PropertyRead(this.span(start), receiver, id);\n                }\n            }\n        }\n    }\n\n    parseCallArguments(): BindingPipe[] {\n        if (this.next.isCharacter(chars.$RPAREN)) return [];\n        const positionals: AST[] = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.optionalCharacter(chars.$COMMA));\n        return positionals as BindingPipe[];\n    }\n\n    /**\n     * An identifier, a keyword, a string with an optional `-` inbetween.\n     */\n    expectTemplateBindingKey(): string {\n        let result = '';\n        let operatorFound = false;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.optionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n\n        return result.toString();\n    }\n\n    parseTemplateBindings(): TemplateBindingParseResult {\n        const bindings: TemplateBinding[] = [];\n        let prefix: string = null;\n        const warnings: string[] = [];\n        while (this.index < this.tokens.length) {\n            const start = this.inputIndex;\n            const keyIsVar: boolean = this.peekKeywordLet();\n            if (keyIsVar) {\n                this.advance();\n            }\n            let key = this.expectTemplateBindingKey();\n            if (!keyIsVar) {\n                if (prefix == null) {\n                    prefix = key;\n                } else {\n                    key = prefix + key[0].toUpperCase() + key.substring(1);\n                }\n            }\n            this.optionalCharacter(chars.$COLON);\n            let name: string = null;\n            let expression: ASTWithSource = null;\n            if (keyIsVar) {\n                if (this.optionalOperator('=')) {\n                    name = this.expectTemplateBindingKey();\n                } else {\n                    name = '\\$implicit';\n                }\n            } else if (this.next !== EOF && !this.peekKeywordLet()) {\n                const start = this.inputIndex;\n                const ast = this.parsePipe();\n                const source = this.input.substring(start - this.offset, this.inputIndex - this.offset);\n                expression = new ASTWithSource(ast, source, this.location, this.errors);\n            }\n            bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n            if (!this.optionalCharacter(chars.$SEMICOLON)) {\n                this.optionalCharacter(chars.$COMMA);\n            }\n        }\n        return new TemplateBindingParseResult(bindings, warnings, this.errors);\n    }\n\n    error(message: string, index: number = null) {\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    }\n\n    private locationText(index: number = null) {\n        if (isBlank(index)) index = this.index;\n        return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n            `at the end of the expression`;\n    }\n\n    // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n    // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n    // '}' and ']' as conditional recovery points if one of calling productions is expecting\n    // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n    // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n    // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n    // must be conditional as they must be skipped if none of the calling productions are not\n    // expecting the closing token else we will never make progress in the case of an\n    // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n    // parseChain() is always the root production and it expects a ';'.\n\n    // If a production expects one of these token it increments the corresponding nesting count,\n    // and then decrements it just prior to checking if the token is in the input.\n    private skip() {\n        let n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n        (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n        (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n        (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\n            if (this.next.isError()) {\n                this.errors.push(\n                    new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n    static check(ast: AST): string[] {\n        const s = new SimpleExpressionChecker();\n        ast.visit(s);\n        return s.errors;\n    }\n\n    errors: string[] = [];\n\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n    visitInterpolation(ast: Interpolation, context: any) {}\n\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n    visitPropertyRead(ast: PropertyRead, context: any) {}\n\n    visitPropertyWrite(ast: PropertyWrite, context: any) {}\n\n    visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n\n    visitMethodCall(ast: MethodCall, context: any) {}\n\n    visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n\n    visitFunctionCall(ast: FunctionCall, context: any) {}\n\n    visitLiteralArray(ast: LiteralArray, context: any) { this.visitAll(ast.expressions); }\n\n    visitLiteralMap(ast: LiteralMap, context: any) { this.visitAll(ast.values); }\n\n    visitBinary(ast: Binary, context: any) {}\n\n    visitPrefixNot(ast: PrefixNot, context: any) {}\n\n    visitConditional(ast: Conditional, context: any) {}\n\n    visitPipe(ast: BindingPipe, context: any) { this.errors.push('pipes'); }\n\n    visitKeyedRead(ast: KeyedRead, context: any) {}\n\n    visitKeyedWrite(ast: KeyedWrite, context: any) {}\n\n    visitAll(asts: any[]): any[] { return asts.map(node => node.visit(this)); }\n\n    visitChain(ast: Chain, context: any) {}\n\n    visitQuote(ast: Quote, context: any) {}\n}","export const BinaryOperations = new Map<string, any>([\n    ['==', (left: any, right: any) => left == right],\n    ['===', (left: any, right: any) => left === right],\n    ['!=', (left: any, right: any) => left != right],\n    ['!==', (left: any, right: any) => left !== right],\n    ['&&', (left: any, right: any) => left && right],\n    ['||', (left: any, right: any) => left || right],\n    ['+', (left: any, right: any) => left + right],\n    ['-', (left: any, right: any) => left - right],\n    ['/', (left: any, right: any) => left / right],\n    ['*', (left: any, right: any) => left * right],\n    ['%', (left: any, right: any) => left % right],\n    ['<', (left: any, right: any) => left < right],\n    ['<=', (left: any, right: any) => left <= right],\n    ['>', (left: any, right: any) => left > right],\n    ['>=', (left: any, right: any) => left >= right],\n]);","export function compileToJSON(json: any) {\n    return JSON.stringify(json).replace(/\"/g, '');\n}\n\nexport function isPresent(obj: any) {\n    return obj !== null && obj !== undefined;\n}\n\nexport function isJsObject(obj: any) {\n    return obj !== null && (typeof obj === 'function' || typeof obj === 'object');\n}\n\nexport function isFunction(val: any) {\n    return typeof val === 'function';\n}","import {\n    AST,\n    RecursiveAstVisitor,\n    PropertyRead,\n    MethodCall,\n    KeyedRead,\n    ImplicitReceiver,\n    LiteralPrimitive,\n    Binary,\n    Chain,\n    Conditional,\n    BindingPipe,\n    FunctionCall,\n    Interpolation,\n    KeyedWrite,\n    LiteralArray,\n    LiteralMap,\n    PrefixNot,\n    PropertyWrite,\n    SafePropertyRead,\n    SafeMethodCall,\n    Quote\n} from '../angular';\nimport { compileToJSON } from '../util';\n\nexport class ParseVisitorCompiler extends RecursiveAstVisitor {\n\n    visitBinary(ast: Binary): any {\n        const left = ast.left.visit(this);\n        const right = ast.right.visit(this);\n\n        return `${left} ${ast.operation} ${right}`;\n    }\n\n    // TODO\n    visitChain(ast: Chain): any {\n        return compileToJSON(this.visitAll(ast.expressions));\n    }\n\n    visitConditional(ast: Conditional): any {\n        const condition = ast.condition.visit(this);\n        const trueExp = ast.trueExp.visit(this);\n        const falseExp = ast.falseExp.visit(this);\n\n        return `${condition} ? ${trueExp} : ${falseExp}`;\n    }\n\n    visitPipe(ast: BindingPipe): any {\n        const pipe = ast.name;\n        const args = this.visitAll(ast.args);\n        const value = ast.exp.visit(this);\n        args.unshift(value);\n\n        return `pipesCache.get('${pipe}').transform.apply(null, ${compileToJSON(args)})`;\n    }\n\n    // TODO\n    visitFunctionCall(ast: FunctionCall): any {\n        const target = ast.target.visit(this);\n        const args = compileToJSON(this.visitAll(ast.args));\n\n        return `${target}.apply(${target}, ${args})`;\n    }\n\n    visitImplicitReceiver(ast: ImplicitReceiver): any {\n        return `context`;\n    }\n\n    visitInterpolation(ast: Interpolation): any {\n        return this.visitAll(ast.expressions)[0];\n    }\n\n    visitKeyedRead(ast: KeyedRead): any {\n        const obj = ast.obj.visit(this);\n        const key = ast.key.visit(this);\n\n        return `${obj}[${key}]`;\n    }\n\n    visitKeyedWrite(ast: KeyedWrite): any {\n        return null;\n    }\n\n    visitLiteralArray(ast: LiteralArray): any {\n        return compileToJSON(this.visitAll(ast.expressions));\n    }\n\n    visitLiteralMap(ast: LiteralMap): any {\n        const result = {};\n        const keys = ast.keys;\n        const values = this.visitAll(ast.values);\n\n        for (let i = 0, length = keys.length; i < length; i++) {\n            result[keys[i]] = values[i];\n        }\n\n        return compileToJSON(result);\n    }\n\n    visitLiteralPrimitive(ast: LiteralPrimitive): any {\n        return typeof ast.value === 'string' ? `'${ast.value}'` : ast.value;\n    }\n\n    visitMethodCall(ast: MethodCall): any {\n        const methodName = ast.name;\n        const receiver = ast.receiver.visit(this);\n        const args = compileToJSON(this.visitAll(ast.args));\n\n        return `${receiver}['${methodName}'].apply(${receiver}, ${args})`;\n    }\n\n    visitPrefixNot(ast: PrefixNot): any {\n        return ast.expression.visit(this);\n    }\n\n    visitPropertyRead(ast: PropertyRead): any {\n        const property = ast.name;\n        const receiver = ast.receiver.visit(this);\n\n        return `${receiver}['${property}']`;\n    }\n\n    visitPropertyWrite(ast: PropertyWrite): any {\n        return null;\n    }\n\n    visitSafePropertyRead(ast: SafePropertyRead): any {\n        const property = ast.name;\n        const receiver = ast.receiver.visit(this);\n\n        return `${receiver}['${property}']`;\n    }\n\n    visitSafeMethodCall(ast: SafeMethodCall): any {\n        const methodName = ast.name;\n        const receiver = ast.receiver.visit(this);\n        const args = compileToJSON(this.visitAll(ast.args));\n\n        return `${receiver}['${methodName}'].apply(${receiver}, ${args})`;\n    }\n\n    visitAll(asts: AST[]): any {\n        return asts.map(ast => ast.visit(this));\n    }\n\n    visitQuote(ast: Quote): any {\n        return null;\n    }\n}","import {\n    AST,\n    RecursiveAstVisitor,\n    PropertyRead,\n    MethodCall,\n    KeyedRead,\n    ImplicitReceiver,\n    LiteralPrimitive,\n    Binary,\n    Chain,\n    Conditional,\n    BindingPipe,\n    FunctionCall,\n    Interpolation,\n    KeyedWrite,\n    LiteralArray,\n    LiteralMap,\n    PrefixNot,\n    PropertyWrite,\n    SafePropertyRead,\n    SafeMethodCall,\n    Quote\n} from '../angular';\nimport * as util from '../util';\nimport { BinaryOperations } from '../util/binary-operations';\n\nexport class ParseVisitorResolver extends RecursiveAstVisitor {\n\n    constructor(private pipes: Map<string, any>) {\n        super();\n    };\n\n    visitBinary(ast: Binary, context: any): any {\n        const execFn = BinaryOperations.get(ast.operation);\n\n        if (!execFn) {\n            throw new Error(`Parse ERROR: on visitBinary, unknown operator ${ast.operation}`);\n        }\n\n        return execFn(ast.left.visit(this, context), ast.right.visit(this, context));\n    }\n\n    // TODO\n    visitChain(ast: Chain, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n\n    visitConditional(ast: Conditional, context: any): any {\n        if (ast.condition.visit(this, context)) {\n            return ast.trueExp.visit(this, context);\n        }\n        else if (util.isPresent(ast.falseExp)) {\n            return ast.falseExp.visit(this, context);\n        }\n\n        return null;\n    }\n\n    visitPipe(ast: BindingPipe, context: any): any {\n        const pipe = this.pipes.get(ast.name);\n\n        if (!pipe) {\n            throw new Error(`pipe ${ast.name} not found.`);\n        }\n\n        if (!pipe.transform) {\n            throw new Error(`Parse ERROR: on visitPipe, transform method doesn't exist on pipe ${ast.name}.`);\n        }\n\n        const value = ast.exp.visit(this, context);\n        const pipeArgs = this.visitAll(ast.args, context);\n\n        pipeArgs.unshift(value);\n\n        return pipe.transform.apply(null, pipeArgs);\n    }\n\n    // TODO\n    visitFunctionCall(ast: FunctionCall, context: any): any {\n        const target = ast.target.visit(this, context);\n\n        if (!util.isFunction(target)) {\n            throw new Error(`Parse ERROR: on visitFunctionCall, target is not a function.`);\n        }\n\n        const args = this.visitAll(ast.args, context);\n        return target.apply(target, args);\n    }\n\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any {\n        return context;\n    }\n\n    visitInterpolation(ast: Interpolation, context: any): any {\n        return this.visitAll(ast.expressions, context)[0];\n    }\n\n    visitKeyedRead(ast: KeyedRead, context: any): any {\n        const obj = ast.obj.visit(this, context);\n        const key = ast.key.visit(this, context);\n        return obj[key];\n    }\n\n    visitKeyedWrite(ast: KeyedWrite, context: any): any {\n        const obj = ast.obj.visit(this, context);\n        const key = ast.key.visit(this, context);\n        const value = ast.value.visit(this, context);\n        obj[key] = value;\n        return null;\n    }\n\n    visitLiteralArray(ast: LiteralArray, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n\n    visitLiteralMap(ast: LiteralMap, context: any): any {\n        const result = {};\n        const keys = ast.keys;\n        const values = this.visitAll(ast.values, context);\n\n        for (let i = 0, length = keys.length; i < length; i++) {\n            result[keys[i]] = values[i];\n        }\n\n        return result;\n    }\n\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {\n        return ast.value;\n    }\n\n    visitMethodCall(ast: MethodCall, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitMethodCall, invalid method receiver.`);\n        }\n\n        const method = receiver[ast.name];\n\n        if (!util.isFunction(method)) {\n            throw new Error(`Parse ERROR: on visitMethodCall, method ${ast.name} doesn't exist on receiver.`);\n        }\n\n        const args = this.visitAll(ast.args, context);\n        return method.apply(receiver, args);\n    }\n\n    visitPrefixNot(ast: PrefixNot, context: any): any {\n        return ast.expression.visit(this, context);\n    }\n\n    visitPropertyRead(ast: PropertyRead, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitPropertyRead, invalid property receiver.`);\n        }\n\n        return receiver[ast.name];\n    }\n\n    visitPropertyWrite(ast: PropertyWrite, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitPropertyRead, invalid property receiver.`);\n        }\n\n        receiver[ast.name] = ast.value.visit(this, context);\n        return null;\n    }\n\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitSafePropertyRead, invalid property receiver.`);\n        }\n\n        return receiver[ast.name];\n    }\n\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitSafeMethodCall, invalid method receiver.`);\n        }\n\n        const method = receiver[ast.name];\n\n        if (!util.isFunction(method)) {\n            throw new Error(`Parse ERROR: on visitSafeMethodCall, method ${ast.name} doesn't exist on receiver.`);\n        }\n\n        const args = this.visitAll(ast.args, context);\n        return method.apply(receiver, args);\n    }\n\n    visitAll(asts: AST[], context: any): any {\n        return asts.map(ast => ast.visit(this, context));\n    }\n\n    visitQuote(ast: Quote, context: any): any {\n        throw new Error(`Parse ERROR: on visitQuote, quote expression not allowed.`);\n    }\n}","import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { Parser, Lexer, ASTWithSource } from './angular';\nimport { ParseVisitorResolver, ParseVisitorCompiler } from './visitors';\n\nexport const PIPES_CONFIG = new InjectionToken('PipesConfig');\n\nexport interface PipesConfig {\n  pipeName: string;\n  pipeInstance: any;\n}\n\n@Injectable({providedIn: 'root'})\nexport class Parse {\n  private _parser: Parser = new Parser(new Lexer());\n  private _pipesCache: Map<string, any> = new Map<string, any>();\n  private _evalCache: Map<string, Function> = new Map<string, Function>();\n  private _calcCache: Map<string, Function> = new Map<string, Function>();\n\n  /**\n   * Used to dependency inject the Angular 2 parser.\n   */\n\n  constructor(@Optional() @Inject(PIPES_CONFIG) pipesConfigs: PipesConfig[][]) {\n    if (pipesConfigs && pipesConfigs.length) {\n      pipesConfigs\n        .filter(pipes => pipes && pipes.length)\n        .forEach(pipes => pipes.forEach((pipeData) => this._pipesCache.set(pipeData.pipeName, pipeData.pipeInstance)));\n    }\n  }\n\n  eval(expression: string): Function {\n    if (this._evalCache.has(expression)) {\n      return this._evalCache.get(expression);\n    }\n\n    const visitor = new ParseVisitorCompiler();\n\n    let ast: ASTWithSource = this._parser.parseInterpolation(expression, 'Parse');\n\n    if (!ast) {\n      ast = this._parser.parseBinding(expression, 'Parse');\n    }\n\n    const fnBody = ast.visit(visitor);\n    const pipesCache = this._pipesCache;\n    const getFn = new Function('context', 'pipesCache', `return ${fnBody};`);\n\n    const evalParse = function evalParse(context: any): any {\n      return getFn(context, pipesCache);\n    };\n\n    this._evalCache.set(expression, evalParse);\n\n    return evalParse;\n  }\n\n  calc(expression: string): Function {\n    if (this._calcCache.has(expression)) {\n      return this._calcCache.get(expression);\n    }\n\n    const visitor = new ParseVisitorResolver(this._pipesCache);\n\n    let ast: ASTWithSource = this._parser.parseInterpolation(expression, 'Parse');\n\n    if (!ast) {\n      ast = this._parser.parseBinding(expression, 'Parse');\n    }\n\n    const calcParse = function calcParse(context: any): any {\n      return ast.visit(visitor, context);\n    };\n\n    this._calcCache.set(expression, calcParse);\n\n    return calcParse;\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { Parse, PIPES_CONFIG, PipesConfig } from './parse';\n\n@NgModule()\nexport class Angular2ParseModule {\n  static forRoot(pipesConfigMap: PipesConfig[]): ModuleWithProviders {\n    return {\n      ngModule: Angular2ParseModule,\n      providers: [{provide: PIPES_CONFIG, multi: true, useValue: pipesConfigMap || []}]\n    };\n  }\n}\n"]}