{"version":3,"file":"json-string-mapper.umd.js","sources":["../src/angular/src/angular/facade/lang.ts","../src/angular/src/angular/compiler/ast.ts","../src/angular/src/angular/compiler/chars.ts","../src/angular/src/angular/compiler/assertions.ts","../src/angular/src/angular/compiler/interpolation-config.ts","../src/angular/src/angular/compiler/lexer.ts","../src/angular/src/angular/compiler/parser.ts","../src/src/util/lang.ts","../src/visitors/src/visitors/json-string-mapper-visitor/json-string-mapper-visitor.ts","../src/src/mapper/json-string-mapper.ts"],"sourcesContent":["/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nexport interface BrowserNodeGlobal {\r\n    Object: typeof Object;\r\n    Array: typeof Array;\r\n    Map: typeof Map;\r\n    Set: typeof Set;\r\n    Date: DateConstructor;\r\n    RegExp: RegExpConstructor;\r\n    JSON: typeof JSON;\r\n    Math: any;  // typeof Math;\r\n    assert(condition: any): void;\r\n    Reflect: any;\r\n    getAngularTestability: Function;\r\n    getAllAngularTestabilities: Function;\r\n    getAllAngularRootElements: Function;\r\n    frameworkStabilizers: Array<Function>;\r\n    setTimeout: Function;\r\n    clearTimeout: Function;\r\n    setInterval: Function;\r\n    clearInterval: Function;\r\n    encodeURI: Function;\r\n}\r\n\r\n\r\nexport function getTypeNameForDebugging(type: any): string {\r\n    return type['name'] || typeof type;\r\n}\r\n\r\nexport function isPresent(obj: any): boolean {\r\n    return obj != null;\r\n}\r\n\r\nexport function isBlank(obj: any): boolean {\r\n    return obj == null;\r\n}\r\n\r\nconst STRING_MAP_PROTO = Object.getPrototypeOf({});\r\nexport function isStrictStringMap(obj: any): boolean {\r\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\r\n}\r\n\r\nexport function stringify(token: any): string {\r\n    if (typeof token === 'string') {\r\n        return token;\r\n    }\r\n\r\n    if (token == null) {\r\n        return '' + token;\r\n    }\r\n\r\n    if (token.overriddenName) {\r\n        return `${token.overriddenName}`;\r\n    }\r\n\r\n    if (token.name) {\r\n        return `${token.name}`;\r\n    }\r\n\r\n    const res = token.toString();\r\n    const newLineIndex = res.indexOf('\\n');\r\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\r\n}\r\n\r\nexport class NumberWrapper {\r\n    static parseIntAutoRadix(text: string): number {\r\n        const result: number = parseInt(text);\r\n        if (isNaN(result)) {\r\n            throw new Error('Invalid integer literal when parsing ' + text);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static isNumeric(value: any): boolean { return !isNaN(value - parseFloat(value)); }\r\n}\r\n\r\n// JS has NaN !== NaN\r\nexport function looseIdentical(a: any, b: any): boolean {\r\n    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\r\n}\r\n\r\nexport function isJsObject(o: any): boolean {\r\n    return o !== null && (typeof o === 'function' || typeof o === 'object');\r\n}\r\n\r\nexport function print(obj: Error | Object) {\r\n    // tslint:disable-next-line:no-console\r\n    console.log(obj);\r\n}\r\n\r\nexport function warn(obj: Error | Object) {\r\n    console.warn(obj);\r\n}\r\n\r\nexport function setValueOnPath(global: any, path: string, value: any) {\r\n    const parts = path.split('.');\r\n    let obj: any = global;\r\n    while (parts.length > 1) {\r\n        const name = parts.shift();\r\n        if (obj.hasOwnProperty(name) && obj[name] != null) {\r\n            obj = obj[name];\r\n        } else {\r\n            obj = obj[name] = {};\r\n        }\r\n    }\r\n    if (obj === undefined || obj === null) {\r\n        obj = {};\r\n    }\r\n    obj[parts.shift()] = value;\r\n}\r\n\r\nexport function isPrimitive(obj: any): boolean {\r\n    return !isJsObject(obj);\r\n}\r\n\r\nexport function escapeRegExp(s: string): string {\r\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\r\n}","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\r\nimport {isBlank} from '../facade/lang';\r\n\r\nexport class ParserError {\r\n    public message: string;\r\n    constructor(\r\n        message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\r\n        this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\r\n    }\r\n}\r\n\r\nexport class ParseSpan {\r\n    constructor(public start: number, public end: number) {}\r\n}\r\n\r\nexport class AST {\r\n    constructor(public span: ParseSpan) {}\r\n    visit(visitor: AstVisitor, context: any = null): any { return null; }\r\n    toString(): string { return 'AST'; }\r\n}\r\n\r\n/**\r\n * Represents a quoted expression of the form:\r\n *\r\n * quote = prefix `:` uninterpretedExpression\r\n * prefix = identifier\r\n * uninterpretedExpression = arbitrary string\r\n *\r\n * A quoted expression is meant to be pre-processed by an AST transformer that\r\n * converts it into another AST that no longer contains quoted expressions.\r\n * It is meant to allow third-party developers to extend Angular template\r\n * expression language. The `uninterpretedExpression` part of the quote is\r\n * therefore not interpreted by the Angular's own expression parser.\r\n */\r\nexport class Quote extends AST {\r\n    constructor(\r\n        span: ParseSpan, public prefix: string, public uninterpretedExpression: string,\r\n        public location: any) {\r\n        super(span);\r\n    }\r\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitQuote(this, context); }\r\n    toString(): string { return 'Quote'; }\r\n}\r\n\r\nexport class EmptyExpr extends AST {\r\n    visit(visitor: AstVisitor, context: any = null) {\r\n        // do nothing\r\n    }\r\n}\r\n\r\nexport class ImplicitReceiver extends AST {\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitImplicitReceiver(this, context);\r\n    }\r\n}\r\n\r\n/**\r\n * Multiple expressions separated by a semicolon.\r\n */\r\nexport class Chain extends AST {\r\n    constructor(span: ParseSpan, public expressions: any[]) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitChain(this, context); }\r\n}\r\n\r\nexport class Conditional extends AST {\r\n    constructor(span: ParseSpan, public condition: AST, public trueExp: AST, public falseExp: AST) {\r\n        super(span);\r\n    }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitConditional(this, context);\r\n    }\r\n}\r\n\r\nexport class PropertyRead extends AST {\r\n    constructor(span: ParseSpan, public receiver: AST, public name: string) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitPropertyRead(this, context);\r\n    }\r\n}\r\n\r\nexport class PropertyWrite extends AST {\r\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public value: AST) {\r\n        super(span);\r\n    }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitPropertyWrite(this, context);\r\n    }\r\n}\r\n\r\nexport class SafePropertyRead extends AST {\r\n    constructor(span: ParseSpan, public receiver: AST, public name: string) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitSafePropertyRead(this, context);\r\n    }\r\n}\r\n\r\nexport class KeyedRead extends AST {\r\n    constructor(span: ParseSpan, public obj: AST, public key: AST) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitKeyedRead(this, context);\r\n    }\r\n}\r\n\r\nexport class KeyedWrite extends AST {\r\n    constructor(span: ParseSpan, public obj: AST, public key: AST, public value: AST) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitKeyedWrite(this, context);\r\n    }\r\n}\r\n\r\nexport class BindingPipe extends AST {\r\n    constructor(span: ParseSpan, public exp: AST, public name: string, public args: any[]) {\r\n        super(span);\r\n    }\r\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitPipe(this, context); }\r\n}\r\n\r\nexport class LiteralPrimitive extends AST {\r\n    constructor(span: ParseSpan, public value: any) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitLiteralPrimitive(this, context);\r\n    }\r\n}\r\n\r\nexport class LiteralArray extends AST {\r\n    constructor(span: ParseSpan, public expressions: any[]) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitLiteralArray(this, context);\r\n    }\r\n}\r\n\r\nexport class LiteralMap extends AST {\r\n    constructor(span: ParseSpan, public keys: any[], public values: any[]) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitLiteralMap(this, context);\r\n    }\r\n}\r\n\r\nexport class Interpolation extends AST {\r\n    constructor(span: ParseSpan, public strings: any[], public expressions: any[]) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitInterpolation(this, context);\r\n    }\r\n}\r\n\r\nexport class Binary extends AST {\r\n    constructor(span: ParseSpan, public operation: string, public left: AST, public right: AST) {\r\n        super(span);\r\n    }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitBinary(this, context);\r\n    }\r\n}\r\n\r\nexport class PrefixNot extends AST {\r\n    constructor(span: ParseSpan, public expression: AST) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitPrefixNot(this, context);\r\n    }\r\n}\r\n\r\nexport class MethodCall extends AST {\r\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\r\n        super(span);\r\n    }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitMethodCall(this, context);\r\n    }\r\n}\r\n\r\nexport class SafeMethodCall extends AST {\r\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\r\n        super(span);\r\n    }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitSafeMethodCall(this, context);\r\n    }\r\n}\r\n\r\nexport class FunctionCall extends AST {\r\n    constructor(span: ParseSpan, public target: AST, public args: any[]) { super(span); }\r\n    visit(visitor: AstVisitor, context: any = null): any {\r\n        return visitor.visitFunctionCall(this, context);\r\n    }\r\n}\r\n\r\nexport class ASTWithSource extends AST {\r\n    constructor(\r\n        public ast: AST, public source: string, public location: string,\r\n        public errors: ParserError[]) {\r\n        super(new ParseSpan(0, isBlank(source) ? 0 : source.length));\r\n    }\r\n    visit(visitor: AstVisitor, context: any = null): any { return this.ast.visit(visitor, context); }\r\n    toString(): string { return `${this.source} in ${this.location}`; }\r\n}\r\n\r\nexport class TemplateBinding {\r\n    constructor(\r\n        public span: ParseSpan, public key: string, public keyIsVar: boolean, public name: string,\r\n        public expression: ASTWithSource) {}\r\n}\r\n\r\nexport interface AstVisitor {\r\n    visitBinary(ast: Binary, context: any): any;\r\n    visitChain(ast: Chain, context: any): any;\r\n    visitConditional(ast: Conditional, context: any): any;\r\n    visitFunctionCall(ast: FunctionCall, context: any): any;\r\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\r\n    visitInterpolation(ast: Interpolation, context: any): any;\r\n    visitKeyedRead(ast: KeyedRead, context: any): any;\r\n    visitKeyedWrite(ast: KeyedWrite, context: any): any;\r\n    visitLiteralArray(ast: LiteralArray, context: any): any;\r\n    visitLiteralMap(ast: LiteralMap, context: any): any;\r\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\r\n    visitMethodCall(ast: MethodCall, context: any): any;\r\n    visitPipe(ast: BindingPipe, context: any): any;\r\n    visitPrefixNot(ast: PrefixNot, context: any): any;\r\n    visitPropertyRead(ast: PropertyRead, context: any): any;\r\n    visitPropertyWrite(ast: PropertyWrite, context: any): any;\r\n    visitQuote(ast: Quote, context: any): any;\r\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\r\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\r\n}\r\n\r\nexport class RecursiveAstVisitor implements AstVisitor {\r\n    visitBinary(ast: Binary, context: any): any {\r\n        ast.left.visit(this);\r\n        ast.right.visit(this);\r\n        return null;\r\n    }\r\n    visitChain(ast: Chain, context: any): any { return this.visitAll(ast.expressions, context); }\r\n    visitConditional(ast: Conditional, context: any): any {\r\n        ast.condition.visit(this);\r\n        ast.trueExp.visit(this);\r\n        ast.falseExp.visit(this);\r\n        return null;\r\n    }\r\n    visitPipe(ast: BindingPipe, context: any): any {\r\n        ast.exp.visit(this);\r\n        this.visitAll(ast.args, context);\r\n        return null;\r\n    }\r\n    visitFunctionCall(ast: FunctionCall, context: any): any {\r\n        ast.target.visit(this);\r\n        this.visitAll(ast.args, context);\r\n        return null;\r\n    }\r\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any { return null; }\r\n    visitInterpolation(ast: Interpolation, context: any): any {\r\n        return this.visitAll(ast.expressions, context);\r\n    }\r\n    visitKeyedRead(ast: KeyedRead, context: any): any {\r\n        ast.obj.visit(this);\r\n        ast.key.visit(this);\r\n        return null;\r\n    }\r\n    visitKeyedWrite(ast: KeyedWrite, context: any): any {\r\n        ast.obj.visit(this);\r\n        ast.key.visit(this);\r\n        ast.value.visit(this);\r\n        return null;\r\n    }\r\n    visitLiteralArray(ast: LiteralArray, context: any): any {\r\n        return this.visitAll(ast.expressions, context);\r\n    }\r\n    visitLiteralMap(ast: LiteralMap, context: any): any { return this.visitAll(ast.values, context); }\r\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any { return null; }\r\n    visitMethodCall(ast: MethodCall, context: any): any {\r\n        ast.receiver.visit(this);\r\n        return this.visitAll(ast.args, context);\r\n    }\r\n    visitPrefixNot(ast: PrefixNot, context: any): any {\r\n        ast.expression.visit(this);\r\n        return null;\r\n    }\r\n    visitPropertyRead(ast: PropertyRead, context: any): any {\r\n        ast.receiver.visit(this);\r\n        return null;\r\n    }\r\n    visitPropertyWrite(ast: PropertyWrite, context: any): any {\r\n        ast.receiver.visit(this);\r\n        ast.value.visit(this);\r\n        return null;\r\n    }\r\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\r\n        ast.receiver.visit(this);\r\n        return null;\r\n    }\r\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\r\n        ast.receiver.visit(this);\r\n        return this.visitAll(ast.args, context);\r\n    }\r\n    visitAll(asts: AST[], context: any): any {\r\n        asts.forEach(ast => ast.visit(this, context));\r\n        return null;\r\n    }\r\n    visitQuote(ast: Quote, context: any): any { return null; }\r\n}\r\n\r\nexport class AstTransformer implements AstVisitor {\r\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST { return ast; }\r\n\r\n    visitInterpolation(ast: Interpolation, context: any): AST {\r\n        return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\r\n    }\r\n\r\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\r\n        return new LiteralPrimitive(ast.span, ast.value);\r\n    }\r\n\r\n    visitPropertyRead(ast: PropertyRead, context: any): AST {\r\n        return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\r\n    }\r\n\r\n    visitPropertyWrite(ast: PropertyWrite, context: any): AST {\r\n        return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value);\r\n    }\r\n\r\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\r\n        return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\r\n    }\r\n\r\n    visitMethodCall(ast: MethodCall, context: any): AST {\r\n        return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\r\n    }\r\n\r\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\r\n        return new SafeMethodCall(\r\n            ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\r\n    }\r\n\r\n    visitFunctionCall(ast: FunctionCall, context: any): AST {\r\n        return new FunctionCall(ast.span, ast.target.visit(this), this.visitAll(ast.args));\r\n    }\r\n\r\n    visitLiteralArray(ast: LiteralArray, context: any): AST {\r\n        return new LiteralArray(ast.span, this.visitAll(ast.expressions));\r\n    }\r\n\r\n    visitLiteralMap(ast: LiteralMap, context: any): AST {\r\n        return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\r\n    }\r\n\r\n    visitBinary(ast: Binary, context: any): AST {\r\n        return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\r\n    }\r\n\r\n    visitPrefixNot(ast: PrefixNot, context: any): AST {\r\n        return new PrefixNot(ast.span, ast.expression.visit(this));\r\n    }\r\n\r\n    visitConditional(ast: Conditional, context: any): AST {\r\n        return new Conditional(\r\n            ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\r\n    }\r\n\r\n    visitPipe(ast: BindingPipe, context: any): AST {\r\n        return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\r\n    }\r\n\r\n    visitKeyedRead(ast: KeyedRead, context: any): AST {\r\n        return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\r\n    }\r\n\r\n    visitKeyedWrite(ast: KeyedWrite, context: any): AST {\r\n        return new KeyedWrite(\r\n            ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\r\n    }\r\n\r\n    visitAll(asts: any[]): any[] {\r\n        const res = new Array(asts.length);\r\n        for (let i = 0; i < asts.length; ++i) {\r\n            res[i] = asts[i].visit(this);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    visitChain(ast: Chain, context: any): AST {\r\n        return new Chain(ast.span, this.visitAll(ast.expressions));\r\n    }\r\n\r\n    visitQuote(ast: Quote, context: any): AST {\r\n        return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\r\n    }\r\n}","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nexport const $EOF = 0;\r\nexport const $TAB = 9;\r\nexport const $LF = 10;\r\nexport const $VTAB = 11;\r\nexport const $FF = 12;\r\nexport const $CR = 13;\r\nexport const $SPACE = 32;\r\nexport const $BANG = 33;\r\nexport const $DQ = 34;\r\nexport const $HASH = 35;\r\nexport const $$ = 36;\r\nexport const $PERCENT = 37;\r\nexport const $AMPERSAND = 38;\r\nexport const $SQ = 39;\r\nexport const $LPAREN = 40;\r\nexport const $RPAREN = 41;\r\nexport const $STAR = 42;\r\nexport const $PLUS = 43;\r\nexport const $COMMA = 44;\r\nexport const $MINUS = 45;\r\nexport const $PERIOD = 46;\r\nexport const $SLASH = 47;\r\nexport const $COLON = 58;\r\nexport const $SEMICOLON = 59;\r\nexport const $LT = 60;\r\nexport const $EQ = 61;\r\nexport const $GT = 62;\r\nexport const $QUESTION = 63;\r\n\r\nexport const $0 = 48;\r\nexport const $9 = 57;\r\n\r\nexport const $A = 65;\r\nexport const $E = 69;\r\nexport const $F = 70;\r\nexport const $X = 88;\r\nexport const $Z = 90;\r\n\r\nexport const $LBRACKET = 91;\r\nexport const $BACKSLASH = 92;\r\nexport const $RBRACKET = 93;\r\nexport const $CARET = 94;\r\nexport const $_ = 95;\r\n\r\nexport const $a = 97;\r\nexport const $e = 101;\r\nexport const $f = 102;\r\nexport const $n = 110;\r\nexport const $r = 114;\r\nexport const $t = 116;\r\nexport const $u = 117;\r\nexport const $v = 118;\r\nexport const $x = 120;\r\nexport const $z = 122;\r\n\r\nexport const $LBRACE = 123;\r\nexport const $BAR = 124;\r\nexport const $RBRACE = 125;\r\nexport const $NBSP = 160;\r\n\r\nexport const $PIPE = 124;\r\nexport const $TILDA = 126;\r\nexport const $AT = 64;\r\n\r\nexport const $BT = 96;\r\n\r\nexport function isWhitespace(code: number): boolean {\r\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\r\n}\r\n\r\nexport function isDigit(code: number): boolean {\r\n    return $0 <= code && code <= $9;\r\n}\r\n\r\nexport function isAsciiLetter(code: number): boolean {\r\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\r\n}\r\n\r\nexport function isAsciiHexDigit(code: number): boolean {\r\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\r\n}","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n\r\nimport {isBlank, isPresent} from '../facade/lang';\r\n\r\nconst isDevMode = () => false;\r\n\r\nexport function assertArrayOfStrings(identifier: string, value: any) {\r\n    if (!isDevMode() || isBlank(value)) {\r\n        return;\r\n    }\r\n    if (!Array.isArray(value)) {\r\n        throw new Error(`Expected '${identifier}' to be an array of strings.`);\r\n    }\r\n    for (let i = 0; i < value.length; i += 1) {\r\n        if (typeof value[i] !== 'string') {\r\n            throw new Error(`Expected '${identifier}' to be an array of strings.`);\r\n        }\r\n    }\r\n}\r\n\r\nconst INTERPOLATION_BLACKLIST_REGEXPS = [\r\n    /^\\s*$/,        // empty\r\n    /[<>]/,         // html tag\r\n    /^[{}]$/,       // i18n expansion\r\n    /&(#|[a-z])/i,  // character reference,\r\n    /^\\/\\//,        // comment\r\n];\r\n\r\nexport function assertInterpolationSymbols(identifier: string, value: any): void {\r\n    if (isPresent(value) && !(Array.isArray(value) && value.length == 2)) {\r\n        throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\r\n    } else if (isDevMode() && !isBlank(value)) {\r\n        const start = value[0] as string;\r\n        const end = value[1] as string;\r\n        // black list checking\r\n        INTERPOLATION_BLACKLIST_REGEXPS.forEach(regexp => {\r\n            if (regexp.test(start) || regexp.test(end)) {\r\n                throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\r\n            }\r\n        });\r\n    }\r\n}","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport {assertInterpolationSymbols} from './assertions';\r\n\r\nexport class InterpolationConfig {\r\n    static fromArray(markers: [string, string]): InterpolationConfig {\r\n        if (!markers) {\r\n            return DEFAULT_INTERPOLATION_CONFIG;\r\n        }\r\n\r\n        assertInterpolationSymbols('interpolation', markers);\r\n        return new InterpolationConfig(markers[0], markers[1]);\r\n    }\r\n\r\n    constructor(public start: string, public end: string){};\r\n}\r\n\r\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig =\r\n    new InterpolationConfig('{{', '}}');","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport * as chars from './chars';\r\nimport {NumberWrapper} from '../facade/lang';\r\n\r\nexport enum TokenType {\r\n    Character,\r\n    Identifier,\r\n    Keyword,\r\n    String,\r\n    Operator,\r\n    Number,\r\n    Error\r\n}\r\n\r\nconst KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\r\n\r\nexport class Lexer {\r\n    tokenize(text: string): Token[] {\r\n        const scanner = new _Scanner(text);\r\n        const tokens: Token[] = [];\r\n        let token = scanner.scanToken();\r\n        while (token != null) {\r\n            tokens.push(token);\r\n            token = scanner.scanToken();\r\n        }\r\n        return tokens;\r\n    }\r\n}\r\n\r\nexport class Token {\r\n    constructor(\r\n        public index: number, public type: TokenType, public numValue: number,\r\n        public strValue: string) {}\r\n\r\n    isCharacter(code: number): boolean {\r\n        return this.type == TokenType.Character && this.numValue == code;\r\n    }\r\n\r\n    isNumber(): boolean { return this.type == TokenType.Number; }\r\n\r\n    isString(): boolean { return this.type == TokenType.String; }\r\n\r\n    isOperator(operater: string): boolean {\r\n        return this.type == TokenType.Operator && this.strValue == operater;\r\n    }\r\n\r\n    isIdentifier(): boolean { return this.type == TokenType.Identifier; }\r\n\r\n    isKeyword(): boolean { return this.type == TokenType.Keyword; }\r\n\r\n    isKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\r\n\r\n    isKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\r\n\r\n    isKeywordUndefined(): boolean {\r\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\r\n    }\r\n\r\n    isKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\r\n\r\n    isKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\r\n\r\n    isKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\r\n\r\n    isError(): boolean { return this.type == TokenType.Error; }\r\n\r\n    toNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\r\n\r\n    toString(): string {\r\n        switch (this.type) {\r\n            case TokenType.Character:\r\n            case TokenType.Identifier:\r\n            case TokenType.Keyword:\r\n            case TokenType.Operator:\r\n            case TokenType.String:\r\n            case TokenType.Error:\r\n                return this.strValue;\r\n            case TokenType.Number:\r\n                return this.numValue.toString();\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n}\r\n\r\nfunction newCharacterToken(index: number, code: number): Token {\r\n    return new Token(index, TokenType.Character, code, String.fromCharCode(code));\r\n}\r\n\r\nfunction newIdentifierToken(index: number, text: string): Token {\r\n    return new Token(index, TokenType.Identifier, 0, text);\r\n}\r\n\r\nfunction newKeywordToken(index: number, text: string): Token {\r\n    return new Token(index, TokenType.Keyword, 0, text);\r\n}\r\n\r\nfunction newOperatorToken(index: number, text: string): Token {\r\n    return new Token(index, TokenType.Operator, 0, text);\r\n}\r\n\r\nfunction newStringToken(index: number, text: string): Token {\r\n    return new Token(index, TokenType.String, 0, text);\r\n}\r\n\r\nfunction newNumberToken(index: number, n: number): Token {\r\n    return new Token(index, TokenType.Number, n, '');\r\n}\r\n\r\nfunction newErrorToken(index: number, message: string): Token {\r\n    return new Token(index, TokenType.Error, 0, message);\r\n}\r\n\r\nexport const EOF: Token = new Token(-1, TokenType.Character, 0, '');\r\n\r\nclass _Scanner {\r\n    length: number;\r\n    peek: number = 0;\r\n    index: number = -1;\r\n\r\n    constructor(public input: string) {\r\n        this.length = input.length;\r\n        this.advance();\r\n    }\r\n\r\n    advance() {\r\n        this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\r\n    }\r\n\r\n    scanToken(): Token {\r\n        const input = this.input, length = this.length;\r\n        let peek = this.peek, index = this.index;\r\n\r\n        // Skip whitespace.\r\n        while (peek <= chars.$SPACE) {\r\n            if (++index >= length) {\r\n                peek = chars.$EOF;\r\n                break;\r\n            } else {\r\n                peek = input.charCodeAt(index);\r\n            }\r\n        }\r\n\r\n        this.peek = peek;\r\n        this.index = index;\r\n\r\n        if (index >= length) {\r\n            return null;\r\n        }\r\n\r\n        // Handle identifiers and numbers.\r\n        if (isIdentifierStart(peek)) return this.scanIdentifier();\r\n        if (chars.isDigit(peek)) return this.scanNumber(index);\r\n\r\n        const start: number = index;\r\n        switch (peek) {\r\n            case chars.$PERIOD:\r\n                this.advance();\r\n                return chars.isDigit(this.peek) ? this.scanNumber(start) :\r\n                    newCharacterToken(start, chars.$PERIOD);\r\n            case chars.$LPAREN:\r\n            case chars.$RPAREN:\r\n            case chars.$LBRACE:\r\n            case chars.$RBRACE:\r\n            case chars.$LBRACKET:\r\n            case chars.$RBRACKET:\r\n            case chars.$COMMA:\r\n            case chars.$COLON:\r\n            case chars.$SEMICOLON:\r\n                return this.scanCharacter(start, peek);\r\n            case chars.$SQ:\r\n            case chars.$DQ:\r\n                return this.scanString();\r\n            case chars.$HASH:\r\n            case chars.$PLUS:\r\n            case chars.$MINUS:\r\n            case chars.$STAR:\r\n            case chars.$SLASH:\r\n            case chars.$PERCENT:\r\n            case chars.$CARET:\r\n                return this.scanOperator(start, String.fromCharCode(peek));\r\n            case chars.$QUESTION:\r\n                return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\r\n            case chars.$LT:\r\n            case chars.$GT:\r\n                return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\r\n            case chars.$BANG:\r\n            case chars.$EQ:\r\n                return this.scanComplexOperator(\r\n                    start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\r\n            case chars.$AMPERSAND:\r\n                return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\r\n            case chars.$BAR:\r\n                return this.scanComplexOperator(start, '|', chars.$BAR, '|');\r\n            case chars.$NBSP:\r\n                while (chars.isWhitespace(this.peek)) this.advance();\r\n                return this.scanToken();\r\n        }\r\n\r\n        this.advance();\r\n        return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\r\n    }\r\n\r\n    scanCharacter(start: number, code: number): Token {\r\n        this.advance();\r\n        return newCharacterToken(start, code);\r\n    }\r\n\r\n\r\n    scanOperator(start: number, str: string): Token {\r\n        this.advance();\r\n        return newOperatorToken(start, str);\r\n    }\r\n\r\n    /**\r\n     * Tokenize a 2/3 char long operator\r\n     *\r\n     * @param start start index in the expression\r\n     * @param one first symbol (always part of the operator)\r\n     * @param twoCode code point for the second symbol\r\n     * @param two second symbol (part of the operator when the second code point matches)\r\n     * @param threeCode code point for the third symbol\r\n     * @param three third symbol (part of the operator when provided and matches source expression)\r\n     * @returns {Token}\r\n     */\r\n    scanComplexOperator(\r\n        start: number, one: string, twoCode: number, two: string, threeCode?: number,\r\n        three?: string): Token {\r\n        this.advance();\r\n        let str: string = one;\r\n        if (this.peek == twoCode) {\r\n            this.advance();\r\n            str += two;\r\n        }\r\n        if (threeCode != null && this.peek == threeCode) {\r\n            this.advance();\r\n            str += three;\r\n        }\r\n        return newOperatorToken(start, str);\r\n    }\r\n\r\n    scanIdentifier(): Token {\r\n        const start: number = this.index;\r\n        this.advance();\r\n        while (isIdentifierPart(this.peek)) this.advance();\r\n        const str: string = this.input.substring(start, this.index);\r\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\r\n            newIdentifierToken(start, str);\r\n    }\r\n\r\n    scanNumber(start: number): Token {\r\n        let simple: boolean = (this.index === start);\r\n        this.advance();  // Skip initial digit.\r\n        while (true) {\r\n            if (chars.isDigit(this.peek)) {\r\n                // Do nothing.\r\n            } else if (this.peek == chars.$PERIOD) {\r\n                simple = false;\r\n            } else if (isExponentStart(this.peek)) {\r\n                this.advance();\r\n                if (isExponentSign(this.peek)) this.advance();\r\n                if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\r\n                simple = false;\r\n            } else {\r\n                break;\r\n            }\r\n            this.advance();\r\n        }\r\n        const str: string = this.input.substring(start, this.index);\r\n        const value: number = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);\r\n        return newNumberToken(start, value);\r\n    }\r\n\r\n    scanString(): Token {\r\n        const start: number = this.index;\r\n        const quote: number = this.peek;\r\n        this.advance();  // Skip initial quote.\r\n\r\n        let buffer: string = '';\r\n        let marker: number = this.index;\r\n        const input: string = this.input;\r\n\r\n        while (this.peek != quote) {\r\n            if (this.peek == chars.$BACKSLASH) {\r\n                buffer += input.substring(marker, this.index);\r\n                this.advance();\r\n                let unescapedCode: number;\r\n                // Workaround for TS2.1-introduced type strictness\r\n                this.peek = this.peek;\r\n                if (this.peek == chars.$u) {\r\n                    // 4 character hex code for unicode character.\r\n                    const hex: string = input.substring(this.index + 1, this.index + 5);\r\n                    if (/^[0-9a-f]+$/i.test(hex)) {\r\n                        unescapedCode = parseInt(hex, 16);\r\n                    } else {\r\n                        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\r\n                    }\r\n                    for (let i: number = 0; i < 5; i++) {\r\n                        this.advance();\r\n                    }\r\n                } else {\r\n                    unescapedCode = unescape(this.peek);\r\n                    this.advance();\r\n                }\r\n                buffer += String.fromCharCode(unescapedCode);\r\n                marker = this.index;\r\n            } else if (this.peek == chars.$EOF) {\r\n                return this.error('Unterminated quote', 0);\r\n            } else {\r\n                this.advance();\r\n            }\r\n        }\r\n\r\n        const last: string = input.substring(marker, this.index);\r\n        this.advance();  // Skip terminating quote.\r\n\r\n        return newStringToken(start, buffer + last);\r\n    }\r\n\r\n    error(message: string, offset: number): Token {\r\n        const position: number = this.index + offset;\r\n        return newErrorToken(\r\n            position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\r\n    }\r\n}\r\n\r\nfunction isIdentifierStart(code: number): boolean {\r\n    return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\r\n        (code == chars.$_) || (code == chars.$$);\r\n}\r\n\r\nexport function isIdentifier(input: string): boolean {\r\n    if (input.length == 0) return false;\r\n    const scanner = new _Scanner(input);\r\n    if (!isIdentifierStart(scanner.peek)) return false;\r\n    scanner.advance();\r\n    while (scanner.peek !== chars.$EOF) {\r\n        if (!isIdentifierPart(scanner.peek)) return false;\r\n        scanner.advance();\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction isIdentifierPart(code: number): boolean {\r\n    return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\r\n        (code == chars.$$);\r\n}\r\n\r\nfunction isExponentStart(code: number): boolean {\r\n    return code == chars.$e || code == chars.$E;\r\n}\r\n\r\nfunction isExponentSign(code: number): boolean {\r\n    return code == chars.$MINUS || code == chars.$PLUS;\r\n}\r\n\r\nexport function isQuote(code: number): boolean {\r\n    return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\r\n}\r\n\r\nfunction unescape(code: number): number {\r\n    switch (code) {\r\n        case chars.$n:\r\n            return chars.$LF;\r\n        case chars.$f:\r\n            return chars.$FF;\r\n        case chars.$r:\r\n            return chars.$CR;\r\n        case chars.$t:\r\n            return chars.$TAB;\r\n        case chars.$v:\r\n            return chars.$VTAB;\r\n        default:\r\n            return code;\r\n    }\r\n}","/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nimport * as chars from './chars';\r\nimport {escapeRegExp, isBlank, isPresent} from '../facade/lang';\r\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './interpolation-config';\r\n\r\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, ParseSpan, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, TemplateBinding} from './ast';\r\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from './lexer';\r\n\r\n\r\nexport class SplitInterpolation {\r\n    constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\r\n}\r\n\r\nexport class TemplateBindingParseResult {\r\n    constructor(\r\n        public templateBindings: TemplateBinding[], public warnings: string[],\r\n        public errors: ParserError[]) {}\r\n}\r\n\r\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\r\n    const pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\r\n    return new RegExp(pattern, 'g');\r\n}\r\n\r\nexport class Parser {\r\n    private errors: ParserError[] = [];\r\n\r\n    constructor(private _lexer: Lexer) {}\r\n\r\n    parseAction(\r\n        input: string, location: any,\r\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\r\n        this._checkNoInterpolation(input, location, interpolationConfig);\r\n        const sourceToLex = this._stripComments(input);\r\n        const tokens = this._lexer.tokenize(this._stripComments(input));\r\n        const ast = new _ParseAST(\r\n            input, location, tokens, sourceToLex.length, true, this.errors,\r\n            input.length - sourceToLex.length)\r\n            .parseChain();\r\n        return new ASTWithSource(ast, input, location, this.errors);\r\n    }\r\n\r\n    parseBinding(\r\n        input: string, location: any,\r\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\r\n        const ast = this._parseBindingAst(input, location, interpolationConfig);\r\n        return new ASTWithSource(ast, input, location, this.errors);\r\n    }\r\n\r\n    parseSimpleBinding(\r\n        input: string, location: string,\r\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\r\n        const ast = this._parseBindingAst(input, location, interpolationConfig);\r\n        const errors = SimpleExpressionChecker.check(ast);\r\n        if (errors.length > 0) {\r\n            this._reportError(\r\n                `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\r\n        }\r\n        return new ASTWithSource(ast, input, location, this.errors);\r\n    }\r\n\r\n    private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\r\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\r\n    }\r\n\r\n    private _parseBindingAst(\r\n        input: string, location: string, interpolationConfig: InterpolationConfig): AST {\r\n        // Quotes expressions use 3rd-party expression language. We don't want to use\r\n        // our lexer or parser for that, so we check for that ahead of time.\r\n        const quote = this._parseQuote(input, location);\r\n\r\n        if (isPresent(quote)) {\r\n            return quote;\r\n        }\r\n\r\n        this._checkNoInterpolation(input, location, interpolationConfig);\r\n        const sourceToLex = this._stripComments(input);\r\n        const tokens = this._lexer.tokenize(sourceToLex);\r\n        return new _ParseAST(\r\n            input, location, tokens, sourceToLex.length, false, this.errors,\r\n            input.length - sourceToLex.length)\r\n            .parseChain();\r\n    }\r\n\r\n    private _parseQuote(input: string, location: any): AST {\r\n        if (isBlank(input)) return null;\r\n        const prefixSeparatorIndex = input.indexOf(':');\r\n        if (prefixSeparatorIndex == -1) return null;\r\n        const prefix = input.substring(0, prefixSeparatorIndex).trim();\r\n        if (!isIdentifier(prefix)) return null;\r\n        const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\r\n        return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\r\n    }\r\n\r\n    parseTemplateBindings(prefixToken: string, input: string, location: any):\r\n    TemplateBindingParseResult {\r\n        const tokens = this._lexer.tokenize(input);\r\n        if (prefixToken) {\r\n            // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\r\n            const prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\r\n                t.index = 0;\r\n                return t;\r\n            });\r\n            tokens.unshift(...prefixTokens);\r\n        }\r\n        return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\r\n            .parseTemplateBindings();\r\n    }\r\n\r\n    parseInterpolation(\r\n        input: string, location: any,\r\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\r\n        const split = this.splitInterpolation(input, location, interpolationConfig);\r\n        if (split == null) return null;\r\n\r\n        const expressions: AST[] = [];\r\n\r\n        for (let i = 0; i < split.expressions.length; ++i) {\r\n            const expressionText = split.expressions[i];\r\n            const sourceToLex = this._stripComments(expressionText);\r\n            const tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));\r\n            const ast = new _ParseAST(\r\n                input, location, tokens, sourceToLex.length, false, this.errors,\r\n                split.offsets[i] + (expressionText.length - sourceToLex.length))\r\n                .parseChain();\r\n            expressions.push(ast);\r\n        }\r\n\r\n        return new ASTWithSource(\r\n            new Interpolation(\r\n                new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions),\r\n            input, location, this.errors);\r\n    }\r\n\r\n    splitInterpolation(\r\n        input: string, location: string,\r\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\r\n        const regexp = _createInterpolateRegExp(interpolationConfig);\r\n        const parts = input.split(regexp);\r\n        if (parts.length <= 1) {\r\n            return null;\r\n        }\r\n        const strings: string[] = [];\r\n        const expressions: string[] = [];\r\n        const offsets: number[] = [];\r\n        let offset = 0;\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part: string = parts[i];\r\n            if (i % 2 === 0) {\r\n                // fixed string\r\n                strings.push(part);\r\n                offset += part.length;\r\n            } else if (part.trim().length > 0) {\r\n                offset += interpolationConfig.start.length;\r\n                expressions.push(part);\r\n                offsets.push(offset);\r\n                offset += part.length + interpolationConfig.end.length;\r\n            } else {\r\n                this._reportError(\r\n                    'Blank expressions are not allowed in interpolated strings', input,\r\n                    `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\r\n                    location);\r\n                expressions.push('$implict');\r\n                offsets.push(offset);\r\n            }\r\n        }\r\n        return new SplitInterpolation(strings, expressions, offsets);\r\n    }\r\n\r\n    wrapLiteralPrimitive(input: string, location: any): ASTWithSource {\r\n        return new ASTWithSource(\r\n            new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input,\r\n            location, this.errors);\r\n    }\r\n\r\n    private _stripComments(input: string): string {\r\n        const i = this._commentStart(input);\r\n        return isPresent(i) ? input.substring(0, i).trim() : input;\r\n    }\r\n\r\n    private _commentStart(input: string): number {\r\n        let outerQuote: number = null;\r\n        for (let i = 0; i < input.length - 1; i++) {\r\n            const char = input.charCodeAt(i);\r\n            const nextChar = input.charCodeAt(i + 1);\r\n\r\n            if (char === chars.$SLASH && nextChar == chars.$SLASH && isBlank(outerQuote)) return i;\r\n\r\n            if (outerQuote === char) {\r\n                outerQuote = null;\r\n            } else if (isBlank(outerQuote) && isQuote(char)) {\r\n                outerQuote = char;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private _checkNoInterpolation(\r\n        input: string, location: any, interpolationConfig: InterpolationConfig): void {\r\n        const regexp = _createInterpolateRegExp(interpolationConfig);\r\n        const parts = input.split(regexp);\r\n        if (parts.length > 1) {\r\n            this._reportError(\r\n                `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\r\n                input,\r\n                `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\r\n                location);\r\n        }\r\n    }\r\n\r\n    private _findInterpolationErrorColumn(\r\n        parts: string[], partInErrIdx: number, interpolationConfig: InterpolationConfig): number {\r\n        let errLocation = '';\r\n        for (let j = 0; j < partInErrIdx; j++) {\r\n            errLocation += j % 2 === 0 ?\r\n                parts[j] :\r\n                `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\r\n        }\r\n\r\n        return errLocation.length;\r\n    }\r\n}\r\n\r\nexport class _ParseAST {\r\n    private rparensExpected = 0;\r\n    private rbracketsExpected = 0;\r\n    private rbracesExpected = 0;\r\n\r\n    index: number = 0;\r\n\r\n    constructor(\r\n        public input: string, public location: any, public tokens: Token[],\r\n        public inputLength: number, public parseAction: boolean, private errors: ParserError[],\r\n        private offset: number) {}\r\n\r\n    peek(offset: number): Token {\r\n        const i = this.index + offset;\r\n        return i < this.tokens.length ? this.tokens[i] : EOF;\r\n    }\r\n\r\n    get next(): Token { return this.peek(0); }\r\n\r\n    get inputIndex(): number {\r\n        return (this.index < this.tokens.length) ? this.next.index + this.offset :\r\n            this.inputLength + this.offset;\r\n    }\r\n\r\n    span(start: number) { return new ParseSpan(start, this.inputIndex); }\r\n\r\n    advance() { this.index++; }\r\n\r\n    optionalCharacter(code: number): boolean {\r\n        if (this.next.isCharacter(code)) {\r\n            this.advance();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    peekKeywordLet(): boolean { return this.next.isKeywordLet(); }\r\n\r\n    expectCharacter(code: number) {\r\n        if (this.optionalCharacter(code)) return;\r\n        this.error(`Missing expected ${String.fromCharCode(code)}`);\r\n    }\r\n\r\n    optionalOperator(op: string): boolean {\r\n        if (this.next.isOperator(op)) {\r\n            this.advance();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    expectOperator(operator: string) {\r\n        if (this.optionalOperator(operator)) return;\r\n        this.error(`Missing expected operator ${operator}`);\r\n    }\r\n\r\n    expectIdentifierOrKeyword(): string {\r\n        const n = this.next;\r\n        if (!n.isIdentifier() && !n.isKeyword()) {\r\n            this.error(`Unexpected token ${n}, expected identifier or keyword`);\r\n            return '';\r\n        }\r\n        this.advance();\r\n        return n.toString();\r\n    }\r\n\r\n    expectIdentifierOrKeywordOrString(): string {\r\n        const n = this.next;\r\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\r\n            this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\r\n            return '';\r\n        }\r\n        this.advance();\r\n        return n.toString();\r\n    }\r\n\r\n    parseChain(): AST {\r\n        const exprs: AST[] = [];\r\n        const start = this.inputIndex;\r\n        while (this.index < this.tokens.length) {\r\n            const expr = this.parsePipe();\r\n            exprs.push(expr);\r\n\r\n            if (this.optionalCharacter(chars.$SEMICOLON)) {\r\n                if (!this.parseAction) {\r\n                    this.error('Binding expression cannot contain chained expression');\r\n                }\r\n                while (this.optionalCharacter(chars.$SEMICOLON)) {\r\n                }  // read all semicolons\r\n            } else if (this.index < this.tokens.length) {\r\n                this.error(`Unexpected token '${this.next}'`);\r\n            }\r\n        }\r\n        if (exprs.length == 0) return new EmptyExpr(this.span(start));\r\n        if (exprs.length == 1) return exprs[0];\r\n        return new Chain(this.span(start), exprs);\r\n    }\r\n\r\n    parsePipe(): AST {\r\n        let result = this.parseExpression();\r\n        if (this.optionalOperator('|')) {\r\n            if (this.parseAction) {\r\n                this.error('Cannot have a pipe in an action expression');\r\n            }\r\n\r\n            do {\r\n                const name = this.expectIdentifierOrKeyword();\r\n                const args: AST[] = [];\r\n                while (this.optionalCharacter(chars.$COLON)) {\r\n                    args.push(this.parseExpression());\r\n                }\r\n                result = new BindingPipe(this.span(result.span.start), result, name, args);\r\n            } while (this.optionalOperator('|'));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    parseExpression(): AST { return this.parseConditional(); }\r\n\r\n    parseConditional(): AST {\r\n        const start = this.inputIndex;\r\n        const result = this.parseLogicalOr();\r\n\r\n        if (this.optionalOperator('?')) {\r\n            const yes = this.parsePipe();\r\n            let no: AST;\r\n            if (!this.optionalCharacter(chars.$COLON)) {\r\n                const end = this.inputIndex;\r\n                const expression = this.input.substring(start, end);\r\n                this.error(`Conditional expression ${expression} requires all 3 expressions`);\r\n                no = new EmptyExpr(this.span(start));\r\n            } else {\r\n                no = this.parsePipe();\r\n            }\r\n            return new Conditional(this.span(start), result, yes, no);\r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    parseLogicalOr(): AST {\r\n        // '||'\r\n        let result = this.parseLogicalAnd();\r\n        while (this.optionalOperator('||')) {\r\n            const right = this.parseLogicalAnd();\r\n            result = new Binary(this.span(result.span.start), '||', result, right);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    parseLogicalAnd(): AST {\r\n        // '&&'\r\n        let result = this.parseEquality();\r\n        while (this.optionalOperator('&&')) {\r\n            const right = this.parseEquality();\r\n            result = new Binary(this.span(result.span.start), '&&', result, right);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    parseEquality(): AST {\r\n        // '==','!=','===','!=='\r\n        let result = this.parseRelational();\r\n        while (this.next.type == TokenType.Operator) {\r\n            const operator = this.next.strValue;\r\n            switch (operator) {\r\n                case '==':\r\n                case '===':\r\n                case '!=':\r\n                case '!==':\r\n                    this.advance();\r\n                    const right = this.parseRelational();\r\n                    result = new Binary(this.span(result.span.start), operator, result, right);\r\n                    continue;\r\n            }\r\n            break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    parseRelational(): AST {\r\n        // '<', '>', '<=', '>='\r\n        let result = this.parseAdditive();\r\n        while (this.next.type == TokenType.Operator) {\r\n            const operator = this.next.strValue;\r\n            switch (operator) {\r\n                case '<':\r\n                case '>':\r\n                case '<=':\r\n                case '>=':\r\n                    this.advance();\r\n                    const right = this.parseAdditive();\r\n                    result = new Binary(this.span(result.span.start), operator, result, right);\r\n                    continue;\r\n            }\r\n            break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    parseAdditive(): AST {\r\n        // '+', '-'\r\n        let result = this.parseMultiplicative();\r\n        while (this.next.type == TokenType.Operator) {\r\n            const operator = this.next.strValue;\r\n            switch (operator) {\r\n                case '+':\r\n                case '-':\r\n                    this.advance();\r\n                    let right = this.parseMultiplicative();\r\n                    result = new Binary(this.span(result.span.start), operator, result, right);\r\n                    continue;\r\n            }\r\n            break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    parseMultiplicative(): AST {\r\n        // '*', '%', '/'\r\n        let result = this.parsePrefix();\r\n        while (this.next.type == TokenType.Operator) {\r\n            const operator = this.next.strValue;\r\n            switch (operator) {\r\n                case '*':\r\n                case '%':\r\n                case '/':\r\n                    this.advance();\r\n                    let right = this.parsePrefix();\r\n                    result = new Binary(this.span(result.span.start), operator, result, right);\r\n                    continue;\r\n            }\r\n            break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    parsePrefix(): AST {\r\n        if (this.next.type == TokenType.Operator) {\r\n            const start = this.inputIndex;\r\n            const operator = this.next.strValue;\r\n            let result: AST;\r\n            switch (operator) {\r\n                case '+':\r\n                    this.advance();\r\n                    return this.parsePrefix();\r\n                case '-':\r\n                    this.advance();\r\n                    result = this.parsePrefix();\r\n                    return new Binary(\r\n                        this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0),\r\n                        result);\r\n                case '!':\r\n                    this.advance();\r\n                    result = this.parsePrefix();\r\n                    return new PrefixNot(this.span(start), result);\r\n            }\r\n        }\r\n        return this.parseCallChain();\r\n    }\r\n\r\n    parseCallChain(): AST {\r\n        let result = this.parsePrimary();\r\n        while (true) {\r\n            if (this.optionalCharacter(chars.$PERIOD)) {\r\n                result = this.parseAccessMemberOrMethodCall(result, false);\r\n\r\n            } else if (this.optionalOperator('?.')) {\r\n                result = this.parseAccessMemberOrMethodCall(result, true);\r\n\r\n            } else if (this.optionalCharacter(chars.$LBRACKET)) {\r\n                this.rbracketsExpected++;\r\n                const key = this.parsePipe();\r\n                this.rbracketsExpected--;\r\n                this.expectCharacter(chars.$RBRACKET);\r\n                if (this.optionalOperator('=')) {\r\n                    const value = this.parseConditional();\r\n                    result = new KeyedWrite(this.span(result.span.start), result, key, value);\r\n                } else {\r\n                    result = new KeyedRead(this.span(result.span.start), result, key);\r\n                }\r\n\r\n            } else if (this.optionalCharacter(chars.$LPAREN)) {\r\n                this.rparensExpected++;\r\n                const args = this.parseCallArguments();\r\n                this.rparensExpected--;\r\n                this.expectCharacter(chars.$RPAREN);\r\n                result = new FunctionCall(this.span(result.span.start), result, args);\r\n\r\n            } else {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n\r\n    parsePrimary(): AST {\r\n        const start = this.inputIndex;\r\n        if (this.optionalCharacter(chars.$LPAREN)) {\r\n            this.rparensExpected++;\r\n            const result = this.parsePipe();\r\n            this.rparensExpected--;\r\n            this.expectCharacter(chars.$RPAREN);\r\n            return result;\r\n\r\n        } else if (this.next.isKeywordNull()) {\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), null);\r\n\r\n        } else if (this.next.isKeywordUndefined()) {\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), void 0);\r\n\r\n        } else if (this.next.isKeywordTrue()) {\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), true);\r\n\r\n        } else if (this.next.isKeywordFalse()) {\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), false);\r\n\r\n        } else if (this.next.isKeywordThis()) {\r\n            this.advance();\r\n            return new ImplicitReceiver(this.span(start));\r\n\r\n        } else if (this.optionalCharacter(chars.$LBRACKET)) {\r\n            this.rbracketsExpected++;\r\n            const elements = this.parseExpressionList(chars.$RBRACKET);\r\n            this.rbracketsExpected--;\r\n            this.expectCharacter(chars.$RBRACKET);\r\n            return new LiteralArray(this.span(start), elements);\r\n\r\n        } else if (this.next.isCharacter(chars.$LBRACE)) {\r\n            return this.parseLiteralMap();\r\n\r\n        } else if (this.next.isIdentifier()) {\r\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\r\n\r\n        } else if (this.next.isNumber()) {\r\n            const value = this.next.toNumber();\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), value);\r\n\r\n        } else if (this.next.isString()) {\r\n            const literalValue = this.next.toString();\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), literalValue);\r\n\r\n        } else if (this.index >= this.tokens.length) {\r\n            this.error(`Unexpected end of expression: ${this.input}`);\r\n            return new EmptyExpr(this.span(start));\r\n        } else {\r\n            this.error(`Unexpected token ${this.next}`);\r\n            return new EmptyExpr(this.span(start));\r\n        }\r\n    }\r\n\r\n    parseExpressionList(terminator: number): AST[] {\r\n        const result: AST[] = [];\r\n        if (!this.next.isCharacter(terminator)) {\r\n            do {\r\n                result.push(this.parsePipe());\r\n            } while (this.optionalCharacter(chars.$COMMA));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    parseLiteralMap(): LiteralMap {\r\n        const keys: string[] = [];\r\n        const values: AST[] = [];\r\n        const start = this.inputIndex;\r\n        this.expectCharacter(chars.$LBRACE);\r\n        if (!this.optionalCharacter(chars.$RBRACE)) {\r\n            this.rbracesExpected++;\r\n            do {\r\n                const key = this.expectIdentifierOrKeywordOrString();\r\n                keys.push(key);\r\n                this.expectCharacter(chars.$COLON);\r\n                values.push(this.parsePipe());\r\n            } while (this.optionalCharacter(chars.$COMMA));\r\n            this.rbracesExpected--;\r\n            this.expectCharacter(chars.$RBRACE);\r\n        }\r\n        return new LiteralMap(this.span(start), keys, values);\r\n    }\r\n\r\n    parseAccessMemberOrMethodCall(receiver: AST, isSafe: boolean = false): AST {\r\n        const start = receiver.span.start;\r\n        const id = this.expectIdentifierOrKeyword();\r\n\r\n        if (this.optionalCharacter(chars.$LPAREN)) {\r\n            this.rparensExpected++;\r\n            const args = this.parseCallArguments();\r\n            this.expectCharacter(chars.$RPAREN);\r\n            this.rparensExpected--;\r\n            const span = this.span(start);\r\n            return isSafe ? new SafeMethodCall(span, receiver, id, args) :\r\n                new MethodCall(span, receiver, id, args);\r\n\r\n        } else {\r\n            if (isSafe) {\r\n                if (this.optionalOperator('=')) {\r\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\r\n                    return new EmptyExpr(this.span(start));\r\n                } else {\r\n                    return new SafePropertyRead(this.span(start), receiver, id);\r\n                }\r\n            } else {\r\n                if (this.optionalOperator('=')) {\r\n                    if (!this.parseAction) {\r\n                        this.error('Bindings cannot contain assignments');\r\n                        return new EmptyExpr(this.span(start));\r\n                    }\r\n\r\n                    const value = this.parseConditional();\r\n                    return new PropertyWrite(this.span(start), receiver, id, value);\r\n                } else {\r\n                    return new PropertyRead(this.span(start), receiver, id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    parseCallArguments(): BindingPipe[] {\r\n        if (this.next.isCharacter(chars.$RPAREN)) return [];\r\n        const positionals: AST[] = [];\r\n        do {\r\n            positionals.push(this.parsePipe());\r\n        } while (this.optionalCharacter(chars.$COMMA));\r\n        return positionals as BindingPipe[];\r\n    }\r\n\r\n    /**\r\n     * An identifier, a keyword, a string with an optional `-` inbetween.\r\n     */\r\n    expectTemplateBindingKey(): string {\r\n        let result = '';\r\n        let operatorFound = false;\r\n        do {\r\n            result += this.expectIdentifierOrKeywordOrString();\r\n            operatorFound = this.optionalOperator('-');\r\n            if (operatorFound) {\r\n                result += '-';\r\n            }\r\n        } while (operatorFound);\r\n\r\n        return result.toString();\r\n    }\r\n\r\n    parseTemplateBindings(): TemplateBindingParseResult {\r\n        const bindings: TemplateBinding[] = [];\r\n        let prefix: string = null;\r\n        const warnings: string[] = [];\r\n        while (this.index < this.tokens.length) {\r\n            const start = this.inputIndex;\r\n            const keyIsVar: boolean = this.peekKeywordLet();\r\n            if (keyIsVar) {\r\n                this.advance();\r\n            }\r\n            let key = this.expectTemplateBindingKey();\r\n            if (!keyIsVar) {\r\n                if (prefix == null) {\r\n                    prefix = key;\r\n                } else {\r\n                    key = prefix + key[0].toUpperCase() + key.substring(1);\r\n                }\r\n            }\r\n            this.optionalCharacter(chars.$COLON);\r\n            let name: string = null;\r\n            let expression: ASTWithSource = null;\r\n            if (keyIsVar) {\r\n                if (this.optionalOperator('=')) {\r\n                    name = this.expectTemplateBindingKey();\r\n                } else {\r\n                    name = '\\$implicit';\r\n                }\r\n            } else if (this.next !== EOF && !this.peekKeywordLet()) {\r\n                const start = this.inputIndex;\r\n                const ast = this.parsePipe();\r\n                const source = this.input.substring(start - this.offset, this.inputIndex - this.offset);\r\n                expression = new ASTWithSource(ast, source, this.location, this.errors);\r\n            }\r\n            bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\r\n            if (!this.optionalCharacter(chars.$SEMICOLON)) {\r\n                this.optionalCharacter(chars.$COMMA);\r\n            }\r\n        }\r\n        return new TemplateBindingParseResult(bindings, warnings, this.errors);\r\n    }\r\n\r\n    error(message: string, index: number = null) {\r\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\r\n        this.skip();\r\n    }\r\n\r\n    private locationText(index: number = null) {\r\n        if (isBlank(index)) index = this.index;\r\n        return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\r\n            `at the end of the expression`;\r\n    }\r\n\r\n    // Error recovery should skip tokens until it encounters a recovery point. skip() treats\r\n    // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\r\n    // '}' and ']' as conditional recovery points if one of calling productions is expecting\r\n    // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\r\n    // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\r\n    // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\r\n    // must be conditional as they must be skipped if none of the calling productions are not\r\n    // expecting the closing token else we will never make progress in the case of an\r\n    // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\r\n    // parseChain() is always the root production and it expects a ';'.\r\n\r\n    // If a production expects one of these token it increments the corresponding nesting count,\r\n    // and then decrements it just prior to checking if the token is in the input.\r\n    private skip() {\r\n        let n = this.next;\r\n        while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\r\n        (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\r\n        (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\r\n        (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\r\n            if (this.next.isError()) {\r\n                this.errors.push(\r\n                    new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\r\n            }\r\n            this.advance();\r\n            n = this.next;\r\n        }\r\n    }\r\n}\r\n\r\nclass SimpleExpressionChecker implements AstVisitor {\r\n    static check(ast: AST): string[] {\r\n        const s = new SimpleExpressionChecker();\r\n        ast.visit(s);\r\n        return s.errors;\r\n    }\r\n\r\n    errors: string[] = [];\r\n\r\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\r\n\r\n    visitInterpolation(ast: Interpolation, context: any) {}\r\n\r\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\r\n\r\n    visitPropertyRead(ast: PropertyRead, context: any) {}\r\n\r\n    visitPropertyWrite(ast: PropertyWrite, context: any) {}\r\n\r\n    visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\r\n\r\n    visitMethodCall(ast: MethodCall, context: any) {}\r\n\r\n    visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\r\n\r\n    visitFunctionCall(ast: FunctionCall, context: any) {}\r\n\r\n    visitLiteralArray(ast: LiteralArray, context: any) { this.visitAll(ast.expressions); }\r\n\r\n    visitLiteralMap(ast: LiteralMap, context: any) { this.visitAll(ast.values); }\r\n\r\n    visitBinary(ast: Binary, context: any) {}\r\n\r\n    visitPrefixNot(ast: PrefixNot, context: any) {}\r\n\r\n    visitConditional(ast: Conditional, context: any) {}\r\n\r\n    visitPipe(ast: BindingPipe, context: any) { this.errors.push('pipes'); }\r\n\r\n    visitKeyedRead(ast: KeyedRead, context: any) {}\r\n\r\n    visitKeyedWrite(ast: KeyedWrite, context: any) {}\r\n\r\n    visitAll(asts: any[]): any[] { return asts.map(node => node.visit(this)); }\r\n\r\n    visitChain(ast: Chain, context: any) {}\r\n\r\n    visitQuote(ast: Quote, context: any) {}\r\n}","export function compileToJSON (json: any) {\r\n    return JSON.stringify(json).replace(/\"/g, '');\r\n}\r\n\r\nexport function isPresent(obj: any) {\r\n    return obj !== null && obj !== undefined;\r\n}\r\n\r\nexport function isJsObject(obj: any) {\r\n    return obj !== null && (typeof obj === 'function' || typeof obj === 'object');\r\n}\r\n\r\nexport function isFunction(val: any) {\r\n    return typeof val === 'function';\r\n}","import {\r\n    AST, RecursiveAstVisitor, PropertyRead, MethodCall, KeyedRead,\r\n    ImplicitReceiver, LiteralPrimitive, Binary, Chain, Conditional,\r\n    BindingPipe, FunctionCall, Interpolation, KeyedWrite, LiteralArray,\r\n    LiteralMap, PrefixNot, PropertyWrite, SafePropertyRead, SafeMethodCall, Quote\r\n} from '../../angular/compiler/ast';\r\nimport * as util from \"../../util/lang\";\r\n\r\nexport class JsonStringMapperVisitor extends RecursiveAstVisitor {\r\n\r\n    private _handleMethodArgs(args): any {\r\n        if (!args) {\r\n            return ``;\r\n        }\r\n\r\n        let result = ``;\r\n\r\n        for (let i = 0, length = args.length; i < length; i++) {\r\n            if (i === (length - 1)) {\r\n                result += `${args[i]}`;\r\n            }\r\n            else {\r\n                result += `${args[i]}, `;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private _handlePipeArgs(args): any {\r\n        if (!args) {\r\n            return ``;\r\n        }\r\n\r\n        let result = ``;\r\n\r\n        for (let arg of args) {\r\n            result += ` : ${arg}`;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    visitBinary(ast: Binary): any {\r\n        const left = ast.left.visit(this);\r\n        const right = ast.right.visit(this);\r\n\r\n        return `${left} ${ast.operation} ${right}`;\r\n    }\r\n\r\n    // TODO\r\n    visitChain(ast: Chain): any {\r\n        return util.compileToJSON(this.visitAll(ast.expressions));\r\n    }\r\n\r\n    visitConditional(ast: Conditional): any {\r\n        const condition = ast.condition.visit(this);\r\n        const trueExp = ast.trueExp.visit(this);\r\n        const falseExp = ast.falseExp.visit(this);\r\n\r\n        return `${condition} ? ${trueExp} : ${falseExp}`;\r\n    }\r\n\r\n    visitPipe(ast: BindingPipe): any {\r\n        const pipe = ast.name;\r\n        const value = ast.exp.visit(this);\r\n        const args = this._handlePipeArgs(this.visitAll(ast.args));\r\n\r\n        return `${value} | ${pipe}${args}`;\r\n    }\r\n\r\n    // TODO\r\n    visitFunctionCall(ast: FunctionCall): any {\r\n        const target = ast.target.visit(this);\r\n        const args = this._handleMethodArgs(this.visitAll(ast.args));\r\n\r\n        return `${target}(${args})`;\r\n    }\r\n\r\n    visitImplicitReceiver(ast: ImplicitReceiver): any {\r\n        return ``;\r\n    }\r\n\r\n    visitInterpolation(ast: Interpolation): any {\r\n        return `{{${this.visitAll(ast.expressions)[0]}}}`;\r\n    }\r\n\r\n    visitKeyedRead(ast: KeyedRead): any {\r\n        const obj = ast.obj.visit(this);\r\n        let key = ast.key.visit(this);\r\n\r\n        return `${obj}[${key}]`;\r\n    }\r\n\r\n    visitKeyedWrite(ast: KeyedWrite): any {\r\n        return null;\r\n    }\r\n\r\n    visitLiteralArray(ast: LiteralArray): any {\r\n        return util.compileToJSON(this.visitAll(ast.expressions));\r\n    }\r\n\r\n    visitLiteralMap(ast: LiteralMap, firstCall: boolean): any {\r\n        const result = {};\r\n        const keys = ast.keys;\r\n        const values = this.visitAll(ast.values);\r\n\r\n        for (let i = 0, length = keys.length; i < length; i++) {\r\n            let value = values[i];\r\n\r\n            if (typeof value !== 'string' && firstCall) {\r\n                value = `${value}`;\r\n            }\r\n\r\n            result[keys[i]] = value;\r\n        }\r\n\r\n        if (firstCall) {\r\n            return result;\r\n        }\r\n\r\n        return util.compileToJSON(result);\r\n    }\r\n\r\n    visitLiteralPrimitive(ast: LiteralPrimitive): any {\r\n        return typeof ast.value === 'string' ? `'${ast.value}'` : ast.value;\r\n    }\r\n\r\n    visitMethodCall(ast: MethodCall): any {\r\n        const methodName = ast.name;\r\n        const receiver = ast.receiver.visit(this);\r\n        const args = this._handleMethodArgs(this.visitAll(ast.args));\r\n\r\n        return `${receiver ? receiver + '.' : receiver}${methodName}(${args})`;\r\n    }\r\n\r\n    visitPrefixNot(ast: PrefixNot): any {\r\n        return ast.expression.visit(this);\r\n    }\r\n\r\n    visitPropertyRead(ast: PropertyRead): any {\r\n        const property = ast.name;\r\n        const receiver = ast.receiver.visit(this);\r\n\r\n        return `${receiver ? receiver + '.' : receiver}${property}`;\r\n    }\r\n\r\n    visitPropertyWrite(ast: PropertyWrite): any {\r\n        return null;\r\n    }\r\n\r\n    visitSafePropertyRead(ast: SafePropertyRead): any {\r\n        const property = ast.name;\r\n        const receiver = ast.receiver.visit(this);\r\n\r\n        return `${receiver ? receiver + '.' : receiver}${property}`;\r\n    }\r\n\r\n    visitSafeMethodCall(ast: SafeMethodCall): any {\r\n        const methodName = ast.name;\r\n        const receiver = ast.receiver.visit(this);\r\n        const args = this._handleMethodArgs(this.visitAll(ast.args));\r\n\r\n        return `${receiver ? receiver + '.' : receiver}${methodName}(${args})`;\r\n    }\r\n\r\n    visitAll(asts: AST[]): any {\r\n        return asts.map(ast => ast.visit(this));\r\n    }\r\n\r\n    visitQuote(ast: Quote): any {\r\n        return null;\r\n    }\r\n}","import {Parser, Lexer} from '../angular/compiler';\r\nimport {LiteralMap, ASTWithSource} from '../angular/compiler';\r\nimport {JsonStringMapperVisitor} from \"../visitors/json-string-mapper-visitor/json-string-mapper-visitor\";\r\n\r\nexport class JsonStringMapper {\r\n    private _parser: Parser = new Parser(new Lexer());\r\n    private _cache: Map<string, ASTWithSource> = new Map<string, ASTWithSource>();\r\n\r\n    map(expression: string): Map<string, string> {\r\n        let ast: ASTWithSource = null;\r\n        const visitor = new JsonStringMapperVisitor();\r\n\r\n        if (this._cache.has(expression)) {\r\n            ast = this._cache.get(expression);\r\n        }\r\n        else {\r\n            ast = this._parser.parseInterpolation(expression, 'JsonMapper');\r\n\r\n            if (ast) {\r\n                throw new Error(`JsonMapperVisitor ERROR: given expression must be json expression.`);\r\n            }\r\n            else {\r\n                ast = this._parser.parseBinding(expression, 'Parse');\r\n            }\r\n\r\n            if (!(ast.ast instanceof LiteralMap)) {\r\n                throw new Error(`JsonMapper ERROR: given expression must be json expression.`);\r\n            }\r\n\r\n            this._cache.set(expression, ast);\r\n        }\r\n\r\n        const jsonMap = new Map<string, string>();\r\n        const resultObj = ast.visit(visitor, true);\r\n        const keys = Object.keys(resultObj);\r\n\r\n        for (let i = 0, length = keys.length; i < length; i++) {\r\n            jsonMap.set(keys[i], resultObj[keys[i]]);\r\n        }\r\n\r\n        return jsonMap;\r\n    }\r\n}"],"names":["chars.$EOF","chars.$SPACE","chars.isDigit","chars.$PERIOD","chars.$LPAREN","chars.$RPAREN","chars.$LBRACE","chars.$RBRACE","chars.$LBRACKET","chars.$RBRACKET","chars.$COMMA","chars.$COLON","chars.$SEMICOLON","chars.$SQ","chars.$DQ","chars.$HASH","chars.$PLUS","chars.$MINUS","chars.$STAR","chars.$SLASH","chars.$PERCENT","chars.$CARET","chars.$QUESTION","chars.$LT","chars.$GT","chars.$EQ","chars.$BANG","chars.$AMPERSAND","chars.$BAR","chars.$NBSP","chars.isWhitespace","chars.$BACKSLASH","chars.$u","chars.$a","chars.$z","chars.$A","chars.$Z","chars.$_","chars.$$","chars.isAsciiLetter","chars.$e","chars.$E","chars.$BT","chars.$n","chars.$LF","chars.$f","chars.$FF","chars.$r","chars.$CR","chars.$t","chars.$TAB","chars.$v","chars.$VTAB","__extends","util.compileToJSON"],"mappings":"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"}